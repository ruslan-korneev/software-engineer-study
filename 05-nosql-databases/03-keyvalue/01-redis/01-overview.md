# Redis: Обзор

## Что такое Redis?

**Redis** (Remote Dictionary Server) — это высокопроизводительное хранилище данных типа "ключ-значение" с открытым исходным кодом. Redis хранит все данные в оперативной памяти (in-memory), что обеспечивает исключительно быстрый доступ к данным — операции чтения и записи выполняются за микросекунды.

Redis часто называют "структурным сервером данных", поскольку помимо простых строк он поддерживает множество сложных структур данных: списки, множества, хэши, отсортированные множества, битовые массивы, HyperLogLog и потоки (streams).

## Ключевые особенности Redis

### 1. In-Memory хранение

Все данные Redis хранятся в оперативной памяти, что даёт огромное преимущество в скорости по сравнению с дисковыми базами данных:

| Операция | Redis (RAM) | Традиционная СУБД (диск) |
|----------|-------------|--------------------------|
| Чтение   | ~1 мкс      | ~1-10 мс                 |
| Запись   | ~1 мкс      | ~1-10 мс                 |

Типичная производительность Redis: **100,000+ операций в секунду** на среднем сервере.

### 2. Single-Threaded архитектура

Redis использует однопоточную модель для обработки команд. Это может показаться ограничением, но на самом деле даёт преимущества:

- **Атомарность операций** — каждая команда выполняется полностью без прерываний
- **Отсутствие блокировок** — нет необходимости в механизмах синхронизации
- **Предсказуемая производительность** — нет накладных расходов на переключение контекста

Важно понимать, что Redis использует дополнительные потоки для:
- I/O операций (начиная с Redis 6.0)
- Фоновых задач (сохранение на диск, репликация)

### 3. Механизмы персистентности (Persistence)

Несмотря на хранение данных в RAM, Redis предоставляет механизмы сохранения данных на диск:

#### RDB (Redis Database Backup)
Создание снимков (snapshots) всей базы данных через заданные интервалы времени.

```
# Конфигурация в redis.conf
save 900 1      # сохранять, если за 900 сек изменился хотя бы 1 ключ
save 300 10     # сохранять, если за 300 сек изменилось 10 ключей
save 60 10000   # сохранять, если за 60 сек изменилось 10000 ключей
```

**Преимущества RDB:**
- Компактный формат файла
- Быстрое восстановление больших наборов данных
- Минимальное влияние на производительность

**Недостатки RDB:**
- Возможна потеря данных между снимками

#### AOF (Append-Only File)
Логирование каждой операции записи в файл.

```
# Конфигурация в redis.conf
appendonly yes
appendfsync everysec   # fsync каждую секунду (рекомендуется)
# appendfsync always   # fsync после каждой команды (надёжнее, но медленнее)
# appendfsync no       # fsync контролируется ОС (быстрее, но менее надёжно)
```

**Преимущества AOF:**
- Минимальная потеря данных (максимум 1 секунда при `appendfsync everysec`)
- Понятный текстовый формат лога
- Возможность редактирования (удаление ошибочных команд)

**Недостатки AOF:**
- Файл больше по размеру, чем RDB
- Восстановление медленнее

#### Гибридный подход (Redis 4.0+)
Комбинация RDB + AOF: RDB для быстрого восстановления основного объёма данных, AOF для последних изменений.

### 4. Поддерживаемые типы данных

| Тип | Описание | Пример использования |
|-----|----------|---------------------|
| String | Строка до 512 MB | Кэширование, счётчики |
| List | Связанный список строк | Очереди, лента новостей |
| Set | Неупорядоченное множество уникальных строк | Теги, уникальные посетители |
| Sorted Set | Множество с весами (scores) | Лидерборды, рейтинги |
| Hash | Словарь (ключ-значение) | Объекты, профили пользователей |
| Stream | Потоки данных | Event sourcing, логи |
| Bitmap | Битовые операции | Флаги, статистика присутствия |
| HyperLogLog | Вероятностная структура | Подсчёт уникальных элементов |
| Geospatial | Геолокационные данные | Поиск ближайших объектов |

## Сравнение с другими Key-Value хранилищами

| Характеристика | Redis | Memcached | etcd | Amazon DynamoDB |
|----------------|-------|-----------|------|-----------------|
| Типы данных | Множество | Только строки | Key-Value | Document + KV |
| Персистентность | RDB/AOF | Нет | Да (Raft) | Да |
| Кластеризация | Redis Cluster | Нет (внешняя) | Встроенная | Managed |
| Pub/Sub | Да | Нет | Watch | Streams |
| Транзакции | MULTI/EXEC | Нет | Да | Да |
| Lua скрипты | Да | Нет | Нет | Нет |
| Развёртывание | Self-hosted / Cloud | Self-hosted | Self-hosted / Cloud | Cloud only |
| Лицензия | BSD-3 | BSD | Apache 2.0 | Проприетарная |

### Когда выбрать Redis:
- Нужны сложные структуры данных
- Требуется персистентность
- Важен функционал Pub/Sub или Streams
- Нужны Lua скрипты для атомарных операций

### Когда выбрать Memcached:
- Простое кэширование строк
- Многопоточность важнее сложных структур
- Нужно максимально простое решение

## Типичные Use Cases

### 1. Кэширование (Caching)

Самый популярный сценарий использования Redis. Кэширование результатов запросов к базе данных, API-ответов, HTML-страниц.

```python
# Пример: кэширование результата запроса
def get_user(user_id):
    cache_key = f"user:{user_id}"

    # Попробовать получить из кэша
    cached = redis.get(cache_key)
    if cached:
        return json.loads(cached)

    # Если нет в кэше — запросить из БД
    user = db.query(f"SELECT * FROM users WHERE id = {user_id}")

    # Сохранить в кэш на 1 час
    redis.setex(cache_key, 3600, json.dumps(user))

    return user
```

### 2. Управление сессиями (Session Store)

Хранение пользовательских сессий в Redis вместо файлов или базы данных:
- Быстрый доступ
- Легко масштабировать (общий Redis для нескольких серверов приложений)
- Автоматическое истечение сессий через TTL

```python
# Сохранение сессии
redis.hset(f"session:{session_id}", mapping={
    "user_id": "12345",
    "username": "john_doe",
    "role": "admin"
})
redis.expire(f"session:{session_id}", 86400)  # 24 часа
```

### 3. Очереди сообщений (Message Queue)

Redis Lists можно использовать как простую очередь:

```python
# Производитель (Producer)
redis.lpush("task_queue", json.dumps({"task": "send_email", "to": "user@example.com"}))

# Потребитель (Consumer)
task = redis.brpop("task_queue", timeout=30)  # Блокирующее ожидание
```

Для более сложных сценариев используются Redis Streams (добавлены в Redis 5.0).

### 4. Pub/Sub (Publish/Subscribe)

Реализация паттерна "издатель-подписчик" для обмена сообщениями в реальном времени:

```python
# Издатель
redis.publish("notifications", json.dumps({"type": "new_message", "from": "user123"}))

# Подписчик
pubsub = redis.pubsub()
pubsub.subscribe("notifications")
for message in pubsub.listen():
    print(message)
```

Применение: чаты, уведомления в реальном времени, синхронизация между сервисами.

### 5. Rate Limiting

Ограничение частоты запросов с помощью счётчиков и TTL:

```python
def rate_limit(user_id, limit=100, window=60):
    key = f"rate:{user_id}:{int(time.time()) // window}"

    current = redis.incr(key)
    if current == 1:
        redis.expire(key, window)

    return current <= limit
```

### 6. Лидерборды и рейтинги

Redis Sorted Sets идеально подходят для реализации рейтингов:

```python
# Добавление/обновление счёта игрока
redis.zadd("leaderboard", {"player1": 1500, "player2": 2300, "player3": 1800})

# Топ-10 игроков
top_players = redis.zrevrange("leaderboard", 0, 9, withscores=True)

# Позиция конкретного игрока
rank = redis.zrevrank("leaderboard", "player1")
```

### 7. Счётчики и аналитика

Атомарные операции инкремента для сбора статистики:

```python
# Подсчёт просмотров статьи
redis.incr(f"views:article:{article_id}")

# Уникальные посетители (HyperLogLog)
redis.pfadd(f"visitors:{date}", user_id)
unique_count = redis.pfcount(f"visitors:{date}")
```

## Архитектура развёртывания

### Standalone
Один сервер Redis. Подходит для разработки и небольших проектов.

### Master-Replica (Репликация)
Один мастер для записи, несколько реплик для чтения. Обеспечивает:
- Масштабирование чтения
- Отказоустойчивость (failover)

### Redis Sentinel
Мониторинг и автоматический failover для Master-Replica конфигурации.

### Redis Cluster
Горизонтальное масштабирование через шардирование данных по нескольким узлам. Поддерживает:
- Автоматическое шардирование
- Репликацию внутри кластера
- Автоматический failover

## Заключение

Redis — это мощный и гибкий инструмент, который выходит далеко за рамки простого key-value хранилища. Его скорость, богатый набор структур данных и дополнительные возможности (персистентность, Pub/Sub, Lua скрипты) делают Redis незаменимым компонентом современной backend-инфраструктуры.

При правильном использовании Redis может значительно улучшить производительность приложения и упростить реализацию многих паттернов (кэширование, очереди, сессии, rate limiting).
