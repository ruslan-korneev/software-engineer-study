# Стратегии слияния в Git

## Введение

Слияние (merge) — это фундаментальная операция в Git, которая объединяет изменения из разных веток. Выбор правильной стратегии слияния критически важен для поддержания чистой истории проекта и эффективной командной работы.

Git предоставляет несколько стратегий слияния, каждая из которых подходит для определённых сценариев.

---

## 1. Fast-Forward Merge

### Что это такое

Fast-forward (перемотка вперёд) — самая простая стратегия слияния. Она применяется, когда целевая ветка не имеет новых коммитов с момента создания feature-ветки.

### Как работает

```
До слияния:
main:     A --- B --- C
                      \
feature:               D --- E

После fast-forward merge:
main:     A --- B --- C --- D --- E
```

Git просто "перемещает" указатель `main` на последний коммит feature-ветки. Никакого нового коммита не создаётся.

### Команды

```bash
# Переключиться на целевую ветку
git checkout main

# Выполнить слияние (по умолчанию fast-forward, если возможно)
git merge feature

# Принудительно отключить fast-forward (создать merge-коммит)
git merge --no-ff feature

# Разрешить только fast-forward (отменить если невозможно)
git merge --ff-only feature
```

### Преимущества

- Чистая линейная история
- Нет лишних merge-коммитов
- Простота отслеживания изменений

### Недостатки

- Теряется информация о том, что изменения были в отдельной ветке
- Невозможен, если в целевой ветке есть новые коммиты

### Когда использовать

- Для небольших быстрых фиксов
- Когда линейная история важнее сохранения информации о ветках
- В личных проектах

---

## 2. 3-Way Merge (Recursive)

### Что это такое

Трёхстороннее слияние — основная стратегия Git для объединения веток, когда обе ветки имеют уникальные коммиты. Называется "трёхсторонним", потому что использует три точки:
1. Общий предок (base)
2. Кончик первой ветки
3. Кончик второй ветки

### Как работает

```
До слияния:
main:     A --- B --- C --- F
                      \
feature:               D --- E

После 3-way merge:
main:     A --- B --- C --- F --- M
                      \         /
feature:               D --- E
```

Git создаёт новый "merge-коммит" (M), который имеет двух родителей.

### Команды

```bash
# Стандартное слияние (Git выберет стратегию автоматически)
git checkout main
git merge feature

# С сообщением для merge-коммита
git merge feature -m "Merge feature: добавлена авторизация"

# Выбор стратегии явно
git merge -s recursive feature
```

### Опции стратегии recursive

```bash
# При конфликтах предпочитать изменения из нашей ветки
git merge -X ours feature

# При конфликтах предпочитать изменения из вливаемой ветки
git merge -X theirs feature

# Игнорировать изменения в пробелах
git merge -X ignore-all-space feature
```

### Преимущества

- Сохраняет полную историю разработки
- Явно показывает, когда и какие ветки были объединены
- Легко отменить слияние целиком

### Недостатки

- История становится нелинейной (граф вместо линии)
- Много merge-коммитов может засорить историю

### Когда использовать

- В командной разработке
- Для долгоживущих feature-веток
- Когда важно сохранить контекст разработки

---

## 3. Squash Merge

### Что это такое

Squash merge — стратегия, которая объединяет все коммиты из feature-ветки в один коммит и добавляет его в целевую ветку. Оригинальная история feature-ветки не сохраняется.

### Как работает

```
До слияния:
main:     A --- B --- C
                      \
feature:               D --- E --- F

После squash merge:
main:     A --- B --- C --- S

(feature остаётся как есть, но S содержит все изменения D+E+F)
```

### Команды

```bash
# Выполнить squash merge
git checkout main
git merge --squash feature

# Git подготовит изменения, но не создаст коммит
# Нужно закоммитить вручную
git commit -m "Feature: добавлена система уведомлений"

# После squash merge feature-ветку можно удалить
git branch -D feature  # -D потому что Git не считает её слитой
```

### Пример с GitHub/GitLab

В веб-интерфейсе при merge pull request можно выбрать "Squash and merge":

```
Все коммиты в PR:
- Fix typo
- WIP: working on feature
- Add feature
- Fix tests
- Final cleanup

После squash merge станет один коммит:
- Add notification system (#123)
```

### Преимущества

- Чистая линейная история в main
- Один осмысленный коммит вместо множества промежуточных
- Скрывает "грязную" историю разработки (WIP, fixup)

### Недостатки

- Теряется детальная история изменений
- Feature-ветка не помечается как слитая
- Сложнее отслеживать, кто и когда делал конкретные изменения

### Когда использовать

- Когда в feature-ветке много мелких/промежуточных коммитов
- Для поддержания чистой истории main-ветки
- В проектах с требованием atomic commits

---

## 4. Rebase как альтернатива Merge

### Что это такое

Rebase (перебазирование) — операция, которая "переносит" коммиты одной ветки на кончик другой, переписывая историю. Это не слияние в традиционном смысле, но достигает той же цели.

### Как работает

```
До rebase:
main:     A --- B --- C --- F
                      \
feature:               D --- E

После git rebase main (находясь в feature):
main:     A --- B --- C --- F
                              \
feature:                       D' --- E'

После fast-forward merge:
main:     A --- B --- C --- F --- D' --- E'
```

D' и E' — это новые коммиты (с новыми хешами), содержащие те же изменения.

### Команды

```bash
# Находясь в feature-ветке, перебазировать на main
git checkout feature
git rebase main

# Интерактивный rebase (редактирование, объединение коммитов)
git rebase -i main

# При конфликтах
git rebase --continue  # продолжить после разрешения
git rebase --abort     # отменить rebase
git rebase --skip      # пропустить проблемный коммит

# После rebase — fast-forward merge в main
git checkout main
git merge feature  # теперь это будет fast-forward
```

### Интерактивный rebase

```bash
git rebase -i HEAD~3

# Откроется редактор:
pick abc1234 Add feature base
pick def5678 Fix typo
pick ghi9012 Add tests

# Можно изменить на:
pick abc1234 Add feature base
squash def5678 Fix typo      # объединить с предыдущим
reword ghi9012 Add tests     # изменить сообщение
```

Команды интерактивного rebase:
- `pick` — использовать коммит как есть
- `reword` — изменить сообщение коммита
- `edit` — остановиться для внесения изменений
- `squash` — объединить с предыдущим, сохранив сообщение
- `fixup` — объединить с предыдущим, отбросив сообщение
- `drop` — удалить коммит

### Преимущества

- Линейная, чистая история
- Нет merge-коммитов
- Можно "почистить" историю перед слиянием

### Недостатки

- Переписывает историю (меняются хеши коммитов)
- Опасно для уже опубликованных веток
- Сложнее для начинающих

### Золотое правило Rebase

**Никогда не делайте rebase коммитов, которые уже были отправлены в публичный репозиторий и могут использоваться другими разработчиками.**

```bash
# ПЛОХО — rebase публичной ветки
git checkout main
git rebase feature  # НЕ ДЕЛАЙТЕ ТАК!

# ХОРОШО — rebase своей локальной feature-ветки на main
git checkout feature
git rebase main
```

### Когда использовать

- Для обновления feature-ветки изменениями из main
- Перед merge для очистки истории
- В личных/локальных ветках

---

## 5. Сравнительная таблица

| Стратегия | История | Merge-коммит | Сложность | Применение |
|-----------|---------|--------------|-----------|------------|
| Fast-forward | Линейная | Нет | Низкая | Быстрые фиксы |
| 3-way merge | Нелинейная | Да | Средняя | Командная работа |
| Squash merge | Линейная | Нет (1 коммит) | Средняя | Чистый main |
| Rebase + FF | Линейная | Нет | Высокая | Чистая история |

---

## 6. Стратегии в реальных проектах

### Git Flow

```bash
# Feature -> develop: squash или merge
git checkout develop
git merge --no-ff feature/auth

# Release -> main: merge
git checkout main
git merge --no-ff release/1.0

# Hotfix -> main и develop: merge
git checkout main
git merge --no-ff hotfix/critical-bug
git checkout develop
git merge --no-ff hotfix/critical-bug
```

### GitHub Flow

```bash
# Feature -> main: обычно squash через Pull Request
# Настраивается в Settings репозитория

# Локально обновить feature-ветку:
git checkout feature
git rebase main  # или git merge main
git push --force-with-lease  # после rebase
```

### Trunk-Based Development

```bash
# Очень короткоживущие ветки
# Частые слияния в main
git checkout main
git merge --ff-only feature  # только fast-forward
```

---

## 7. Разрешение конфликтов

При любой стратегии слияния могут возникнуть конфликты.

### Процесс разрешения

```bash
# 1. Git сообщает о конфликте
git merge feature
# CONFLICT (content): Merge conflict in file.txt

# 2. Посмотреть статус
git status

# 3. Открыть файл — найти маркеры конфликта
<<<<<<< HEAD
код из текущей ветки
=======
код из вливаемой ветки
>>>>>>> feature

# 4. Отредактировать файл, убрав маркеры и оставив нужный код

# 5. Добавить файл и завершить merge
git add file.txt
git commit  # или git merge --continue
```

### Инструменты для разрешения конфликтов

```bash
# Использовать встроенный mergetool
git mergetool

# Настроить mergetool
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait $MERGED'
```

---

## 8. Best Practices

### Общие рекомендации

1. **Договоритесь о стратегии в команде** — все должны следовать одному подходу
2. **Настройте защиту веток** — запретите прямые push в main
3. **Используйте Pull Requests** — код-ревью перед слиянием
4. **Пишите осмысленные сообщения** — особенно для merge и squash коммитов

### Рекомендации по выбору стратегии

```bash
# Для личных проектов
git merge --ff-only feature  # простая линейная история

# Для командных проектов
git merge --no-ff feature    # сохранение контекста

# Для больших feature
git merge --squash feature   # чистая история main

# Перед merge любой стратегией
git checkout feature
git rebase main              # актуализировать feature
```

### Настройка поведения по умолчанию

```bash
# Запретить fast-forward по умолчанию
git config --global merge.ff false

# Разрешить только fast-forward (если возможно)
git config --global merge.ff only

# Настройка для pull
git config --global pull.rebase true  # rebase вместо merge при pull
```

---

## Заключение

Выбор стратегии слияния зависит от:
- Размера команды
- Требований к истории
- Принятого workflow
- Конкретной ситуации

Не существует единственно правильного подхода. Главное — последовательность и понимание последствий каждой стратегии.
