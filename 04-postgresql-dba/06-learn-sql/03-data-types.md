# Типы данных в PostgreSQL

## Обзор типов данных

PostgreSQL предлагает богатый набор встроенных типов данных, а также возможность создавать собственные типы. Правильный выбор типа данных важен для:
- Целостности данных
- Производительности запросов
- Экономии дискового пространства

---

## Числовые типы

### Целые числа

| Тип | Размер | Диапазон |
|-----|--------|----------|
| `SMALLINT` | 2 байта | -32768 до 32767 |
| `INTEGER` / `INT` | 4 байта | -2147483648 до 2147483647 |
| `BIGINT` | 8 байт | -9223372036854775808 до 9223372036854775807 |

```sql
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    quantity SMALLINT,
    total_sold BIGINT
);
```

### Автоинкремент

| Тип | Эквивалент | Использование |
|-----|------------|---------------|
| `SERIAL` | `INTEGER` + sequence | Стандартный ID |
| `SMALLSERIAL` | `SMALLINT` + sequence | Маленькие таблицы |
| `BIGSERIAL` | `BIGINT` + sequence | Большие таблицы |

```sql
-- Старый способ (все еще работает)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50)
);

-- Современный способ (PostgreSQL 10+)
CREATE TABLE users (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    username VARCHAR(50)
);

-- С возможностью вставки своих значений
CREATE TABLE users (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50)
);
```

### Числа с плавающей точкой

| Тип | Размер | Точность |
|-----|--------|----------|
| `REAL` / `FLOAT4` | 4 байта | 6 знаков |
| `DOUBLE PRECISION` / `FLOAT8` | 8 байт | 15 знаков |

```sql
-- Приблизительные вычисления (физика, статистика)
CREATE TABLE measurements (
    id SERIAL PRIMARY KEY,
    temperature REAL,
    pressure DOUBLE PRECISION
);

-- ВНИМАНИЕ: проблемы с точностью
SELECT 0.1::REAL + 0.2::REAL;  -- 0.30000001192092896
```

### Точные числа (NUMERIC / DECIMAL)

```sql
-- NUMERIC(precision, scale)
-- precision - общее количество цифр
-- scale - количество цифр после запятой

CREATE TABLE prices (
    id SERIAL PRIMARY KEY,
    price NUMERIC(10, 2),      -- до 99999999.99
    tax_rate NUMERIC(5, 4),    -- до 9.9999
    discount NUMERIC(3, 2)     -- до 9.99
);

-- Без указания точности - неограниченная точность
CREATE TABLE scientific_data (
    value NUMERIC  -- точные вычисления любой точности
);
```

### Когда что использовать:

| Задача | Тип |
|--------|-----|
| ID записей | `INTEGER` / `BIGINT` |
| Деньги | `NUMERIC(p, 2)` |
| Научные расчеты | `DOUBLE PRECISION` |
| Проценты | `NUMERIC(5, 2)` |
| Счетчики | `INTEGER` / `BIGINT` |

---

## Текстовые типы

### Основные текстовые типы

| Тип | Описание | Макс. размер |
|-----|----------|--------------|
| `CHAR(n)` | Фиксированная длина | n символов |
| `VARCHAR(n)` | Переменная длина | до n символов |
| `TEXT` | Неограниченная длина | ~1 GB |

```sql
CREATE TABLE users (
    -- Фиксированная длина (дополняется пробелами)
    country_code CHAR(2),        -- 'RU', 'US'

    -- Переменная длина с ограничением
    username VARCHAR(50),
    email VARCHAR(255),

    -- Неограниченная длина
    bio TEXT,
    content TEXT
);
```

### Особенности

```sql
-- CHAR дополняется пробелами
SELECT 'abc'::CHAR(5) = 'abc  ';  -- true

-- VARCHAR не дополняется
SELECT LENGTH('abc'::VARCHAR(10));  -- 3

-- TEXT и VARCHAR(n) идентичны по производительности
-- TEXT предпочтительнее, если нет ограничений на длину
```

### Поиск и сравнение

```sql
-- Регистрозависимое сравнение
SELECT * FROM users WHERE username = 'John';

-- Регистронезависимое сравнение
SELECT * FROM users WHERE LOWER(username) = 'john';
SELECT * FROM users WHERE username ILIKE 'john';

-- COLLATE для локали
SELECT * FROM users ORDER BY name COLLATE "ru_RU";
```

---

## Дата и время

### Типы даты и времени

| Тип | Описание | Пример |
|-----|----------|--------|
| `DATE` | Только дата | 2024-01-15 |
| `TIME` | Только время | 14:30:00 |
| `TIMESTAMP` | Дата и время | 2024-01-15 14:30:00 |
| `TIMESTAMPTZ` | С часовым поясом | 2024-01-15 14:30:00+03 |
| `INTERVAL` | Интервал времени | 2 hours 30 minutes |

```sql
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    event_date DATE,
    start_time TIME,
    created_at TIMESTAMP DEFAULT NOW(),
    scheduled_at TIMESTAMPTZ,
    duration INTERVAL
);

-- Вставка данных
INSERT INTO events (event_date, start_time, scheduled_at, duration)
VALUES (
    '2024-06-15',
    '09:00:00',
    '2024-06-15 09:00:00+03',
    '2 hours'
);
```

### Работа с датами

```sql
-- Текущие дата и время
SELECT CURRENT_DATE;           -- 2024-01-15
SELECT CURRENT_TIME;           -- 14:30:00.123456
SELECT NOW();                  -- 2024-01-15 14:30:00.123456+03
SELECT CURRENT_TIMESTAMP;      -- то же, что NOW()

-- Извлечение частей даты
SELECT EXTRACT(YEAR FROM NOW());    -- 2024
SELECT EXTRACT(MONTH FROM NOW());   -- 1
SELECT EXTRACT(DOW FROM NOW());     -- день недели (0=воскресенье)

-- DATE_PART (синоним EXTRACT)
SELECT DATE_PART('hour', NOW());

-- Форматирование
SELECT TO_CHAR(NOW(), 'DD.MM.YYYY HH24:MI:SS');  -- 15.01.2024 14:30:00
SELECT TO_CHAR(NOW(), 'Day, DD Month YYYY');     -- Monday, 15 January 2024

-- Арифметика с датами
SELECT NOW() + INTERVAL '1 day';
SELECT NOW() - INTERVAL '2 weeks';
SELECT '2024-12-31'::DATE - '2024-01-01'::DATE;  -- 365 (дней)

-- Усечение даты
SELECT DATE_TRUNC('month', NOW());  -- 2024-01-01 00:00:00
SELECT DATE_TRUNC('hour', NOW());   -- 2024-01-15 14:00:00
```

### TIMESTAMP vs TIMESTAMPTZ

```sql
-- TIMESTAMP - хранит как есть
-- TIMESTAMPTZ - конвертирует в UTC при хранении

SET timezone = 'Europe/Moscow';

INSERT INTO events (local_time, utc_time) VALUES
    ('2024-01-15 12:00:00'::TIMESTAMP,
     '2024-01-15 12:00:00'::TIMESTAMPTZ);

-- local_time: 2024-01-15 12:00:00 (как есть)
-- utc_time: 2024-01-15 12:00:00+03 (интерпретировано как Moscow)

SET timezone = 'UTC';
SELECT utc_time FROM events;  -- 2024-01-15 09:00:00+00
```

**Рекомендация:** Всегда используйте `TIMESTAMPTZ` для хранения моментов времени.

---

## Логический тип (Boolean)

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    is_admin BOOLEAN
);

-- Допустимые значения
INSERT INTO users (is_active) VALUES (true);
INSERT INTO users (is_active) VALUES (false);
INSERT INTO users (is_active) VALUES ('yes');
INSERT INTO users (is_active) VALUES ('no');
INSERT INTO users (is_active) VALUES ('1');
INSERT INTO users (is_active) VALUES ('0');
INSERT INTO users (is_active) VALUES (NULL);

-- Условия
SELECT * FROM users WHERE is_active;           -- true
SELECT * FROM users WHERE NOT is_active;       -- false
SELECT * FROM users WHERE is_active IS NULL;   -- NULL
```

---

## UUID

```sql
-- Включение расширения
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Или использовать встроенную функцию (PostgreSQL 13+)
CREATE TABLE orders (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_number VARCHAR(50)
);

-- Генерация UUID
SELECT gen_random_uuid();  -- a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
SELECT uuid_generate_v4();  -- требует uuid-ossp

-- UUID как первичный ключ
INSERT INTO orders (order_number) VALUES ('ORD-001')
RETURNING id;
```

### Преимущества UUID:
- Глобальная уникальность
- Можно генерировать на клиенте
- Безопасность (не угадаешь следующий ID)

### Недостатки UUID:
- Больше места (16 байт vs 4/8 для INT)
- Хуже для индексов (случайные значения)
- Сложнее для отладки

---

## JSON и JSONB

### Различия JSON и JSONB

| Характеристика | JSON | JSONB |
|---------------|------|-------|
| Хранение | Текст | Бинарный формат |
| Скорость записи | Быстрее | Медленнее |
| Скорость чтения | Медленнее | Быстрее |
| Индексы | Нет | GIN индексы |
| Сохранение порядка ключей | Да | Нет |
| Дубликаты ключей | Разрешены | Последний побеждает |

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    attributes JSONB
);

-- Вставка JSON
INSERT INTO products (name, attributes) VALUES
    ('Laptop', '{"brand": "Dell", "ram": 16, "ssd": true}'),
    ('Phone', '{"brand": "Apple", "model": "iPhone 15", "colors": ["black", "white"]}');
```

### Операторы JSONB

```sql
-- Извлечение значения как JSON
SELECT attributes->'brand' FROM products;  -- "Dell"

-- Извлечение как текст
SELECT attributes->>'brand' FROM products;  -- Dell

-- Вложенные пути
SELECT attributes->'specs'->'cpu'->>'cores' FROM products;

-- Оператор #> для пути
SELECT attributes #> '{specs, cpu}' FROM products;
SELECT attributes #>> '{specs, cpu, cores}' FROM products;

-- Проверка наличия ключа
SELECT * FROM products WHERE attributes ? 'brand';

-- Проверка наличия любого из ключей
SELECT * FROM products WHERE attributes ?| array['brand', 'model'];

-- Проверка наличия всех ключей
SELECT * FROM products WHERE attributes ?& array['brand', 'model'];

-- Проверка содержимого
SELECT * FROM products WHERE attributes @> '{"brand": "Dell"}';

-- Проверка вхождения
SELECT * FROM products WHERE '{"brand": "Dell"}' <@ attributes;
```

### Функции JSONB

```sql
-- Объединение
SELECT '{"a": 1}'::JSONB || '{"b": 2}'::JSONB;  -- {"a": 1, "b": 2}

-- Удаление ключа
SELECT '{"a": 1, "b": 2}'::JSONB - 'a';  -- {"b": 2}

-- Удаление по пути
SELECT '{"a": {"b": 1}}'::JSONB #- '{a, b}';  -- {"a": {}}

-- Установка значения
SELECT jsonb_set('{"a": 1}'::JSONB, '{b}', '2');  -- {"a": 1, "b": 2}

-- Извлечение ключей
SELECT jsonb_object_keys('{"a": 1, "b": 2}'::JSONB);

-- Разворачивание массива
SELECT jsonb_array_elements('[1, 2, 3]'::JSONB);

-- Преобразование в записи
SELECT * FROM jsonb_to_record('{"name": "John", "age": 30}'::JSONB)
    AS x(name TEXT, age INT);
```

### Индексы для JSONB

```sql
-- GIN индекс для всего документа
CREATE INDEX idx_products_attrs ON products USING GIN (attributes);

-- Индекс для конкретного пути
CREATE INDEX idx_products_brand ON products USING BTREE ((attributes->>'brand'));

-- Использование индексов
SELECT * FROM products WHERE attributes @> '{"brand": "Dell"}';  -- использует GIN
SELECT * FROM products WHERE attributes->>'brand' = 'Dell';  -- использует BTREE
```

---

## Массивы (Arrays)

```sql
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    tags TEXT[],
    ratings INTEGER[]
);

-- Вставка массивов
INSERT INTO posts (title, tags, ratings) VALUES
    ('SQL Tutorial', ARRAY['sql', 'database', 'postgresql'], ARRAY[5, 4, 5]),
    ('Python Basics', '{"python", "programming"}', '{4, 5, 3}');

-- Доступ к элементам (индексация с 1)
SELECT tags[1] FROM posts;  -- первый элемент

-- Срез
SELECT tags[1:2] FROM posts;  -- первые два элемента

-- Проверка наличия элемента
SELECT * FROM posts WHERE 'sql' = ANY(tags);
SELECT * FROM posts WHERE tags @> ARRAY['sql'];

-- Пересечение массивов
SELECT * FROM posts WHERE tags && ARRAY['sql', 'python'];

-- Длина массива
SELECT array_length(tags, 1) FROM posts;

-- Разворачивание массива
SELECT id, unnest(tags) AS tag FROM posts;

-- Агрегация в массив
SELECT array_agg(tag) FROM unnest(ARRAY['a', 'b', 'c']) AS tag;
```

---

## Перечисления (ENUM)

```sql
-- Создание типа
CREATE TYPE order_status AS ENUM ('pending', 'processing', 'shipped', 'delivered', 'cancelled');

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    status order_status DEFAULT 'pending'
);

-- Вставка
INSERT INTO orders (status) VALUES ('processing');

-- Ошибка при неверном значении
INSERT INTO orders (status) VALUES ('unknown');  -- ERROR

-- Добавление значения
ALTER TYPE order_status ADD VALUE 'refunded' AFTER 'delivered';

-- Получение всех значений
SELECT enum_range(NULL::order_status);
```

---

## Специальные типы

### MONEY

```sql
-- Не рекомендуется - используйте NUMERIC
CREATE TABLE old_prices (
    price MONEY
);

-- Лучше
CREATE TABLE prices (
    price NUMERIC(12, 2)
);
```

### Network Types

```sql
CREATE TABLE servers (
    id SERIAL PRIMARY KEY,
    ip_address INET,
    mac_address MACADDR,
    network CIDR
);

INSERT INTO servers (ip_address, network) VALUES
    ('192.168.1.100', '192.168.1.0/24');

-- Проверка вхождения в сеть
SELECT * FROM servers WHERE ip_address << '192.168.0.0/16'::CIDR;
```

### Geometric Types

```sql
CREATE TABLE locations (
    id SERIAL PRIMARY KEY,
    point POINT,
    area BOX
);

INSERT INTO locations (point, area) VALUES
    ('(55.7558, 37.6173)', '((0,0),(10,10))');

-- Расстояние между точками
SELECT point <-> '(55.7522, 37.6156)' FROM locations;
```

---

## Лучшие практики

### 1. Выбор правильного типа

```sql
-- Для ID
id BIGINT GENERATED ALWAYS AS IDENTITY

-- Для денег
price NUMERIC(12, 2)

-- Для времени
created_at TIMESTAMPTZ DEFAULT NOW()

-- Для текста без ограничений
description TEXT

-- Для ограниченного текста
username VARCHAR(50)
```

### 2. Избегайте неявных преобразований

```sql
-- Плохо: индекс не используется
SELECT * FROM users WHERE id = '123';

-- Хорошо
SELECT * FROM users WHERE id = 123;
```

### 3. Используйте CHECK для ограничений

```sql
CREATE TABLE products (
    price NUMERIC(10, 2) CHECK (price >= 0),
    status VARCHAR(20) CHECK (status IN ('active', 'inactive', 'deleted'))
);
```

### 4. NULL vs Default

```sql
-- Явный NULL когда отсутствие значения важно
phone VARCHAR(20),  -- NULL = телефон не указан

-- Default когда есть разумное значение по умолчанию
is_active BOOLEAN DEFAULT true,
created_at TIMESTAMPTZ DEFAULT NOW()
```
