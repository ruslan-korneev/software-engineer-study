# Управление памятью (Memory Management)

## Определение

**Управление памятью** — это функция операционной системы, отвечающая за эффективное распределение оперативной памяти (RAM) между процессами, защиту памяти и оптимизацию её использования.

## Иерархия памяти

```
┌─────────────────────────────────────────────────────┐
│  Регистры CPU     │  < 1 КБ   │  < 1 нс    │ Самая │
├───────────────────┼───────────┼────────────┤ быст- │
│  Кэш L1           │  32-64 КБ │  ~1 нс     │ рая   │
├───────────────────┼───────────┼────────────┤       │
│  Кэш L2           │  256 КБ   │  ~4 нс     │       │
├───────────────────┼───────────┼────────────┤       │
│  Кэш L3           │  8-64 МБ  │  ~12 нс    │       │
├───────────────────┼───────────┼────────────┤       ↓
│  RAM (ОЗУ)        │  8-128 ГБ │  ~100 нс   │       │
├───────────────────┼───────────┼────────────┤       │
│  SSD              │  256 ГБ+  │  ~100 мкс  │       │
├───────────────────┼───────────┼────────────┤       │
│  HDD              │  1 ТБ+    │  ~10 мс    │ Самая │
└─────────────────────────────────────────────│ медл. │
```

## Адресное пространство процесса

### Структура памяти процесса

```
Высокие адреса
┌────────────────────────────────────┐ 0xFFFFFFFF
│         Kernel Space               │ (ядро ОС)
├────────────────────────────────────┤ 0xC0000000
│              Stack                 │ ↓ Растёт вниз
│         (локальные переменные,     │
│          адреса возврата)          │
├────────────────────────────────────┤
│                                    │
│         (свободная память)         │
│                                    │
├────────────────────────────────────┤
│              Heap                  │ ↑ Растёт вверх
│     (динамически выделенная        │
│            память)                 │
├────────────────────────────────────┤
│         BSS Segment                │ (неинициализированные
│                                    │  глобальные переменные)
├────────────────────────────────────┤
│         Data Segment               │ (инициализированные
│                                    │  глобальные переменные)
├────────────────────────────────────┤
│         Text Segment               │ (исполняемый код)
│            (Code)                  │ (только чтение)
└────────────────────────────────────┘ 0x00000000
Низкие адреса
```

## Виртуальная память

### Концепция виртуальной памяти

**Виртуальная память** — механизм, создающий иллюзию большего объёма памяти, чем физически доступно. Каждый процесс имеет собственное виртуальное адресное пространство.

```
┌──────────────────┐      ┌──────────────────┐
│ Процесс A        │      │ Процесс B        │
│ Виртуальная      │      │ Виртуальная      │
│ память           │      │ память           │
│ ┌──────────────┐ │      │ ┌──────────────┐ │
│ │ Страница 0   │─┼──┐   │ │ Страница 0   │─┼─┐
│ │ Страница 1   │─┼──┼───┼─│ Страница 1   │ │ │
│ │ Страница 2   │─┼─┐│   │ │ Страница 2   │─┼─┼┐
│ └──────────────┘ │ ││   │ └──────────────┘ │ ││
└──────────────────┘ ││   └──────────────────┘ ││
                     ││                        ││
      ┌──────────────┼┼────────────────────────┼┘
      ↓              ↓↓                        ↓
┌─────────────────────────────────────────────────┐
│          Физическая память (RAM)                │
│ ┌─────────┬─────────┬─────────┬─────────┬─────┐ │
│ │Frame 0  │Frame 1  │Frame 2  │Frame 3  │ ... │ │
│ └─────────┴─────────┴─────────┴─────────┴─────┘ │
└─────────────────────────────────────────────────┘
```

### Преимущества виртуальной памяти

1. **Изоляция процессов** — каждый процесс думает, что владеет всей памятью
2. **Защита памяти** — процессы не могут читать/писать память друг друга
3. **Расширение памяти** — использование диска как продолжения RAM (swap)
4. **Упрощение программирования** — унифицированное адресное пространство

## Страничная организация (Paging)

### Как работает paging

Виртуальная память делится на **страницы (pages)**, физическая — на **фреймы (frames)**. Типичный размер: 4 КБ.

```
Виртуальный адрес (32 бита):
┌──────────────────────┬───────────────┐
│ Номер страницы (20)  │ Смещение (12) │
└──────────────────────┴───────────────┘

Трансляция адреса:
Виртуальный адрес → Page Table → Физический адрес

Page Table (таблица страниц):
┌─────────────┬─────────────────────────┐
│ Page Number │ Frame Number │ Флаги    │
├─────────────┼─────────────────────────┤
│     0       │     5        │ RW-      │
│     1       │    12        │ R--      │
│     2       │   SWAP       │ ---      │
│    ...      │   ...        │ ...      │
└─────────────┴─────────────────────────┘
```

### Page Fault (Страничная ошибка)

Возникает, когда запрашиваемая страница отсутствует в RAM:

1. Процесс обращается к адресу
2. MMU проверяет Page Table
3. Страница отсутствует → Page Fault
4. ОС загружает страницу с диска в RAM
5. Обновляет Page Table
6. Повторяет инструкцию

## Сегментация (Segmentation)

Память делится на логические сегменты разного размера:
- Code segment
- Data segment
- Stack segment

```
┌────────────────────────────────────────┐
│  Segment Table                         │
├──────────┬─────────┬───────────────────┤
│ Segment  │ Base    │ Limit (размер)    │
├──────────┼─────────┼───────────────────┤
│ Code     │ 0x1000  │ 0x0500            │
│ Data     │ 0x2000  │ 0x0300            │
│ Stack    │ 0x3000  │ 0x0400            │
└──────────┴─────────┴───────────────────┘
```

## Алгоритмы замещения страниц

Когда RAM заполнена и нужна новая страница, какую выгрузить на диск?

### 1. FIFO (First-In, First-Out)
```
Страницы: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Фреймы (3):
[1] → [1,2] → [1,2,3] → [4,2,3] → [4,1,3] → [4,1,2] → [5,1,2] → ...
```
Выгружается самая старая страница.

### 2. LRU (Least Recently Used)
Выгружается страница, которая дольше всего не использовалась.
```
Оптимальнее FIFO, но сложнее в реализации.
```

### 3. Optimal (Оптимальный)
Выгружается страница, которая не понадобится дольше всего.
```
Теоретически идеален, но требует знания будущего.
Используется как эталон для сравнения.
```

### 4. Clock (Second Chance)
Модификация FIFO с битом использования.

## Управление памятью в Linux

### Просмотр информации о памяти

```bash
# Общая информация о памяти
free -h
#               total        used        free      shared  buff/cache   available
# Mem:           15Gi       8.2Gi       2.1Gi       1.2Gi       5.4Gi       5.9Gi
# Swap:          8.0Gi       0.5Gi       7.5Gi

# Детальная информация
cat /proc/meminfo

# Использование памяти процессами
top -o %MEM
# или
ps aux --sort=-%mem | head

# Память конкретного процесса
pmap <PID>
cat /proc/<PID>/maps
cat /proc/<PID>/status | grep -i mem
```

### Swap (подкачка)

```bash
# Информация о swap
swapon --show

# Создание swap-файла
sudo fallocate -l 4G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile

# Настройка swappiness (0-100)
# 0 = минимальное использование swap
# 100 = агрессивное использование swap
cat /proc/sys/vm/swappiness
sudo sysctl vm.swappiness=10
```

## Динамическое выделение памяти

### В C

```c
#include <stdlib.h>
#include <string.h>

int main() {
    // Выделение памяти
    int *arr = (int*)malloc(10 * sizeof(int));  // 10 int'ов

    // Инициализация нулями
    int *zeros = (int*)calloc(10, sizeof(int));

    // Изменение размера
    arr = (int*)realloc(arr, 20 * sizeof(int));

    // Освобождение памяти (ВАЖНО!)
    free(arr);
    free(zeros);

    return 0;
}
```

### В Python

```python
import sys

# Python управляет памятью автоматически
my_list = [1, 2, 3, 4, 5]

# Размер объекта в памяти
print(sys.getsizeof(my_list))  # размер в байтах

# Сборщик мусора (garbage collector)
import gc

# Принудительная сборка мусора
gc.collect()

# Информация о сборке мусора
print(gc.get_stats())

# Отслеживание утечек памяти
import tracemalloc
tracemalloc.start()

# ... код ...

snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics('lineno')
for stat in top_stats[:10]:
    print(stat)
```

## Проблемы управления памятью

### 1. Утечка памяти (Memory Leak)

```c
// Плохо: память выделена, но не освобождена
void leaky_function() {
    int *ptr = malloc(1000);
    // ... работа с ptr ...
    // Забыли free(ptr)!
}

// Хорошо: всегда освобождаем память
void good_function() {
    int *ptr = malloc(1000);
    // ... работа с ptr ...
    free(ptr);
}
```

### 2. Фрагментация памяти

```
Внешняя фрагментация:
┌─────┬────────┬─────┬────────┬─────┐
│Used │ Free   │Used │ Free   │Used │
│ 2KB │ 1KB    │ 1KB │ 1KB    │ 2KB │
└─────┴────────┴─────┴────────┴─────┘
Свободно 2KB, но нельзя выделить блок 2KB!

Внутренняя фрагментация:
┌────────────────────────┐
│ Запрошено: 1000 байт   │
│ Выделено:  4096 байт   │ ← Потеряно 3096 байт
└────────────────────────┘
```

### 3. Переполнение буфера (Buffer Overflow)

```c
// ОПАСНО: запись за границы буфера
char buffer[10];
strcpy(buffer, "Эта строка слишком длинная для буфера");

// Безопасно: использование безопасных функций
char buffer[10];
strncpy(buffer, "Длинная строка", sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';
```

## Инструменты диагностики

### Valgrind (C/C++)

```bash
# Поиск утечек памяти
valgrind --leak-check=full ./my_program

# Проверка ошибок памяти
valgrind --tool=memcheck ./my_program
```

### memory_profiler (Python)

```python
# pip install memory_profiler

from memory_profiler import profile

@profile
def my_function():
    a = [1] * (10 ** 6)
    b = [2] * (2 * 10 ** 7)
    del b
    return a

my_function()
```

```bash
# Запуск с профилированием
python -m memory_profiler script.py
```

## Best Practices

### Общие принципы

1. **Освобождайте ресурсы** — используйте RAII (C++), context managers (Python), try-finally
2. **Избегайте утечек** — профилируйте приложения, используйте статический анализ
3. **Понимайте лимиты** — учитывайте ulimit, cgroups в контейнерах
4. **Используйте пулы** — object pools для частого создания/удаления объектов

### Для Python

```python
# Используйте context managers
with open('file.txt') as f:
    data = f.read()
# Файл автоматически закрыт

# Используйте генераторы для больших данных
def read_large_file(file_path):
    with open(file_path) as f:
        for line in f:
            yield line  # Не загружает весь файл в память

# Используйте __slots__ для экономии памяти
class Point:
    __slots__ = ['x', 'y']  # Экономит ~40% памяти
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

### Для серверных приложений

```bash
# Ограничение памяти процесса (Linux)
ulimit -v 1000000  # Лимит виртуальной памяти (КБ)

# Мониторинг в production
# Prometheus + Grafana для метрик
# OOM Killer в Linux — следите за логами
dmesg | grep -i "killed process"
```

## Заключение

Понимание управления памятью критично для:
- Написания эффективного кода
- Отладки проблем производительности
- Предотвращения утечек памяти
- Работы с большими объёмами данных
- Настройки серверных приложений

Для backend-разработчика важно понимать, как ОС управляет памятью, чтобы правильно настраивать приложения и контейнеры.
