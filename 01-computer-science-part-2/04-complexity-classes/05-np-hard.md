# NP-трудные задачи (NP-Hard)

## Определение

### Формальное определение

Задача H является **NP-трудной** (NP-hard), если любая задача из NP сводится к H за полиномиальное время.

```
H ∈ NP-hard ⟺ ∀ L ∈ NP: L ≤ₚ H
```

**Важно**: NP-трудная задача НЕ обязана принадлежать NP!

### Соотношение с NP-полнотой

```
NP-complete = NP ∩ NP-hard

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│                       NP-hard                                │
│    ┌──────────────────────────────────────────────────────┐  │
│    │                                                      │  │
│    │   Оптимизационные версии:                            │  │
│    │   • TSP-OPT (найти кратчайший маршрут)               │  │
│    │   • MIN-VERTEX-COVER                                 │  │
│    │   • MAX-CLIQUE                                       │  │
│    │                                                      │  │
│    │   Неразрешимые:                                      │  │
│    │   • Halting Problem                                  │  │
│    │                                                      │  │
│    │   ┌──────────────────────────────────────────────┐   │  │
│    │   │                    NP                        │   │  │
│    │   │  ┌──────────────────────────────────────┐    │   │  │
│    │   │  │         NP-complete                  │    │   │  │
│    │   │  │  SAT, CLIQUE, TSP-DECISION           │    │   │  │
│    │   │  └──────────────────────────────────────┘    │   │  │
│    │   │  ┌──────────────────────────────────────┐    │   │  │
│    │   │  │              P                       │    │   │  │
│    │   │  │  Sorting, 2-SAT, PRIMES              │    │   │  │
│    │   │  └──────────────────────────────────────┘    │   │  │
│    │   └──────────────────────────────────────────────┘   │  │
│    │                                                      │  │
│    └──────────────────────────────────────────────────────┘  │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### Интуитивное объяснение

NP-трудные задачи — "как минимум такие же сложные, как NP-полные":

- **NP-полная**: сложная, но ответ можно проверить
- **NP-трудная**: может быть ещё сложнее (ответ нельзя даже проверить за полиномиальное время)

```
┌────────────────────────────────────────────────────────────────┐
│                      СРАВНЕНИЕ                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  NP-complete (NP-полная):                                      │
│  • Задача ПРИНЯТИЯ РЕШЕНИЙ                                     │
│  • Ответ: "да" или "нет"                                       │
│  • Лежит в NP (можно проверить за poly time)                   │
│  • Пример: "Существует ли маршрут ≤ k км?"                     │
│                                                                │
│  NP-hard (NP-трудная):                                         │
│  • Любой тип задачи (оптимизация, подсчёт, функция)            │
│  • Ответ: число, множество, функция...                         │
│  • Может НЕ лежать в NP                                        │
│  • Пример: "Какова длина кратчайшего маршрута?"                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

## Зачем нужно

### Практическое значение

1. **Классификация сложности**: показывает минимальную сложность задачи
2. **Оптимизационные задачи**: большинство реальных задач — оптимизационные (NP-hard)
3. **Выбор подхода**: если задача NP-hard, нужны приближённые методы
4. **Теоретические границы**: связь с неразрешимыми задачами

### Примеры применения

```
┌────────────────────────────────────────────────────────────────┐
│              NP-ТРУДНЫЕ ЗАДАЧИ В РЕАЛЬНОСТИ                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ЛОГИСТИКА                                                     │
│  • Оптимальный маршрут доставки (TSP-OPT)                      │
│  • Минимизация транспортных расходов                           │
│  • Оптимальное размещение складов                              │
│                                                                │
│  ПРОИЗВОДСТВО                                                  │
│  • Оптимальное расписание задач (Job Shop Scheduling)          │
│  • Минимизация простоев оборудования                           │
│  • Оптимальная загрузка контейнеров                            │
│                                                                │
│  ТЕЛЕКОММУНИКАЦИИ                                              │
│  • Оптимальное размещение вышек                                │
│  • Минимизация задержек в сети                                 │
│  • Маршрутизация пакетов                                       │
│                                                                │
│  БИОИНФОРМАТИКА                                                │
│  • Оптимальное выравнивание последовательностей                │
│  • Предсказание структуры белка                                │
│  • Построение филогенетических деревьев                        │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

## Типы NP-трудных задач

### 1. Оптимизационные версии NP-полных задач

```
┌────────────────────────────────────────────────────────────────┐
│        NP-полная (решение)    →    NP-трудная (оптимизация)    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  TSP-DECISION                     TSP-OPTIMIZATION             │
│  "Есть ли маршрут ≤ k?"    →     "Найти кратчайший маршрут"    │
│                                                                │
│  CLIQUE-DECISION                  MAX-CLIQUE                   │
│  "Есть ли клика ≥ k?"      →     "Найти максимальную клику"    │
│                                                                │
│  VERTEX-COVER-DECISION            MIN-VERTEX-COVER             │
│  "Есть ли покрытие ≤ k?"   →     "Найти минимальное покрытие"  │
│                                                                │
│  SUBSET-SUM-DECISION              SUBSET-SUM-COUNT             │
│  "Есть ли подмножество?"   →     "Сколько подмножеств?"        │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 2. Задачи подсчёта (#P)

```
#P (sharp-P): класс задач подсчёта решений

Примеры:
• #SAT — сколько выполняющих присваиваний?
• #CLIQUE — сколько клик размера k?
• PERMANENT — перманент матрицы

#P-полные задачи — NP-трудные:
  Если бы мы могли считать решения за poly time,
  мы бы могли проверить существование решения (NP)
```

### 3. Задачи с PSPACE-полнотой

```
PSPACE ⊇ NP

Примеры PSPACE-полных (следовательно, NP-трудных) задач:
• QBF (Quantified Boolean Formula)
• Игры: шахматы, го (на досках n×n)
• Планирование в AI
```

### 4. Неразрешимые задачи

```
Неразрешимые задачи тоже NP-трудные!

Halting Problem (проблема остановки):
  Вход: программа P, вход x
  Вопрос: остановится ли P на x?

Это NP-трудная задача, потому что:
• Любую NP-задачу можно свести к ней
• Но она НЕРАЗРЕШИМА (нет алгоритма вообще!)
```

## Примеры NP-трудных задач

### 1. TSP-OPTIMIZATION (Задача коммивояжёра — оптимизация)

```
TSP-OPT:
  Вход: граф G с весами рёбер
  Выход: минимальный по весу гамильтонов цикл

Почему NP-hard:
• TSP-DECISION ≤ₚ TSP-OPT
• Если решим оптимизацию, узнаем ответ на решение

Сложность: O(n!) наивно, O(n² × 2ⁿ) с динамическим программированием
```

```python
def tsp_brute_force(graph):
    """
    Полный перебор TSP: O(n!)
    graph: матрица расстояний n×n
    """
    import itertools

    n = len(graph)
    cities = list(range(1, n))  # Начинаем с города 0
    min_cost = float('inf')
    best_path = None

    for perm in itertools.permutations(cities):
        # Путь: 0 → perm[0] → perm[1] → ... → perm[-1] → 0
        path = (0,) + perm + (0,)
        cost = sum(graph[path[i]][path[i+1]] for i in range(n))

        if cost < min_cost:
            min_cost = cost
            best_path = path

    return best_path, min_cost

# n = 20 городов → 20! ≈ 2.4 × 10¹⁸ перестановок!
```

### 2. Graph Coloring — минимизация

```
CHROMATIC-NUMBER:
  Вход: граф G
  Выход: минимальное число цветов для правильной раскраски

NP-hard, потому что:
• k-COLORING (для k ≥ 3) — NP-complete
• Если найдём хроматическое число, решим все k-COLORING
```

### 3. Steiner Tree

```
STEINER-TREE:
  Вход: граф G, множество терминалов T ⊆ V
  Выход: дерево минимального веса, соединяющее все терминалы

NP-hard для общих графов
(для деревьев — полиномиальный!)

Применение:
• Проектирование VLSI
• Телекоммуникационные сети
• Филогенетика
```

### 4. Integer Linear Programming (ILP)

```
ILP (Целочисленное линейное программирование):
  Максимизировать: c^T x
  При условиях: Ax ≤ b, x ∈ Zⁿ (целые числа!)

NP-hard, в отличие от:
  LP (линейное программирование с вещественными x) — в P!

Многие NP-полные задачи формулируются как ILP
```

### 5. Subset Sum — оптимизация

```
SUBSET-SUM-OPT:
  Вход: множество чисел S, целевое t
  Выход: подмножество с суммой как можно ближе к t (не превышая)

Это задача о рюкзаке (Knapsack) в простейшей форме
```

## Диаграмма иерархии сложности

```
┌──────────────────────────────────────────────────────────────────┐
│                        ИЕРАРХИЯ СЛОЖНОСТИ                        │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ┌──────────────────────────────────────────────────────────┐  │
│    │                    НЕРАЗРЕШИМЫЕ                          │  │
│    │    Halting Problem, Post Correspondence, Rice's theorem  │  │
│    │                                                          │  │
│    │    ┌──────────────────────────────────────────────────┐  │  │
│    │    │                   EXPSPACE                       │  │  │
│    │    │                                                  │  │  │
│    │    │    ┌──────────────────────────────────────────┐  │  │  │
│    │    │    │               EXPTIME                    │  │  │  │
│    │    │    │  Шахматы, Го (n×n), Generalized Chess    │  │  │  │
│    │    │    │                                          │  │  │  │
│    │    │    │    ┌──────────────────────────────────┐  │  │  │  │
│    │    │    │    │            PSPACE                │  │  │  │  │
│    │    │    │    │  QBF, Geography, TQBF            │  │  │  │  │
│    │    │    │    │                                  │  │  │  │  │
│    │    │    │    │    ┌──────────────────────────┐  │  │  │  │  │
│    │    │    │    │    │    NP        co-NP       │  │  │  │  │  │
│    │    │    │    │    │      \      /            │  │  │  │  │  │
│    │    │    │    │    │       \    /             │  │  │  │  │  │
│    │    │    │    │    │        \  /              │  │  │  │  │  │
│    │    │    │    │    │         \/               │  │  │  │  │  │
│    │    │    │    │    │         P                │  │  │  │  │  │
│    │    │    │    │    │                          │  │  │  │  │  │
│    │    │    │    │    └──────────────────────────┘  │  │  │  │  │
│    │    │    │    │                                  │  │  │  │  │
│    │    │    │    └──────────────────────────────────┘  │  │  │  │
│    │    │    │                                          │  │  │  │
│    │    │    └──────────────────────────────────────────┘  │  │  │
│    │    │                                                  │  │  │
│    │    └──────────────────────────────────────────────────┘  │  │
│    │                                                          │  │
│    └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│                        NP-hard "пересекает" все уровни!          │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

## Связь оптимизации и решения

### Теорема о самосводимости

Для многих NP-полных задач:

```
Если версия РЕШЕНИЯ в P, то версия ОПТИМИЗАЦИИ тоже в P

Пример: TSP

TSP-DECISION: "Есть ли маршрут ≤ k?"
TSP-OPT: "Найти кратчайший маршрут"

Если TSP-DECISION ∈ P, то:
1. Бинарным поиском находим оптимальное k*
2. Для построения маршрута:
   - Удаляем ребро e
   - Если TSP-DECISION(G \ e, k*) = YES → ребро не нужно
   - Иначе → ребро обязательно в оптимуме
   - Повторяем для всех рёбер

Вывод: TSP-OPT решается за O(m × log(max_weight) × Time(TSP-DECISION))
```

### Когда оптимизация сложнее решения?

```
Задачи подсчёта (#P) — сложнее NP:

#SAT: "Сколько выполняющих присваиваний у формулы φ?"

• SAT (есть ли хоть одно?) — NP-complete
• #SAT (сколько их?) — #P-complete
• #P-complete строго сложнее NP-complete (при P ≠ NP)

Даже для задач из P:
• 2-SAT ∈ P (решение)
• #2-SAT — #P-complete (подсчёт)!
```

## Методы решения NP-трудных задач

### 1. Точные алгоритмы (для малых входов)

```python
# Динамическое программирование для TSP
# Сложность: O(n² × 2ⁿ) вместо O(n!)

def tsp_dp(dist):
    """
    Алгоритм Хелда-Карпа для TSP
    dist: матрица расстояний n×n
    """
    n = len(dist)
    # dp[mask][i] = мин. стоимость пути из 0 через вершины mask, заканчивая в i
    dp = [[float('inf')] * n for _ in range(1 << n)]
    dp[1][0] = 0  # Начинаем в вершине 0

    for mask in range(1, 1 << n):
        for last in range(n):
            if not (mask & (1 << last)):
                continue
            for next_v in range(n):
                if mask & (1 << next_v):
                    continue
                new_mask = mask | (1 << next_v)
                dp[new_mask][next_v] = min(
                    dp[new_mask][next_v],
                    dp[mask][last] + dist[last][next_v]
                )

    # Замыкаем цикл обратно в 0
    full_mask = (1 << n) - 1
    return min(dp[full_mask][i] + dist[i][0] for i in range(1, n))
```

### 2. Приближённые алгоритмы

```
┌────────────────────────────────────────────────────────────────┐
│            ГАРАНТИРОВАННЫЕ ПРИБЛИЖЕНИЯ                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  VERTEX-COVER: 2-приближение                                   │
│  • Жадно берём рёбра и обе их вершины                          │
│  • Гарантия: решение ≤ 2 × OPT                                 │
│                                                                │
│  METRIC-TSP: 1.5-приближение (алгоритм Кристофидеса)           │
│  • MST + минимальное паросочетание нечётных вершин             │
│  • Гарантия: решение ≤ 1.5 × OPT                               │
│                                                                │
│  SET-COVER: O(log n)-приближение                               │
│  • Жадный выбор множества, покрывающего больше всего           │
│  • Лучшее возможное (при P ≠ NP)                               │
│                                                                │
│  MAX-CUT: 0.878-приближение (Гёманс-Вильямсон)                 │
│  • Через SDP (полуопределённое программирование)               │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 3. Параметризованные алгоритмы (FPT)

```
FPT (Fixed-Parameter Tractable):
Сложность O(f(k) × poly(n)) вместо O(n^k)

Примеры:
• VERTEX-COVER: O(2^k × n) — параметр k (размер покрытия)
• CLIQUE в планарных графах: O(2^√k × n)
• k-PATH: O(2^k × n) — поиск пути длины k

Идея: экспонента зависит от параметра k, а не от n
Если k мало, алгоритм эффективен даже для больших n
```

### 4. Эвристики и метаэвристики

```python
# Имитация отжига для TSP
import random
import math

def simulated_annealing_tsp(dist, initial_temp=10000, cooling=0.9999):
    """
    Метаэвристика: имитация отжига
    """
    n = len(dist)
    current = list(range(n))
    random.shuffle(current)
    current_cost = tour_cost(dist, current)

    best = current[:]
    best_cost = current_cost

    temp = initial_temp

    while temp > 0.1:
        # Генерируем соседнее решение (swap двух городов)
        i, j = random.sample(range(n), 2)
        neighbor = current[:]
        neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
        neighbor_cost = tour_cost(dist, neighbor)

        # Принимаем с вероятностью, зависящей от температуры
        delta = neighbor_cost - current_cost
        if delta < 0 or random.random() < math.exp(-delta / temp):
            current = neighbor
            current_cost = neighbor_cost

            if current_cost < best_cost:
                best = current[:]
                best_cost = current_cost

        temp *= cooling

    return best, best_cost
```

## Исторический контекст

### Хронология

```
1971    Кук: определение NP-трудности
         │
1972    Карп: формализация сводимости и NP-полноты
         │
1975    Гэри, Джонсон: "Computers and Intractability"
         │ Систематизация теории NP-трудности
         │
1976    Доказано: нет PTAS для TSP (если P ≠ NP)
         │
1992    Arora, Lund, ...: PCP-теорема
         │ Новые границы приближаемости
         │
1996    Christofides: 1.5-приближение для metric TSP
         │ (на самом деле алгоритм был в 1976!)
         │
2000s   Развитие SAT-солверов и практических методов
```

## Практические советы

### Когда задача NP-трудная

```
Признаки NP-трудности:

1. Оптимизационная версия NP-полной задачи
2. Задача подсчёта (#P)
3. Игровые задачи (с чередованием ходов)
4. Задача "для всех/существует" с квантификаторами

Что делать:
1. Убедитесь, что задача действительно NP-трудная
2. Посмотрите на специальные случаи (могут быть в P)
3. Определите допустимую погрешность
4. Выберите метод: приближение, эвристика, параметризация
5. Используйте готовые солверы (Gurobi, CPLEX, SAT-solvers)
```

## Итоги

1. **NP-hard** = "как минимум так же сложно, как NP"
2. **Не обязана быть в NP** — может быть оптимизационной или неразрешимой
3. **NP-complete = NP ∩ NP-hard** — самые сложные задачи решения в NP
4. **Оптимизационные версии** NP-полных задач — NP-трудные
5. **Методы решения**: точные (для малых входов), приближённые, FPT, эвристики
6. **Практика**: большинство реальных задач — NP-трудные (оптимизация)
7. **Связь с неразрешимостью**: неразрешимые задачи тоже NP-трудные
