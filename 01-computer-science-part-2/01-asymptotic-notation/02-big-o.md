# Big O Notation (О-большое)

## Определение

**Big O (О-большое)** — это математическая нотация, описывающая **верхнюю границу** роста функции. В контексте алгоритмов она показывает **максимальную** (worst case) сложность алгоритма.

### Формальное определение

f(n) = O(g(n)) означает, что существуют константы c > 0 и n₀ ≥ 0 такие, что:

```
f(n) ≤ c · g(n)  для всех n ≥ n₀
```

Проще говоря: начиная с некоторого n₀, функция f(n) **не превышает** g(n), умноженную на константу.

## Зачем нужно

### Практическое применение

1. **Оценка производительности** — понять, как поведёт себя алгоритм на больших данных
2. **Сравнение алгоритмов** — выбрать более эффективное решение
3. **Требования к системе** — определить, справится ли система с нагрузкой
4. **Код-ревью** — обнаружить неоптимальные места

### Почему именно верхняя граница?

Big O отвечает на вопрос: **"Как плохо может быть?"**

В production-среде нас интересует гарантия, что алгоритм не будет работать дольше определённого времени. Лучший случай — приятный бонус, но планируем мы по худшему.

## Как работает

### Правила вычисления Big O

**1. Отбрасываем константы:**
```
O(2n) = O(n)
O(100) = O(1)
O(n/2) = O(n)
```

**2. Оставляем только доминирующий член:**
```
O(n² + n) = O(n²)
O(n³ + n² + n) = O(n³)
O(2ⁿ + n¹⁰⁰) = O(2ⁿ)
```

**3. Разные переменные сохраняем:**
```
O(n + m) — нельзя упростить, если n и m независимы
O(n · m) — произведение разных размеров
```

### Последовательные операции складываются

```python
def process(arr):
    # O(n)
    for x in arr:
        print(x)

    # O(n)
    for x in arr:
        print(x * 2)

# Итого: O(n) + O(n) = O(2n) = O(n)
```

### Вложенные операции перемножаются

```python
def nested(arr):
    for x in arr:        # O(n)
        for y in arr:    # O(n)
            print(x, y)

# Итого: O(n) × O(n) = O(n²)
```

## Визуализация

### Графическое представление Big O

```
f(n)
  ↑
  │           ╱ c·g(n) — верхняя граница
  │         ╱
  │       ╱
  │     ╱   -------- f(n) — наша функция
  │   ╱   --╱
  │ ╱  --╱
  │╱--╱
  │ ╱
  └─────────────────────→ n
      ↑
      n₀ (начиная отсюда f(n) ≤ c·g(n))
```

### Иерархия сложностей

```
Скорость роста (от медленного к быстрому):

O(1) ──────────────────────  Константа (идеально)
  │
O(log n) ─────────────────  Логарифм (отлично)
  │
O(n) ─────────────────────  Линейная (хорошо)
  │
O(n log n) ───────────────  Линейно-логарифмическая (неплохо)
  │
O(n²) ────────────────────  Квадратичная (осторожно)
  │
O(n³) ────────────────────  Кубическая (плохо)
  │
O(2ⁿ) ────────────────────  Экспоненциальная (очень плохо)
  │
O(n!) ────────────────────  Факториал (катастрофа)
```

## Примеры с разбором

### Пример 1: O(1) — Константная сложность

```python
def get_element(arr, index):
    return arr[index]

def is_even(n):
    return n % 2 == 0

def get_first_and_last(arr):
    return arr[0], arr[-1]
```

**Разбор:** Количество операций не зависит от размера данных.

### Пример 2: O(log n) — Логарифмическая

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

**Разбор:** Каждая итерация отбрасывает половину элементов.
- n=1024 → максимум 10 итераций (log₂1024 = 10)
- n=1000000 → максимум 20 итераций

### Пример 3: O(n) — Линейная

```python
def find_max(arr):
    max_val = arr[0]
    for x in arr:
        if x > max_val:
            max_val = x
    return max_val

def sum_list(arr):
    return sum(arr)  # Внутри тоже O(n)
```

**Разбор:** Проходим по каждому элементу ровно один раз.

### Пример 4: O(n log n) — Линейно-логарифмическая

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])    # T(n/2)
    right = merge_sort(arr[mid:])   # T(n/2)

    return merge(left, right)        # O(n)

# Глубина рекурсии: log n
# На каждом уровне: O(n) операций
# Итого: O(n log n)
```

### Пример 5: O(n²) — Квадратичная

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

def print_pairs(arr):
    for i in arr:
        for j in arr:
            print(i, j)
```

**Разбор:** Вложенные циклы, каждый проходит по n элементам.

### Пример 6: O(2ⁿ) — Экспоненциальная

```python
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
```

**Разбор:** Каждый вызов порождает два новых вызова.
- n=30 → около 1 млн операций
- n=50 → около 10¹⁵ операций (годы выполнения)

## Типичные ошибки

### 1. Игнорирование вложенных вызовов

```python
def example(arr):
    for x in arr:           # O(n)
        if x in arr:        # O(n) — это не O(1)!
            print("found")

# Итого: O(n²), не O(n)!
```

### 2. Забывать про рекурсию

```python
def count_down(n):
    if n <= 0:
        return
    print(n)
    count_down(n - 1)

# Это O(n), не O(1)!
```

### 3. Путать O(n+m) и O(n·m)

```python
# O(n + m) — последовательные циклы
for x in arr1:  # O(n)
    print(x)
for y in arr2:  # O(m)
    print(y)

# O(n · m) — вложенные циклы
for x in arr1:      # O(n)
    for y in arr2:  # O(m)
        print(x, y)
```

### 4. Неправильная оценка строковых операций

```python
def build_string(n):
    result = ""
    for i in range(n):
        result += str(i)  # Каждая конкатенация — O(len(result))
    return result

# Это O(n²), не O(n)!

# Правильно — O(n):
def build_string_fast(n):
    return "".join(str(i) for i in range(n))
```

### 5. Скрытая сложность в методах

```python
# list.insert(0, x) — O(n), не O(1)
# list.pop(0) — O(n), не O(1)
# list.pop() — O(1)
# collections.deque.appendleft() — O(1)

arr = []
for i in range(n):
    arr.insert(0, i)  # Итого O(n²)!
```

## Сравнительная таблица

| Сложность | n=10 | n=100 | n=1000 | n=10⁶ |
|-----------|------|-------|--------|-------|
| O(1) | 1 | 1 | 1 | 1 |
| O(log n) | 3 | 7 | 10 | 20 |
| O(n) | 10 | 100 | 1000 | 10⁶ |
| O(n log n) | 33 | 664 | 9966 | 2×10⁷ |
| O(n²) | 100 | 10⁴ | 10⁶ | 10¹² |
| O(2ⁿ) | 1024 | 10³⁰ | 10³⁰¹ | ∞ |

## Резюме

- Big O описывает **верхнюю границу** (худший случай)
- Отбрасываем константы и младшие члены
- Последовательные операции — складываем
- Вложенные операции — перемножаем
- Всегда учитываем скрытую сложность встроенных операций
