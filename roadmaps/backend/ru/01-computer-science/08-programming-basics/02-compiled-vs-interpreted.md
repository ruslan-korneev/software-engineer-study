# Compiled vs Interpreted

[prev: 01-what-is-programming](./01-what-is-programming.md) | [next: 03-how-code-runs](./03-how-code-runs.md)

---
## Введение

Когда мы пишем программу на языке программирования, компьютер не может выполнить её напрямую - процессор понимает только машинный код. Существует два основных способа преобразования исходного кода в исполняемый: **компиляция** и **интерпретация**.

## Компилируемые языки

### Что такое компиляция?

**Компиляция** - это процесс преобразования всего исходного кода программы в машинный код **до** её запуска. Результат компиляции - исполняемый файл (executable), который можно запускать многократно без повторной компиляции.

```
Исходный код (.c, .cpp, .go, .rs)
        |
        v
    Компилятор
        |
        v
Машинный код (исполняемый файл)
        |
        v
    Выполнение
```

### Примеры компилируемых языков

| Язык | Компилятор | Применение |
|------|------------|------------|
| C | gcc, clang | Системное ПО, драйверы, embedded |
| C++ | g++, clang++ | Игры, браузеры, высоконагруженные системы |
| Go | go build | Серверы, микросервисы, CLI-инструменты |
| Rust | rustc | Системное ПО, WebAssembly, безопасный код |

### Пример компиляции C

```c
// hello.c
#include <stdio.h>

int main() {
    printf("Привет, мир!\n");
    return 0;
}
```

```bash
# Компиляция
gcc hello.c -o hello

# Запуск
./hello
# Вывод: Привет, мир!
```

### Пример компиляции Go

```go
// hello.go
package main

import "fmt"

func main() {
    fmt.Println("Привет, мир!")
}
```

```bash
# Компиляция
go build hello.go

# Запуск
./hello
# Вывод: Привет, мир!
```

### Преимущества компилируемых языков

1. **Высокая производительность** - машинный код выполняется напрямую процессором
2. **Раннее обнаружение ошибок** - многие ошибки находятся на этапе компиляции
3. **Защита исходного кода** - распространяется только исполняемый файл
4. **Оптимизация** - компилятор может оптимизировать код

### Недостатки компилируемых языков

1. **Время компиляции** - большие проекты компилируются долго
2. **Платформозависимость** - нужно компилировать отдельно для каждой ОС
3. **Сложнее отладка** - труднее связать ошибку с исходным кодом
4. **Цикл разработки дольше** - изменил код -> скомпилировал -> запустил

## Интерпретируемые языки

### Что такое интерпретация?

**Интерпретация** - это построчное выполнение исходного кода программы. Интерпретатор читает код, анализирует его и сразу выполняет, без создания отдельного исполняемого файла.

```
Исходный код (.py, .js, .rb)
        |
        v
   Интерпретатор (читает и выполняет построчно)
        |
        v
    Результат
```

### Примеры интерпретируемых языков

| Язык | Интерпретатор | Применение |
|------|---------------|------------|
| Python | CPython, PyPy | Data Science, веб, автоматизация |
| JavaScript | V8, SpiderMonkey | Веб (браузер и Node.js) |
| Ruby | MRI, JRuby | Веб (Ruby on Rails) |
| PHP | Zend Engine | Веб-разработка |
| Perl | perl | Скриптинг, текстовая обработка |

### Пример интерпретации Python

```python
# hello.py
print("Привет, мир!")
```

```bash
# Сразу запуск (без отдельного этапа компиляции)
python hello.py
# Вывод: Привет, мир!
```

### Пример интерпретации JavaScript (Node.js)

```javascript
// hello.js
console.log("Привет, мир!");
```

```bash
# Запуск
node hello.js
# Вывод: Привет, мир!
```

### Преимущества интерпретируемых языков

1. **Быстрый цикл разработки** - изменил код -> запустил
2. **Кроссплатформенность** - один код работает везде, где есть интерпретатор
3. **Интерактивность** - можно тестировать код в REPL
4. **Динамическая типизация** - обычно более гибкий код

### Недостатки интерпретируемых языков

1. **Медленнее выполнение** - код анализируется при каждом запуске
2. **Ошибки при выполнении** - некоторые ошибки обнаруживаются только в runtime
3. **Требуется интерпретатор** - на целевой машине должен быть установлен интерпретатор
4. **Исходный код открыт** - распространяется сам исходный код

## Байткод и виртуальные машины

Многие современные языки используют **гибридный подход**: исходный код сначала компилируется в промежуточный **байткод**, который затем выполняется виртуальной машиной.

```
Исходный код
      |
      v
  Компилятор (в байткод)
      |
      v
  Байткод (.pyc, .class)
      |
      v
  Виртуальная машина (VM)
      |
      v
  Выполнение
```

### Примеры языков с байткодом

| Язык | Байткод | Виртуальная машина |
|------|---------|-------------------|
| Java | .class файлы | JVM (Java Virtual Machine) |
| Python | .pyc файлы | Python VM (в CPython) |
| C# | IL (Intermediate Language) | CLR (.NET Runtime) |
| Kotlin | .class файлы | JVM |
| Scala | .class файлы | JVM |

### Пример: Java

```java
// Hello.java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Привет, мир!");
    }
}
```

```bash
# Компиляция в байткод
javac Hello.java
# Создаётся Hello.class

# Запуск на JVM
java Hello
# Вывод: Привет, мир!
```

### Преимущества байткода

1. **Портируемость** - байткод работает на любой платформе с VM
2. **Оптимизация** - часть ошибок ловится при компиляции в байткод
3. **Быстрее чистой интерпретации** - байткод проще исполнять

## JIT-компиляция (Just-In-Time)

**JIT-компиляция** - это техника, при которой код компилируется в машинный код **во время выполнения** программы. JIT-компилятор анализирует "горячие" участки кода (которые выполняются часто) и компилирует их в нативный машинный код.

```
Исходный код / Байткод
        |
        v
   Интерпретатор (начинает выполнение)
        |
        v
   JIT-компилятор (компилирует "горячий" код)
        |
        v
   Машинный код (для часто используемых участков)
        |
        v
   Ускоренное выполнение
```

### Примеры JIT-компиляторов

| Технология | Языки | Описание |
|------------|-------|----------|
| V8 | JavaScript | Движок Chrome и Node.js |
| SpiderMonkey | JavaScript | Движок Firefox |
| HotSpot | Java | Стандартная JVM |
| PyPy | Python | Альтернативный интерпретатор Python |
| LuaJIT | Lua | Быстрый JIT для Lua |

### Как работает JIT (на примере V8)

1. **Parsing** - код парсится в AST (Abstract Syntax Tree)
2. **Ignition** - интерпретатор выполняет байткод
3. **Profiling** - собирается статистика выполнения
4. **TurboFan** - "горячий" код компилируется в машинный
5. **Deoptimization** - если предположения неверны, возврат к интерпретации

## AOT-компиляция (Ahead-Of-Time)

**AOT-компиляция** - компиляция в машинный код **до** запуска программы. Это традиционный подход для C/C++, но также используется в современных технологиях.

### Примеры AOT

- **GraalVM Native Image** - компиляция Java в нативный код
- **Flutter** - Dart компилируется в нативный код для мобильных приложений
- **Angular AOT** - компиляция шаблонов Angular до запуска

```bash
# Пример: GraalVM Native Image
native-image -jar myapp.jar
# Создаётся нативный исполняемый файл
```

## Сравнительная таблица

| Характеристика | Компиляция | Интерпретация | JIT |
|----------------|------------|---------------|-----|
| Скорость выполнения | Высокая | Низкая | Средняя-Высокая |
| Время запуска | Быстрое | Быстрое | Медленное (прогрев) |
| Обнаружение ошибок | При компиляции | При выполнении | При выполнении |
| Переносимость | Низкая | Высокая | Высокая |
| Использование памяти | Низкое | Среднее | Высокое |

## Практические примеры

### Почему игры пишут на C++?

- Максимальная производительность
- Прямой доступ к памяти и оборудованию
- Предсказуемое время выполнения (нет пауз GC)

### Почему веб-сервера часто на Python/Node.js?

- Быстрая разработка важнее микросекунд производительности
- I/O-bound задачи (сеть, база данных) - узкое место не в языке
- Большие экосистемы библиотек

### Почему Go популярен для микросервисов?

- Компилируется в один бинарный файл
- Быстрая компиляция
- Хорошая производительность
- Простой деплой (не нужен runtime)

## Резюме

| Подход | Когда использовать |
|--------|-------------------|
| **Компиляция** | Системное ПО, игры, производительность критична |
| **Интерпретация** | Скриптинг, прототипы, быстрая разработка |
| **Байткод + VM** | Кроссплатформенные приложения (Java, C#) |
| **JIT** | Веб (JavaScript), когда нужен баланс скорости и гибкости |

Выбор между компиляцией и интерпретацией зависит от требований проекта: если важна производительность - компилируемые языки; если важна скорость разработки - интерпретируемые; если нужен баланс - языки с JIT.

---

[prev: 01-what-is-programming](./01-what-is-programming.md) | [next: 03-how-code-runs](./03-how-code-runs.md)
