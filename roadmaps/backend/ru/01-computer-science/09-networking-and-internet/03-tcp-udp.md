# TCP and UDP

## Введение

**TCP (Transmission Control Protocol)** и **UDP (User Datagram Protocol)** — это два основных протокола транспортного уровня (Layer 4). Они отвечают за доставку данных между приложениями на разных компьютерах.

```
┌─────────────────────────────────────────────────────────────┐
│                    Транспортный уровень                      │
│                                                              │
│    ┌─────────────────┐          ┌─────────────────┐         │
│    │      TCP        │          │      UDP        │         │
│    │   Надёжный      │          │   Быстрый       │         │
│    │   С соединением │          │   Без соединения │         │
│    └─────────────────┘          └─────────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

---

## TCP (Transmission Control Protocol)

### Характеристики TCP

- **Connection-oriented** — требуется установка соединения перед передачей
- **Надёжный** — гарантирует доставку данных
- **Упорядоченный** — данные приходят в том же порядке, в каком отправлены
- **Контроль потока** — регулирует скорость передачи
- **Контроль перегрузки** — адаптируется к загрузке сети

### TCP-сегмент (структура заголовка)

```
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
├───────────────────────────┼───────────────────────────────────┤
│       Source Port         │       Destination Port            │
├───────────────────────────────────────────────────────────────┤
│                    Sequence Number                            │
├───────────────────────────────────────────────────────────────┤
│                 Acknowledgment Number                         │
├───────┬───────┬───────────┼───────────────────────────────────┤
│Offset │Reserv.│  Flags    │           Window Size             │
├───────────────────────────┼───────────────────────────────────┤
│      Checksum             │       Urgent Pointer              │
├───────────────────────────┴───────────────────────────────────┤
│                    Options (если есть)                        │
├───────────────────────────────────────────────────────────────┤
│                         Data                                  │
└───────────────────────────────────────────────────────────────┘
```

### TCP Flags (флаги)

```
┌──────┬──────────────────────────────────────────────────────┐
│ Флаг │                    Назначение                        │
├──────┼──────────────────────────────────────────────────────┤
│ SYN  │ Synchronize — инициирует соединение                  │
│ ACK  │ Acknowledgment — подтверждает получение              │
│ FIN  │ Finish — завершает соединение                        │
│ RST  │ Reset — сбрасывает соединение                        │
│ PSH  │ Push — передать данные приложению немедленно         │
│ URG  │ Urgent — срочные данные                              │
└──────┴──────────────────────────────────────────────────────┘
```

### TCP Three-Way Handshake (установка соединения)

Это "рукопожатие" из трёх шагов для установки надёжного соединения:

```
    Клиент                                      Сервер
       │                                           │
       │  1. SYN (seq=100)                         │
       │ ─────────────────────────────────────────>│
       │     "Хочу установить соединение"          │
       │                                           │
       │  2. SYN-ACK (seq=300, ack=101)            │
       │ <─────────────────────────────────────────│
       │     "Принято, я тоже хочу"                │
       │                                           │
       │  3. ACK (seq=101, ack=301)                │
       │ ─────────────────────────────────────────>│
       │     "Отлично, соединение установлено"     │
       │                                           │
       │  === СОЕДИНЕНИЕ УСТАНОВЛЕНО ===           │
       │                                           │
```

**Почему три шага?**
1. SYN: Клиент сообщает серверу свой начальный sequence number
2. SYN-ACK: Сервер подтверждает и сообщает свой sequence number
3. ACK: Клиент подтверждает получение — теперь оба знают номера друг друга

### TCP Four-Way Handshake (завершение соединения)

```
    Клиент                                      Сервер
       │                                           │
       │  1. FIN (seq=500)                         │
       │ ─────────────────────────────────────────>│
       │     "Я закончил отправку"                 │
       │                                           │
       │  2. ACK (ack=501)                         │
       │ <─────────────────────────────────────────│
       │     "Понял, но у меня ещё есть данные"    │
       │                                           │
       │  3. FIN (seq=600)                         │
       │ <─────────────────────────────────────────│
       │     "Теперь я тоже закончил"              │
       │                                           │
       │  4. ACK (ack=601)                         │
       │ ─────────────────────────────────────────>│
       │     "Понял, до свидания"                  │
       │                                           │
       │  === СОЕДИНЕНИЕ ЗАКРЫТО ===               │
```

### Надёжность TCP

**Sequence Numbers и Acknowledgments:**

```
Клиент отправляет:  SEQ=1, данные "Hello" (5 байт)
Сервер отвечает:    ACK=6 ("получил до байта 5, жду байт 6")

Клиент отправляет:  SEQ=6, данные "World" (5 байт)
Сервер отвечает:    ACK=11 ("получил до байта 10")
```

**Повторная передача (Retransmission):**

```
Клиент                                      Сервер
   │                                           │
   │  SEQ=1, "Hello"                           │
   │ ─────────────────────────────────────────>│
   │                                           │
   │  ACK=6                                    │
   │ <─────────────────────────────────────────│
   │                                           │
   │  SEQ=6, "World"                           │
   │ ─────────────X (потеряно!)                │
   │                                           │
   │  ... таймаут ...                          │
   │                                           │
   │  SEQ=6, "World" (повтор!)                 │
   │ ─────────────────────────────────────────>│
   │                                           │
   │  ACK=11                                   │
   │ <─────────────────────────────────────────│
```

### TCP Flow Control (контроль потока)

**Sliding Window (скользящее окно):**

Получатель сообщает, сколько данных он может принять (Window Size).

```
Window Size = 3000 байт

Отправитель может отправить до 3000 байт, не дожидаясь ACK.

┌─────────────────────────────────────────────────┐
│ Отправлено и   │ Можно отправить │ Нельзя пока  │
│ подтверждено   │ (в окне)        │ отправить    │
└─────────────────────────────────────────────────┘
```

---

## UDP (User Datagram Protocol)

### Характеристики UDP

- **Connectionless** — не требует установки соединения
- **Ненадёжный** — не гарантирует доставку
- **Без упорядочивания** — пакеты могут приходить в любом порядке
- **Быстрый** — минимальные накладные расходы
- **Простой** — маленький заголовок (8 байт vs 20+ у TCP)

### UDP-датаграмма (структура)

```
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
├───────────────────────────┼───────────────────────────────────┤
│       Source Port         │       Destination Port            │
├───────────────────────────┼───────────────────────────────────┤
│         Length            │           Checksum                │
├───────────────────────────┴───────────────────────────────────┤
│                         Data                                  │
└───────────────────────────────────────────────────────────────┘

Всего 8 байт заголовка (TCP: минимум 20 байт)
```

### Как работает UDP

```
Клиент                                      Сервер
   │                                           │
   │  Датаграмма 1                             │
   │ ─────────────────────────────────────────>│
   │                                           │
   │  Датаграмма 2                             │
   │ ─────────────────────────────────────────>│
   │                                           │
   │  Датаграмма 3 (может потеряться!)         │
   │ ─────────────X                            │
   │                                           │
   │  Датаграмма 4                             │
   │ ─────────────────────────────────────────>│

Никаких handshake, никаких ACK, никаких повторов!
```

---

## Сравнение TCP и UDP

```
┌─────────────────────┬──────────────────────┬──────────────────────┐
│    Характеристика   │        TCP           │        UDP           │
├─────────────────────┼──────────────────────┼──────────────────────┤
│ Соединение          │ Требуется (handshake)│ Не требуется         │
│ Надёжность          │ Гарантирует доставку │ Не гарантирует       │
│ Порядок данных      │ Сохраняется          │ Может нарушаться     │
│ Скорость            │ Медленнее            │ Быстрее              │
│ Накладные расходы   │ Больше (20+ байт)    │ Меньше (8 байт)      │
│ Контроль потока     │ Есть                 │ Нет                  │
│ Контроль перегрузки │ Есть                 │ Нет                  │
│ Broadcast/Multicast │ Нет                  │ Да                   │
└─────────────────────┴──────────────────────┴──────────────────────┘
```

### Аналогия

```
TCP как заказное письмо:
- Проверяется доставка
- Есть подтверждение получения
- Если не доставлено — повторная попытка
- Медленнее, но надёжно

UDP как открытка:
- Бросил в ящик и забыл
- Нет подтверждения
- Если потерялась — никто не узнает
- Быстро и просто
```

---

## Когда использовать TCP?

```
✓ Веб-сайты (HTTP/HTTPS)
✓ Электронная почта (SMTP, IMAP, POP3)
✓ Передача файлов (FTP, SFTP)
✓ Удалённый доступ (SSH, Telnet)
✓ Базы данных (MySQL, PostgreSQL)
✓ API-запросы
✓ Всё, где важна целостность данных
```

**Примеры протоколов на TCP:**
- HTTP/HTTPS (порт 80/443)
- SSH (порт 22)
- SMTP (порт 25/587)
- MySQL (порт 3306)
- PostgreSQL (порт 5432)

---

## Когда использовать UDP?

```
✓ Видеостриминг (YouTube, Netflix)
✓ Голосовая связь (VoIP, Zoom)
✓ Онлайн-игры
✓ DNS-запросы
✓ DHCP
✓ IoT устройства
✓ Всё, где скорость важнее надёжности
```

**Примеры протоколов на UDP:**
- DNS (порт 53)
- DHCP (порты 67-68)
- SNMP (порт 161)
- TFTP (порт 69)
- NTP (порт 123)
- RTP (для аудио/видео)

### Почему UDP для стриминга?

```
Потеря одного кадра в видео:
- TCP: остановить воспроизведение, запросить повтор, подождать
- UDP: пропустить кадр, продолжить (зритель не заметит)

Для реального времени лучше потерять данные, чем ждать!
```

---

## TCP vs UDP: практические примеры

### Пример 1: Загрузка файла (TCP)

```
Файл: photo.jpg (1 MB)

1. Клиент устанавливает соединение (3-way handshake)
2. Сервер отправляет файл порциями (сегменты)
3. Клиент подтверждает каждую порцию (ACK)
4. При потере — повторная отправка
5. Закрытие соединения (4-way handshake)

Результат: файл доставлен полностью и корректно
```

### Пример 2: Видеозвонок (UDP)

```
Видеопоток: 30 кадров/сек

Кадр 1 → доставлен → показан
Кадр 2 → потерян   → пропущен (показан кадр 1 дольше)
Кадр 3 → доставлен → показан
Кадр 4 → доставлен → показан

Небольшие потери незаметны, но задержка критична!
```

### Пример 3: DNS-запрос (UDP)

```
Запрос: "Какой IP у google.com?"
- Один маленький пакет (вопрос)
- Один маленький пакет (ответ)
- Если потерялся — повторить запрос

TCP для этого избыточен (handshake дольше, чем сам запрос)
```

---

## Состояния TCP-соединения

```
┌─────────────────────────────────────────────────────────────┐
│                   Диаграмма состояний TCP                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────┐                          ┌──────────┐         │
│  │  CLOSED  │                          │  LISTEN  │         │
│  └────┬─────┘                          └────┬─────┘         │
│       │ SYN sent                            │ SYN received  │
│       ▼                                     ▼               │
│  ┌──────────┐      SYN+ACK            ┌──────────┐         │
│  │ SYN_SENT │ ◄──────────────────────►│ SYN_RCVD │         │
│  └────┬─────┘                          └────┬─────┘         │
│       │ ACK received                        │ ACK received  │
│       ▼                                     ▼               │
│  ┌────────────────────────────────────────────────┐        │
│  │               ESTABLISHED                       │        │
│  │          (данные передаются)                    │        │
│  └────────────────────────────────────────────────┘        │
│                                                              │
│       │ FIN sent                            │ FIN received  │
│       ▼                                     ▼               │
│  ┌──────────┐                          ┌──────────┐         │
│  │ FIN_WAIT │                          │CLOSE_WAIT│         │
│  └────┬─────┘                          └────┬─────┘         │
│       │                                     │               │
│       ▼                                     ▼               │
│  ┌──────────┐                          ┌──────────┐         │
│  │TIME_WAIT │                          │ LAST_ACK │         │
│  └────┬─────┘                          └────┬─────┘         │
│       │ timeout (2MSL)                      │ ACK           │
│       ▼                                     ▼               │
│  ┌──────────┐                          ┌──────────┐         │
│  │  CLOSED  │                          │  CLOSED  │         │
│  └──────────┘                          └──────────┘         │
└─────────────────────────────────────────────────────────────┘
```

---

## Практика: код на Python

### TCP-сервер

```python
import socket

# Создаём TCP сокет
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 8080))
server.listen(5)  # Очередь из 5 соединений

print("TCP-сервер запущен на порту 8080")

while True:
    client, address = server.accept()  # Ждём соединение (handshake)
    print(f"Подключение от {address}")

    data = client.recv(1024)  # Получаем данные
    print(f"Получено: {data.decode()}")

    client.send(b"Hello from TCP server!")  # Отправляем ответ
    client.close()  # Закрываем соединение (4-way handshake)
```

### TCP-клиент

```python
import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('127.0.0.1', 8080))  # Устанавливаем соединение

client.send(b"Hello from TCP client!")  # Отправляем данные
response = client.recv(1024)  # Получаем ответ
print(f"Ответ: {response.decode()}")

client.close()
```

### UDP-сервер

```python
import socket

# Создаём UDP сокет
server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server.bind(('0.0.0.0', 8080))

print("UDP-сервер запущен на порту 8080")

while True:
    data, address = server.recvfrom(1024)  # Получаем датаграмму
    print(f"Получено от {address}: {data.decode()}")

    server.sendto(b"Hello from UDP server!", address)  # Отправляем ответ
```

### UDP-клиент

```python
import socket

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Нет connect()! Просто отправляем датаграмму
client.sendto(b"Hello from UDP client!", ('127.0.0.1', 8080))

response, server = client.recvfrom(1024)
print(f"Ответ: {response.decode()}")

client.close()
```

---

## Проверка TCP/UDP в командной строке

```bash
# Показать активные TCP соединения
netstat -ant          # Linux/macOS
netstat -an | grep TCP  # Windows

# Показать активные UDP соединения
netstat -anu          # Linux
netstat -an | grep UDP  # Windows

# Проверить, слушает ли порт
ss -tlnp              # Linux (TCP)
ss -ulnp              # Linux (UDP)
lsof -i :8080         # macOS

# Тестировать TCP порт
nc -vz google.com 80  # netcat
telnet google.com 80

# Тестировать UDP порт
nc -vzu 8.8.8.8 53    # netcat UDP

# Захват пакетов (для анализа TCP/UDP)
sudo tcpdump -i any port 8080
wireshark             # GUI инструмент
```

---

## Ключевые моменты для backend-разработчика

1. **HTTP работает поверх TCP** — каждый API-запрос использует TCP
2. **WebSocket** — persistent TCP-соединение для real-time
3. **gRPC** — использует HTTP/2 (TCP) с эффективным бинарным форматом
4. **DNS** — обычно UDP, но большие ответы могут использовать TCP
5. **Нагрузочное тестирование** — понимание TCP важно для анализа проблем
6. **Keep-Alive** — переиспользование TCP-соединений для производительности
