# Команда test

[prev: 02-exit-status](./02-exit-status.md) | [next: 04-logical-operators](./04-logical-operators.md)

---
## Что такое test

Команда `test` оценивает условные выражения и возвращает код возврата:
- **0** - условие истинно (true)
- **1** - условие ложно (false)

```bash
test -f "/etc/passwd"
echo $?  # 0 (файл существует)

test -f "/nonexistent"
echo $?  # 1 (файл не существует)
```

## Синтаксис

### Три формы записи

```bash
# Форма 1: команда test
test условие

# Форма 2: одинарные скобки [ ]
[ условие ]

# Форма 3: двойные скобки [[ ]]  (bash)
[[ условие ]]
```

**Важно:** пробелы внутри скобок обязательны!

```bash
# ПРАВИЛЬНО
[ -f "$file" ]
[[ -f "$file" ]]

# НЕПРАВИЛЬНО
[-f "$file"]     # Ошибка синтаксиса
[[ -f "$file"]]  # Ошибка синтаксиса
```

## [ ] vs [[ ]]

| Особенность | `[ ]` | `[[ ]]` |
|-------------|-------|---------|
| POSIX-совместимость | Да | Нет (только bash) |
| Word splitting | Да | Нет |
| Pathname expansion | Да | Нет |
| Pattern matching | Нет | Да (`==`, `!=`) |
| Regex matching | Нет | Да (`=~`) |
| Логические операторы | `-a`, `-o` | `&&`, `||` |

### Примеры различий

```bash
file="my file.txt"  # Имя с пробелом

# [ ] требует кавычки
[ -f $file ]        # ОШИБКА: разбивается на слова
[ -f "$file" ]      # Правильно

# [[ ]] не требует (но лучше использовать)
[[ -f $file ]]      # Работает
[[ -f "$file" ]]    # Тоже работает (рекомендуется)
```

**Рекомендация:** Используйте `[[ ]]` в bash-скриптах для надёжности.

## Операторы сравнения строк

```bash
# Равенство
[[ "$str1" == "$str2" ]]
[[ "$str1" = "$str2" ]]   # То же самое

# Неравенство
[[ "$str1" != "$str2" ]]

# Строка пуста
[[ -z "$str" ]]

# Строка не пуста
[[ -n "$str" ]]

# Лексикографическое сравнение
[[ "$str1" < "$str2" ]]   # str1 меньше
[[ "$str1" > "$str2" ]]   # str1 больше
```

### Примеры со строками

```bash
name="Alice"

if [[ "$name" == "Alice" ]]; then
    echo "Привет, Алиса!"
fi

# Проверка на пустоту
if [[ -z "$name" ]]; then
    echo "Имя не задано"
else
    echo "Имя: $name"
fi

# Проверка наличия значения
if [[ -n "$USER" ]]; then
    echo "Текущий пользователь: $USER"
fi
```

## Операторы сравнения чисел

```bash
# Равно
[[ $a -eq $b ]]

# Не равно
[[ $a -ne $b ]]

# Больше
[[ $a -gt $b ]]

# Больше или равно
[[ $a -ge $b ]]

# Меньше
[[ $a -lt $b ]]

# Меньше или равно
[[ $a -le $b ]]
```

### Примеры с числами

```bash
age=25

if [[ $age -ge 18 ]]; then
    echo "Совершеннолетний"
else
    echo "Несовершеннолетний"
fi

# Проверка диапазона
if [[ $age -ge 18 && $age -le 65 ]]; then
    echo "Трудоспособный возраст"
fi
```

### Арифметическое сравнение с (( ))

Для числовых сравнений удобнее использовать `(( ))`:

```bash
a=10
b=20

# Традиционные операторы сравнения
if (( a < b )); then
    echo "$a меньше $b"
fi

if (( a == b )); then
    echo "Равны"
fi

if (( a >= 10 && a <= 20 )); then
    echo "a в диапазоне [10, 20]"
fi
```

## Операторы проверки файлов

### Существование и тип

```bash
[[ -e "$path" ]]  # Существует (файл, директория, ссылка)
[[ -f "$path" ]]  # Обычный файл
[[ -d "$path" ]]  # Директория
[[ -L "$path" ]]  # Символическая ссылка
[[ -h "$path" ]]  # То же, что -L
[[ -p "$path" ]]  # Именованный канал (FIFO)
[[ -S "$path" ]]  # Сокет
[[ -b "$path" ]]  # Блочное устройство
[[ -c "$path" ]]  # Символьное устройство
```

### Права доступа

```bash
[[ -r "$file" ]]  # Доступен для чтения
[[ -w "$file" ]]  # Доступен для записи
[[ -x "$file" ]]  # Доступен для выполнения
[[ -u "$file" ]]  # Установлен SUID
[[ -g "$file" ]]  # Установлен SGID
[[ -k "$file" ]]  # Установлен sticky bit
```

### Размер и содержимое

```bash
[[ -s "$file" ]]  # Размер больше нуля
[[ -N "$file" ]]  # Изменён после последнего чтения
```

### Сравнение файлов

```bash
[[ "$file1" -nt "$file2" ]]  # file1 новее file2
[[ "$file1" -ot "$file2" ]]  # file1 старше file2
[[ "$file1" -ef "$file2" ]]  # Один и тот же файл (hard link)
```

### Примеры с файлами

```bash
#!/bin/bash

file="/etc/passwd"

# Проверка существования и типа
if [[ -f "$file" ]]; then
    echo "$file - обычный файл"
elif [[ -d "$file" ]]; then
    echo "$file - директория"
elif [[ -L "$file" ]]; then
    echo "$file - символическая ссылка"
else
    echo "$file - не существует или особый файл"
fi

# Проверка прав
if [[ -r "$file" && -w "$file" ]]; then
    echo "Доступен для чтения и записи"
elif [[ -r "$file" ]]; then
    echo "Только для чтения"
else
    echo "Нет доступа"
fi
```

## Pattern Matching (только [[]])

```bash
# Wildcard matching
[[ "$file" == *.txt ]]     # Заканчивается на .txt
[[ "$file" == log_* ]]     # Начинается с log_
[[ "$file" == *[0-9]* ]]   # Содержит цифру

# Case-insensitive (bash 4+)
shopt -s nocasematch
[[ "$str" == "hello" ]]    # Соответствует HELLO, Hello и т.д.
shopt -u nocasematch
```

### Примеры с паттернами

```bash
filename="report_2024.txt"

if [[ "$filename" == *.txt ]]; then
    echo "Текстовый файл"
fi

if [[ "$filename" == report_* ]]; then
    echo "Это отчёт"
fi

if [[ "$filename" == *_[0-9][0-9][0-9][0-9].* ]]; then
    echo "Файл с годом в имени"
fi
```

## Регулярные выражения (только [[]])

Оператор `=~` для regex:

```bash
# Проверка email
email="user@example.com"
if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echo "Валидный email"
fi

# Проверка даты
date="2024-01-15"
if [[ "$date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    echo "Валидный формат даты"
fi

# Захват групп
if [[ "John:25" =~ ^([^:]+):([0-9]+)$ ]]; then
    echo "Имя: ${BASH_REMATCH[1]}"
    echo "Возраст: ${BASH_REMATCH[2]}"
fi
```

## Логические операторы

### Внутри [[ ]]

```bash
# AND (И)
[[ условие1 && условие2 ]]

# OR (ИЛИ)
[[ условие1 || условие2 ]]

# NOT (НЕ)
[[ ! условие ]]
```

### Между командами

```bash
# AND
[[ условие1 ]] && [[ условие2 ]]

# OR
[[ условие1 ]] || [[ условие2 ]]
```

### Примеры

```bash
age=25
name="Alice"

# Сложные условия
if [[ $age -ge 18 && -n "$name" ]]; then
    echo "$name - совершеннолетний"
fi

# Проверка файла
file="/etc/passwd"
if [[ -f "$file" && -r "$file" && -s "$file" ]]; then
    echo "Файл существует, доступен для чтения и не пуст"
fi

# Альтернативы
if [[ "$response" == "y" || "$response" == "yes" ]]; then
    echo "Подтверждено"
fi
```

## Приоритет операторов

От высшего к низшему:
1. `!` (NOT)
2. `&&` (AND)
3. `||` (OR)

```bash
# Пример с приоритетом
[[ ! -f "$file" && -d "$dir" ]]  # (NOT -f) AND (-d)

# Используйте скобки для явного порядка
[[ -f "$file" && ( -r "$file" || -w "$file" ) ]]
```

---

[prev: 02-exit-status](./02-exit-status.md) | [next: 04-logical-operators](./04-logical-operators.md)
