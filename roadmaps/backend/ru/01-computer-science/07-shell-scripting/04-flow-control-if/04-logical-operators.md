# Логические операторы

## Обзор логических операторов

В bash есть несколько способов комбинирования условий:

| Оператор | Контекст | Описание |
|----------|----------|----------|
| `&&` | Между командами / внутри `[[ ]]` | Логическое И |
| `||` | Между командами / внутри `[[ ]]` | Логическое ИЛИ |
| `!` | Внутри `[[ ]]` | Логическое НЕ |
| `-a` | Внутри `[ ]` | Логическое И (устаревший) |
| `-o` | Внутри `[ ]` | Логическое ИЛИ (устаревший) |

## Оператор && (логическое И)

### Между командами

Вторая команда выполняется только если первая успешна:

```bash
# Если mkdir успешен, выполнить cd
mkdir new_dir && cd new_dir

# Цепочка команд
apt-get update && apt-get upgrade && apt-get autoremove
```

### Внутри [[ ]]

```bash
if [[ условие1 && условие2 ]]; then
    echo "Оба условия истинны"
fi

# Пример
if [[ $age -ge 18 && $age -le 65 ]]; then
    echo "Трудоспособный возраст"
fi
```

## Оператор || (логическое ИЛИ)

### Между командами

Вторая команда выполняется только если первая неуспешна:

```bash
# Если cd неуспешен, вывести сообщение
cd /nonexistent || echo "Директория не существует"

# Обработка ошибок
command || { echo "Ошибка!"; exit 1; }
```

### Внутри [[ ]]

```bash
if [[ условие1 || условие2 ]]; then
    echo "Хотя бы одно условие истинно"
fi

# Пример
if [[ "$answer" == "y" || "$answer" == "yes" ]]; then
    echo "Подтверждено"
fi
```

## Оператор ! (логическое НЕ)

### Инверсия условия

```bash
if [[ ! -f "$file" ]]; then
    echo "Файл не существует"
fi

# Инверсия сложного условия
if [[ ! ( $a -eq 1 && $b -eq 2 ) ]]; then
    echo "Условие не выполнено"
fi
```

### Инверсия кода возврата

```bash
# Инверсия команды
if ! grep -q "pattern" file.txt; then
    echo "Паттерн не найден"
fi

# Эквивалентно
if grep -q "pattern" file.txt; then
    :  # ничего
else
    echo "Паттерн не найден"
fi
```

## Комбинирование операторов

### Приоритет операторов

1. `!` (НЕ) - высший приоритет
2. `&&` (И)
3. `||` (ИЛИ) - низший приоритет

```bash
# Это выражение:
[[ ! $a && $b || $c ]]

# Эквивалентно:
[[ ((! $a) && $b) || $c ]]
```

### Группировка с помощью скобок

```bash
# Явный порядок вычисления
if [[ $a || ( $b && $c ) ]]; then
    echo "a истинно ИЛИ (b И c истинны)"
fi

# Без скобок было бы (a || b) && c
if [[ $a || $b && $c ]]; then
    # ...
fi
```

## Короткое замыкание (Short-circuit evaluation)

### && - прекращает при первом false

```bash
# Если первое условие ложно, второе не проверяется
[[ -f "$file" && $(cat "$file") == "content" ]]
# Если файл не существует, cat не выполнится
```

### || - прекращает при первом true

```bash
# Если первое условие истинно, второе не проверяется
[[ -f "$file1" || -f "$file2" ]]
# Если file1 существует, file2 не проверяется
```

### Практическое применение

```bash
# Безопасное обращение к файлу
[[ -f "$config" ]] && source "$config"

# Значение по умолчанию
[[ -n "$dir" ]] || dir="/tmp"

# Проверка перед использованием
[[ -n "$var" && "${var:-}" != "invalid" ]]
```

## Паттерны использования

### Паттерн: Guard clause (защитное условие)

```bash
# Вместо вложенных if
process_file() {
    [[ -f "$1" ]] || { echo "Не файл"; return 1; }
    [[ -r "$1" ]] || { echo "Нет доступа"; return 1; }
    [[ -s "$1" ]] || { echo "Файл пуст"; return 1; }

    # Основная логика
    cat "$1"
}
```

### Паттерн: Обязательная зависимость

```bash
# Проверка зависимостей
command -v git &>/dev/null || { echo "Git не установлен"; exit 1; }
command -v curl &>/dev/null || { echo "curl не установлен"; exit 1; }

# Продолжение скрипта...
```

### Паттерн: Условное присваивание

```bash
# Установить значение, если переменная пуста
[[ -z "$CONFIG" ]] && CONFIG="/etc/default.conf"

# Или более идиоматично
CONFIG="${CONFIG:-/etc/default.conf}"
```

### Паттерн: Проверка нескольких условий

```bash
# Все условия должны быть истинны
check_requirements() {
    [[ -n "$DB_HOST" ]] &&
    [[ -n "$DB_USER" ]] &&
    [[ -n "$DB_PASS" ]] &&
    [[ -n "$DB_NAME" ]]
}

if check_requirements; then
    echo "Все параметры БД заданы"
else
    echo "Не хватает параметров БД"
fi
```

### Паттерн: Тернарный оператор

```bash
# Условие && если_истина || если_ложь
[[ $age -ge 18 ]] && status="adult" || status="minor"

echo "Status: $status"
```

**Осторожно:** Если команда после `&&` вернёт ошибку, выполнится часть после `||`:

```bash
# Потенциальная проблема
[[ $x -gt 0 ]] && echo "positive" | grep -q "pos" || echo "non-positive"
# Если grep не найдёт (хотя найдёт), выведется "non-positive"

# Безопаснее использовать if
if [[ $x -gt 0 ]]; then
    echo "positive"
else
    echo "non-positive"
fi
```

## Сложные условия

### Множественные проверки типов файлов

```bash
# Проверка, что это исполняемый скрипт
if [[ -f "$file" && -r "$file" && -x "$file" ]]; then
    echo "$file - исполняемый файл"
fi

# Проверка конфигурационного файла
is_valid_config() {
    local file=$1
    [[ -f "$file" ]] &&
    [[ -r "$file" ]] &&
    [[ -s "$file" ]] &&
    [[ "$file" == *.conf ]]
}
```

### Диапазоны значений

```bash
# Проверка диапазона
in_range() {
    local value=$1
    local min=$2
    local max=$3
    [[ $value -ge $min && $value -le $max ]]
}

if in_range "$port" 1024 65535; then
    echo "Порт в допустимом диапазоне"
fi
```

### Проверка нескольких возможных значений

```bash
# Проверка через pattern matching
if [[ "$response" == [yY]* || "$response" == "да" ]]; then
    echo "Подтверждено"
fi

# Или через case (предпочтительнее для множества вариантов)
case "$response" in
    y|Y|yes|Yes|YES|да|Да|ДА)
        echo "Подтверждено"
        ;;
esac
```

## Отладка логических выражений

### Вывод условий

```bash
# Для отладки выводите условия
debug_condition() {
    echo "file=$file, exists=$(test -f "$file" && echo true || echo false)"
    echo "readable=$(test -r "$file" && echo true || echo false)"
}

debug_condition
if [[ -f "$file" && -r "$file" ]]; then
    echo "OK"
fi
```

### set -x для трассировки

```bash
set -x  # Включить трассировку
[[ -f "$file" && -r "$file" ]] && echo "OK"
set +x  # Выключить трассировку
```

Вывод покажет каждое вычисляемое условие:
```
+ [[ -f /etc/passwd ]]
+ [[ -r /etc/passwd ]]
+ echo OK
OK
```
