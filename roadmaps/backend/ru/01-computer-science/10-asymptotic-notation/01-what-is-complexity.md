# Что такое сложность алгоритма (Complexity)

[prev: 10-browsers-and-how-they-work](../09-networking-and-internet/10-browsers-and-how-they-work.md) | [next: 02-big-o](./02-big-o.md)

---
## Определение

**Сложность алгоритма** — это мера количества ресурсов (времени или памяти), необходимых для выполнения алгоритма в зависимости от размера входных данных.

Существует два основных типа сложности:
- **Временная сложность (Time Complexity)** — сколько операций выполнит алгоритм
- **Пространственная сложность (Space Complexity)** — сколько памяти потребуется

## Зачем нужно

### Практическое применение

1. **Выбор алгоритма** — позволяет сравнить эффективность разных решений
2. **Прогнозирование производительности** — понять, как алгоритм поведёт себя на больших данных
3. **Оптимизация** — найти узкие места в коде
4. **Собеседования** — стандартный вопрос при приёме на работу

### Пример из реальной жизни

Представьте, что нужно найти книгу в библиотеке:
- **Перебор всех книг** — O(n): нужно проверить каждую книгу
- **Поиск по каталогу** — O(log n): каждый шаг уменьшает область поиска вдвое

При 1 000 000 книг:
- Перебор: до 1 000 000 операций
- Каталог: около 20 операций

## Как работает

### Подсчёт операций

Мы не измеряем время в секундах (оно зависит от железа), а считаем **количество элементарных операций**:

```python
def sum_array(arr):
    total = 0           # 1 операция
    for x in arr:       # n итераций
        total += x      # 1 операция × n раз
    return total        # 1 операция

# Всего: 1 + n + 1 = n + 2 операций
```

### Асимптотический анализ

При анализе сложности нас интересует **поведение при больших n**:

```
n + 2 ≈ n при больших n
3n² + 5n + 100 ≈ n² при больших n
```

**Правила упрощения:**
1. Отбрасываем константы: `5n → n`
2. Оставляем только старший член: `n² + n → n²`
3. Игнорируем младшие слагаемые: `n³ + n² + n → n³`

### Виды случаев

При анализе рассматривают три сценария:

| Случай | Описание | Пример для поиска в массиве |
|--------|----------|----------------------------|
| **Best case** (лучший) | Минимальное число операций | Элемент в начале |
| **Average case** (средний) | Типичный сценарий | Элемент где-то в середине |
| **Worst case** (худший) | Максимальное число операций | Элемент в конце или отсутствует |

## Визуализация

### Рост функций при увеличении n

```
Операции
    ↑
    │                                    ╱ n²
    │                                  ╱
    │                               ╱
    │                            ╱    _____ n
    │                         ╱  ____╱
    │                      ╱__╱
    │               ___╱╱
    │         __╱╱╱   ............... log n
    │    _╱╱╱    ..................
    │ ╱╱       ...................  ────── 1
    └────────────────────────────────────→ n (размер данных)
```

### Таблица роста

| n | 1 | log n | n | n log n | n² | 2ⁿ |
|---|---|-------|---|---------|----|----|
| 10 | 1 | 3 | 10 | 33 | 100 | 1024 |
| 100 | 1 | 7 | 100 | 664 | 10,000 | 10³⁰ |
| 1000 | 1 | 10 | 1000 | 9,966 | 1,000,000 | 10³⁰⁰ |

## Примеры с разбором

### Пример 1: Константная сложность O(1)

```python
def get_first(arr):
    return arr[0]  # Всегда 1 операция, независимо от размера массива
```

**Разбор:** Доступ к элементу по индексу — одна операция.

### Пример 2: Линейная сложность O(n)

```python
def find_max(arr):
    max_val = arr[0]
    for x in arr:          # n итераций
        if x > max_val:
            max_val = x
    return max_val
```

**Разбор:** Проходим по всем n элементам один раз.

### Пример 3: Квадратичная сложность O(n²)

```python
def has_duplicates(arr):
    n = len(arr)
    for i in range(n):         # n итераций
        for j in range(i+1, n): # в среднем n/2 итераций
            if arr[i] == arr[j]:
                return True
    return False
```

**Разбор:** Вложенные циклы дают n × n операций.

### Пример 4: Логарифмическая сложность O(log n)

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**Разбор:** Каждую итерацию область поиска уменьшается вдвое.

## Типичные ошибки

### 1. Путать временную и пространственную сложность

```python
# Временная: O(n), Пространственная: O(n)
def create_copy(arr):
    return [x for x in arr]

# Временная: O(n), Пространственная: O(1)
def find_sum(arr):
    return sum(arr)
```

### 2. Забывать о скрытых операциях

```python
def check(arr, target):
    return target in arr  # Это O(n), не O(1)!

def check_set(s, target):
    return target in s    # Для set это O(1)
```

### 3. Неправильно считать вложенные циклы

```python
# Это O(n), не O(n²)!
for i in range(n):
    for j in range(5):  # Константа, не зависит от n
        print(i, j)

# А это O(n²)
for i in range(n):
    for j in range(n):  # Зависит от n
        print(i, j)
```

### 4. Игнорировать сложность встроенных операций

```python
# Сортировка — O(n log n)
arr.sort()

# Вставка в начало списка — O(n)
arr.insert(0, value)

# Конкатенация строк в цикле — O(n²)
result = ""
for s in strings:
    result += s  # Каждый раз создаётся новая строка!
```

## Резюме

- Сложность показывает, как алгоритм масштабируется
- Анализируем худший случай (worst case)
- Отбрасываем константы и младшие члены
- Важно знать сложность стандартных операций в языке

---

[prev: 10-browsers-and-how-they-work](../09-networking-and-internet/10-browsers-and-how-they-work.md) | [next: 02-big-o](./02-big-o.md)
