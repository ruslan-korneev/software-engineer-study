# dd - копирование и преобразование данных

[prev: 03-mkfs-fsck](./03-mkfs-fsck.md) | [next: 01-ping-traceroute](../03-networking/01-ping-traceroute.md)

---
## Что такое dd?

**dd** (data duplicator или disk dump) - низкоуровневая утилита для копирования и преобразования данных. Она работает напрямую с блочными устройствами, обходя файловую систему.

**ВНИМАНИЕ:** dd не спрашивает подтверждения и может мгновенно уничтожить все данные при неправильном использовании. Шутливые расшифровки: "disk destroyer", "delete data".

## Базовый синтаксис

```bash
dd if=источник of=назначение [опции]
```

- **if** (input file) - источник данных
- **of** (output file) - куда записывать
- Без `if` - читает из stdin
- Без `of` - пишет в stdout

## Основные опции

| Опция | Описание |
|-------|----------|
| `bs=размер` | Размер блока чтения и записи |
| `ibs=размер` | Размер блока чтения |
| `obs=размер` | Размер блока записи |
| `count=N` | Скопировать только N блоков |
| `skip=N` | Пропустить N блоков в начале источника |
| `seek=N` | Пропустить N блоков в начале назначения |
| `conv=опции` | Опции преобразования |
| `status=progress` | Показывать прогресс |

### Размеры блоков

```bash
# Можно использовать суффиксы:
bs=512      # байты
bs=1K       # 1024 байта
bs=1M       # 1 мегабайт
bs=1G       # 1 гигабайт
bs=4k       # 4096 байт (регистр не важен)
```

### Опции conv

| Опция | Описание |
|-------|----------|
| `noerror` | Продолжать при ошибках чтения |
| `notrunc` | Не обрезать выходной файл |
| `sync` | Дополнять блоки нулями при ошибках |
| `fsync` | Синхронизировать данные перед завершением |
| `ucase` | Преобразовать в верхний регистр |
| `lcase` | Преобразовать в нижний регистр |
| `swab` | Поменять местами каждую пару байт |

## Примеры использования

### Создание образа диска/раздела

```bash
# Образ всего диска
sudo dd if=/dev/sda of=/backup/disk.img bs=4M status=progress

# Образ раздела
sudo dd if=/dev/sda1 of=/backup/partition.img bs=4M status=progress

# Сжатый образ
sudo dd if=/dev/sda bs=4M status=progress | gzip > disk.img.gz

# Ещё лучше сжатие
sudo dd if=/dev/sda bs=4M status=progress | xz -9 > disk.img.xz
```

### Восстановление из образа

```bash
# Восстановить диск из образа
sudo dd if=/backup/disk.img of=/dev/sdb bs=4M status=progress

# Из сжатого образа
gunzip -c disk.img.gz | sudo dd of=/dev/sdb bs=4M status=progress

# Из xz
xz -dc disk.img.xz | sudo dd of=/dev/sdb bs=4M status=progress
```

### Клонирование дисков

```bash
# Клонировать диск на диск
sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress conv=fsync

# ВНИМАНИЕ: диски должны быть одинакового или большего размера
```

### Создание загрузочной USB

```bash
# Записать ISO на флешку
sudo dd if=ubuntu.iso of=/dev/sdb bs=4M status=progress conv=fsync

# После записи - синхронизация
sync

# Безопасное извлечение
sudo eject /dev/sdb
```

### Очистка диска

```bash
# Заполнить нулями (быстро)
sudo dd if=/dev/zero of=/dev/sdb bs=4M status=progress

# Заполнить случайными данными (медленнее, безопаснее)
sudo dd if=/dev/urandom of=/dev/sdb bs=4M status=progress

# Удалить только MBR (первые 512 байт)
sudo dd if=/dev/zero of=/dev/sdb bs=512 count=1

# Удалить GPT (начало и конец диска)
sudo dd if=/dev/zero of=/dev/sdb bs=1M count=10
sudo dd if=/dev/zero of=/dev/sdb bs=1M count=10 seek=$((SIZE-10))
```

### Создание файла заданного размера

```bash
# Файл из нулей (разреженный)
dd if=/dev/zero of=file.img bs=1M count=100

# Файл реального размера (не разреженный)
dd if=/dev/zero of=file.img bs=1M count=0 seek=100

# Файл для swap
sudo dd if=/dev/zero of=/swapfile bs=1M count=4096
sudo chmod 600 /swapfile
sudo mkswap /swapfile
```

### Резервное копирование MBR

```bash
# Сохранить MBR (первые 512 байт)
sudo dd if=/dev/sda of=mbr_backup.bin bs=512 count=1

# Сохранить MBR + расширенную таблицу разделов
sudo dd if=/dev/sda of=mbr_extended.bin bs=512 count=63

# Восстановить MBR (ОСТОРОЖНО!)
sudo dd if=mbr_backup.bin of=/dev/sda bs=512 count=1

# Восстановить только загрузчик (не трогать таблицу разделов)
sudo dd if=mbr_backup.bin of=/dev/sda bs=446 count=1
```

### Резервное копирование GPT

```bash
# Для GPT нужно сохранить больше данных
# Первые 34 сектора содержат GPT header и entries
sudo dd if=/dev/sda of=gpt_backup.bin bs=512 count=34

# Лучше использовать sgdisk
sudo sgdisk --backup=gpt_table.bin /dev/sda
```

### Тестирование скорости диска

```bash
# Скорость записи
dd if=/dev/zero of=testfile bs=1M count=1024 conv=fdatasync status=progress
# Результат: 1073741824 bytes copied, X s, Y MB/s

# Скорость чтения (очистить кеш перед тестом)
sudo sh -c "echo 3 > /proc/sys/vm/drop_caches"
dd if=testfile of=/dev/null bs=1M status=progress

# Удалить тестовый файл
rm testfile
```

## Показ прогресса

### Встроенный способ (dd)

```bash
# С опцией status=progress (современные версии dd)
dd if=/dev/sda of=disk.img bs=4M status=progress
```

### Сигнал USR1

```bash
# В другом терминале отправить сигнал
sudo kill -USR1 $(pgrep ^dd$)

# Автоматически каждые 5 секунд
watch -n 5 'sudo kill -USR1 $(pgrep ^dd$)'
```

### Использование pv (pipe viewer)

```bash
# Установка
sudo apt install pv

# Использование
sudo dd if=/dev/sda bs=4M | pv -s 500G | dd of=disk.img bs=4M

# Или проще
pv /dev/sda > disk.img

# С gzip
pv /dev/sda | gzip > disk.img.gz
```

## dcfldd и dc3dd - альтернативы

Расширенные версии dd с дополнительными функциями:

```bash
# Установка
sudo apt install dcfldd

# Прогресс по умолчанию
sudo dcfldd if=/dev/sda of=disk.img bs=4M

# Параллельный хеш
sudo dcfldd if=/dev/sda hash=md5,sha256 hashlog=hashes.txt of=disk.img

# Несколько выходных файлов
sudo dcfldd if=/dev/sda of=disk1.img of=disk2.img
```

## Безопасное использование dd

### Проверка перед выполнением

```bash
# 1. Всегда проверяйте устройства
lsblk
sudo fdisk -l

# 2. Убедитесь в правильности if и of
# НЕПРАВИЛЬНО: if=/dev/sdb of=/dev/sda (перезапишет sda!)
# ПРАВИЛЬНО:   if=/dev/sda of=/dev/sdb

# 3. Размонтируйте устройства
sudo umount /dev/sdb*
```

### Защита от ошибок

```bash
# Режим только чтения для защиты диска
sudo blockdev --setro /dev/sda

# Снять защиту
sudo blockdev --setrw /dev/sda
```

### Верификация копии

```bash
# Создать образ с хешем
sudo dd if=/dev/sda of=disk.img bs=4M status=progress
md5sum disk.img > disk.img.md5

# Проверить при восстановлении
md5sum -c disk.img.md5
```

## Полезные комбинации

### Копирование с пропуском ошибок

```bash
# Для повреждённых дисков
sudo dd if=/dev/sda of=disk.img bs=4k conv=noerror,sync status=progress

# Лучше использовать ddrescue
sudo ddrescue /dev/sda disk.img rescue.log
```

### Преобразование формата

```bash
# Конвертировать raw в qcow2 (для виртуализации)
qemu-img convert -f raw -O qcow2 disk.img disk.qcow2
```

### Сетевое копирование

```bash
# На удалённой машине (получатель)
nc -l -p 19000 | dd of=/dev/sdb bs=4M

# На локальной машине (отправитель)
dd if=/dev/sda bs=4M | nc remote_host 19000

# С сжатием
dd if=/dev/sda bs=4M | gzip | nc remote_host 19000
nc -l -p 19000 | gunzip | dd of=/dev/sdb bs=4M

# Через SSH (безопаснее)
dd if=/dev/sda bs=4M | ssh user@remote 'dd of=/dev/sdb bs=4M'
```

### Работа с разделами

```bash
# Скопировать загрузочный раздел
sudo dd if=/dev/sda1 of=boot_partition.img bs=4M status=progress

# Восстановить на новый диск (после создания раздела)
sudo dd if=boot_partition.img of=/dev/sdb1 bs=4M status=progress
```

## Альтернативы dd

| Утилита | Описание |
|---------|----------|
| **ddrescue** | Восстановление данных с повреждённых дисков |
| **dcfldd** | Расширенный dd с хешированием |
| **pv** | Показ прогресса для потоков |
| **cat** | Простое копирование файлов |
| **cp** | Копирование с сохранением атрибутов |
| **rsync** | Инкрементальное копирование |
| **clonezilla** | GUI для клонирования дисков |

## Практические советы

### 1. Выбор размера блока

```bash
# Маленький блок (512, 4K) - медленно, но точно
# Большой блок (1M, 4M, 64M) - быстро

# Для HDD обычно оптимально
bs=4M

# Для SSD можно больше
bs=64M

# Тест оптимального размера
for bs in 512 4k 64k 1M 4M 16M; do
    echo "Testing bs=$bs"
    dd if=/dev/zero of=test bs=$bs count=1000 oflag=dsync 2>&1 | tail -1
done
rm test
```

### 2. Синхронизация после записи

```bash
# Всегда добавляйте sync
dd if=image.iso of=/dev/sdb bs=4M conv=fsync status=progress
sync

# Или используйте oflag
dd if=image.iso of=/dev/sdb bs=4M oflag=sync status=progress
```

### 3. Избегайте записи на смонтированные ФС

```bash
# Проверить что не смонтировано
mount | grep sdb

# Размонтировать все разделы
sudo umount /dev/sdb*
```

## Резюме

```bash
# Создать образ диска
sudo dd if=/dev/sda of=disk.img bs=4M status=progress

# Записать ISO на USB
sudo dd if=file.iso of=/dev/sdb bs=4M status=progress conv=fsync && sync

# Клонировать диск
sudo dd if=/dev/sda of=/dev/sdb bs=4M status=progress conv=fsync

# Очистить диск
sudo dd if=/dev/zero of=/dev/sdb bs=4M status=progress

# Тест скорости
dd if=/dev/zero of=testfile bs=1M count=1024 conv=fdatasync

# Резервное копирование MBR
sudo dd if=/dev/sda of=mbr.bin bs=512 count=1
```

---

[prev: 03-mkfs-fsck](./03-mkfs-fsck.md) | [next: 01-ping-traceroute](../03-networking/01-ping-traceroute.md)
