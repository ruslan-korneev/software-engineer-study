# Класс NP (Nondeterministic Polynomial Time)

[prev: 02-class-p](./02-class-p.md) | [next: 04-np-complete](./04-np-complete.md)
---

## Определение

### Формальное определение

**Класс NP** — это множество задач принятия решений, для которых "да"-ответ можно проверить за полиномиальное время при наличии подсказки (сертификата).

```
NP = { L | существует полиномиальный верификатор V и полином p,
           такие что:
           x ∈ L ⟺ ∃ сертификат c, |c| ≤ p(|x|), V(x, c) = 1 }
```

### Альтернативное определение

NP — класс задач, решаемых недетерминированной машиной Тьюринга за полиномиальное время.

```
NP = { L | существует недетерминированная машина Тьюринга M,
           которая решает L за время O(n^k) }
```

### Интуитивное объяснение

**NP** = "легко проверить, возможно трудно найти"

Представьте судоку:
- **Решить** судоку может быть сложно (перебор)
- **Проверить** готовое решение легко (за секунды)

```
┌─────────────────────────────────────────────────────────────┐
│                      ИНТУИЦИЯ NP                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Задача: Найти решение (может быть экспоненциально долго)   │
│                                                             │
│  Верификация: Проверить решение (полиномиальное время)      │
│                                                             │
│  ┌──────────────┐         ┌──────────────┐                  │
│  │   Задача     │  ───►   │  Сертификат  │  ───►  Да/Нет    │
│  │   (вход)     │         │  (подсказка) │        за O(n^k) │
│  └──────────────┘         └──────────────┘                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Зачем нужно

### Практическое значение

1. **Классификация задач**: NP включает большинство "интересных" задач оптимизации
2. **Криптография**: безопасность основана на сложности задач из NP
3. **Практические приложения**: расписания, маршруты, распределение ресурсов
4. **Теоретическое значение**: центральный объект теории сложности

### Почему "N" в NP?

**NP** расшифровывается как **Nondeterministic Polynomial** (недетерминированно полиномиальное), а НЕ "Non-Polynomial"!

```
РАСПРОСТРАНЁННОЕ ЗАБЛУЖДЕНИЕ:
  ✗ NP = "не полиномиальное"

ПРАВИЛЬНО:
  ✓ NP = "недетерминированно полиномиальное"
  ✓ P ⊆ NP (все задачи из P также в NP!)
```

## Как работает

### Недетерминированная машина Тьюринга

```
┌─────────────────────────────────────────────────────────────┐
│          НЕДЕТЕРМИНИРОВАННАЯ МАШИНА ТЬЮРИНГА (НМТ)          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  В каждом состоянии НМТ может иметь НЕСКОЛЬКО возможных     │
│  переходов и "магически" выбирает правильный путь           │
│                                                             │
│                           ┌──► q₂ (переход 1)               │
│       q₁ ──── читает 'a' ─┼──► q₃ (переход 2)               │
│                           └──► q₄ (переход 3)               │
│                                                             │
│  НМТ принимает вход, если СУЩЕСТВУЕТ путь к принятию        │
│                                                             │
│          ┌──────────────────────────────────────┐           │
│          │        ДЕРЕВО ВЫЧИСЛЕНИЙ             │           │
│          │                                      │           │
│          │              start                   │           │
│          │            /   |   \                 │           │
│          │           /    |    \                │           │
│          │          v     v     v               │           │
│          │         q₁    q₂    q₃               │           │
│          │        / \     |   / | \             │           │
│          │       v   v    v  v  v  v            │           │
│          │      ...      ACCEPT                 │           │
│          │                 ↑                    │           │
│          │       Достаточно одного пути!        │           │
│          └──────────────────────────────────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Верификатор

Эквивалентное определение через верификатор:

```python
def verifier(instance, certificate):
    """
    Верификатор для NP-задачи:
    - instance: входные данные задачи
    - certificate: "подсказка" (потенциальное решение)
    - Возвращает: True если certificate — корректное решение
    - Время работы: полиномиальное от |instance|
    """
    pass

# Задача L ∈ NP, если:
# 1. x ∈ L ⟹ ∃ certificate: verifier(x, certificate) = True
# 2. x ∉ L ⟹ ∀ certificate: verifier(x, certificate) = False
# 3. |certificate| ≤ poly(|x|)
# 4. verifier работает за полиномиальное время
```

## Примеры задач из класса NP

### 1. SAT (Boolean Satisfiability)

```
SAT:
  Вход: булева формула φ в КНФ
  Вопрос: существует ли набор значений, делающий φ = true?
  Сертификат: присваивание значений переменным
```

```python
def sat_verifier(formula, assignment):
    """
    Верификатор для SAT: O(n × m)
    formula: список дизъюнктов, каждый — список литералов
    assignment: словарь {переменная: True/False}
    """
    for clause in formula:
        clause_satisfied = False
        for literal in clause:
            var = literal.lstrip('~')
            value = assignment[var]
            if literal.startswith('~'):
                value = not value
            if value:
                clause_satisfied = True
                break
        if not clause_satisfied:
            return False  # Дизъюнкт не выполнен
    return True  # Все дизъюнкты выполнены

# Пример:
# φ = (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)
# formula = [['x1', 'x2'], ['~x1', 'x3'], ['~x2', '~x3']]
# assignment = {'x1': True, 'x2': False, 'x3': True}
# sat_verifier(formula, assignment) → True
```

### 2. CLIQUE (Клика)

```
CLIQUE:
  Вход: граф G = (V, E) и число k
  Вопрос: содержит ли G клику размера k?
  Сертификат: множество из k вершин
```

```python
def clique_verifier(graph, k, vertices):
    """
    Верификатор для CLIQUE: O(k²)
    graph: словарь {вершина: множество соседей}
    k: требуемый размер клики
    vertices: предполагаемая клика
    """
    # Проверяем размер
    if len(vertices) != k:
        return False

    # Проверяем, что все пары соединены рёбрами
    vertices_list = list(vertices)
    for i in range(len(vertices_list)):
        for j in range(i + 1, len(vertices_list)):
            v1, v2 = vertices_list[i], vertices_list[j]
            if v2 not in graph[v1]:
                return False  # Нет ребра между v1 и v2

    return True  # Это клика!

# Пример:
# graph = {'A': {'B', 'C'}, 'B': {'A', 'C', 'D'}, 'C': {'A', 'B'}, 'D': {'B'}}
# clique_verifier(graph, 3, {'A', 'B', 'C'}) → True
```

### 3. HAMPATH (Гамильтонов путь)

```
HAMPATH:
  Вход: граф G = (V, E)
  Вопрос: существует ли путь, проходящий через каждую вершину ровно раз?
  Сертификат: последовательность вершин
```

```python
def hampath_verifier(graph, path):
    """
    Верификатор для HAMPATH: O(n)
    graph: словарь {вершина: множество соседей}
    path: список вершин
    """
    n = len(graph)

    # Проверяем, что путь содержит все вершины ровно раз
    if len(path) != n or len(set(path)) != n:
        return False

    # Проверяем, что все вершины существуют и рёбра есть
    for i in range(len(path) - 1):
        if path[i + 1] not in graph[path[i]]:
            return False  # Нет ребра

    return True  # Гамильтонов путь!

# Пример:
# graph = {'A': {'B'}, 'B': {'A', 'C', 'D'}, 'C': {'B', 'D'}, 'D': {'B', 'C'}}
# hampath_verifier(graph, ['A', 'B', 'C', 'D']) → True
```

### 4. SUBSET-SUM (Сумма подмножества)

```
SUBSET-SUM:
  Вход: множество целых чисел S и целевое значение t
  Вопрос: существует ли подмножество S' ⊆ S с суммой t?
  Сертификат: подмножество S'
```

```python
def subset_sum_verifier(numbers, target, subset):
    """
    Верификатор для SUBSET-SUM: O(n)
    numbers: список чисел
    target: целевая сумма
    subset: индексы элементов в подмножестве
    """
    # Проверяем, что индексы корректны
    if not all(0 <= i < len(numbers) for i in subset):
        return False

    # Проверяем сумму
    total = sum(numbers[i] for i in subset)
    return total == target

# Пример:
# numbers = [3, 7, 1, 8, -2]
# target = 9
# subset = [0, 1, 4]  # 3 + 7 + (-2) = 8, неверно
# subset = [1, 4, 2]  # 7 + (-2) + 1 = 6, неверно
# subset = [0, 1, 4] → False; нужно найти правильное подмножество
```

## Диаграмма классов сложности

```
┌──────────────────────────────────────────────────────────────────┐
│                           EXPTIME                                │
│    ┌────────────────────────────────────────────────────────┐    │
│    │                         NP                             │    │
│    │                                                        │    │
│    │    ┌────────────────────────────────────────────┐      │    │
│    │    │                   P                        │      │    │
│    │    │                                            │      │    │
│    │    │  • Сортировка    • Кратчайший путь         │      │    │
│    │    │  • Поиск         • Простота числа          │      │    │
│    │    │  • 2-SAT         • Эйлеров путь            │      │    │
│    │    │                                            │      │    │
│    │    └────────────────────────────────────────────┘      │    │
│    │                                                        │    │
│    │    NP-complete (если P ≠ NP):                          │    │
│    │    • SAT              • Гамильтонов путь               │    │
│    │    • CLIQUE           • Раскраска графа                │    │
│    │    • SUBSET-SUM       • Рюкзак (решение)               │    │
│    │    • Vertex Cover     • Коммивояжёр (решение)          │    │
│    │                                                        │    │
│    └────────────────────────────────────────────────────────┘    │
│                                                                  │
│    Задачи вне NP (если NP ≠ co-NP):                              │
│    • UNSAT (дополнение SAT)                                      │
│    • TAUTOLOGY                                                   │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

## Сравнение P и NP

| Характеристика | P | NP |
|----------------|---|-----|
| Решение | За полиномиальное время | Возможно экспоненциальное |
| Верификация | За полиномиальное время | За полиномиальное время |
| Машина Тьюринга | Детерминированная | Недетерминированная |
| Сертификат | Не нужен | Полиномиального размера |
| Пример | Сортировка | SAT |

## co-NP

### Определение

**co-NP** — класс задач, дополнения которых лежат в NP.

```
co-NP = { L | L̄ ∈ NP }

Где L̄ = Σ* \ L (дополнение языка)
```

### Примеры

| NP | co-NP |
|----|-------|
| SAT (формула выполнима?) | UNSAT (формула невыполнима?) |
| CLIQUE (есть клика размера k?) | NO-CLIQUE (нет клики размера k?) |
| COMPOSITE (число составное?) | PRIMES (число простое?) |

### Диаграмма NP vs co-NP

```
┌────────────────────────────────────────────────────────┐
│                    Возможные сценарии                  │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Вариант 1: P = NP = co-NP                             │
│  ┌──────────────────────────────────┐                  │
│  │      P = NP = co-NP              │                  │
│  └──────────────────────────────────┘                  │
│                                                        │
│  Вариант 2: P ≠ NP, но NP = co-NP                      │
│  ┌──────────────────────────────────┐                  │
│  │         NP = co-NP               │                  │
│  │    ┌────────────────┐            │                  │
│  │    │       P        │            │                  │
│  │    └────────────────┘            │                  │
│  └──────────────────────────────────┘                  │
│                                                        │
│  Вариант 3: P ≠ NP и NP ≠ co-NP (наиболее вероятный)   │
│          ┌─────────┐   ┌─────────┐                     │
│          │   NP    │   │  co-NP  │                     │
│          │   ┌─────┴───┴─────┐   │                     │
│          │   │       P       │   │                     │
│          │   └───────────────┘   │                     │
│          └─────────────┴─────────┘                     │
│                  P ⊆ NP ∩ co-NP                        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## Исторический контекст

### Хронология

```
1936    Тьюринг: машины Тьюринга
         │
1965    Эдмондс: "хорошие алгоритмы" = полиномиальное время
         │
1971    Кук: определение NP, теорема о NP-полноте SAT
         │
1972    Карп: 21 NP-полная задача
         │
1970s   Бурное развитие теории NP-полноты
         │
2002    AKS: PRIMES ∈ P (долго думали, что в NP \ P)
         │
2000    Институт Клэя: P vs NP — задача тысячелетия ($1M)
```

### Ключевые фигуры

- **Стивен Кук** (1971) — ввёл понятие NP и доказал NP-полноту SAT
- **Леонид Левин** (1973) — независимо открыл NP-полноту в СССР
- **Ричард Карп** (1972) — показал NP-полноту 21 задачи

## Практическое значение

### Почему NP важен для практики

```
┌────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ ЗАДАЧИ В NP                      │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ЛОГИСТИКА                                                     │
│  • Маршрутизация транспорта (TSP-подобные)                     │
│  • Расписание производства                                     │
│  • Распределение ресурсов                                      │
│                                                                │
│  БИОИНФОРМАТИКА                                                │
│  • Выравнивание последовательностей                            │
│  • Сворачивание белков                                         │
│  • Филогенетические деревья                                    │
│                                                                │
│  КРИПТОГРАФИЯ                                                  │
│  • Факторизация (RSA основан на сложности)                     │
│  • Дискретный логарифм                                         │
│                                                                │
│  ПЛАНИРОВАНИЕ                                                  │
│  • Расписание экзаменов                                        │
│  • Распределение частот                                        │
│  • Раскраска графов (конфликты ресурсов)                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Что делать, если задача в NP (но не известно, что в P)?

1. **Приближённые алгоритмы** — найти решение, близкое к оптимальному
2. **Эвристики** — генетические алгоритмы, имитация отжига
3. **Параметризованные алгоритмы** — эффективны для малых параметров
4. **SAT-солверы** — современные решатели справляются с огромными экземплярами
5. **Квантовые алгоритмы** — потенциальное ускорение (Гровер)

## Итоги

1. **NP** = задачи с полиномиально проверяемым решением
2. **P ⊆ NP** — всё, что можно быстро решить, можно быстро проверить
3. **NP ≠ "не полиномиальное"** — это распространённое заблуждение
4. **Сертификат** — "подсказка", позволяющая проверить ответ "да"
5. **co-NP** — дополнения NP-задач (отношение с NP неизвестно)
6. **Большинство практических задач** оптимизации лежат в NP
7. **Открытый вопрос**: P = NP? (главный вопрос теоретической информатики)

---
[prev: 02-class-p](./02-class-p.md) | [next: 04-np-complete](./04-np-complete.md)