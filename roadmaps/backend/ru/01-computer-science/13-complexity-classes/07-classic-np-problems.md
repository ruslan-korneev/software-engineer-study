# Классические NP-задачи

[prev: 06-p-vs-np](./06-p-vs-np.md) | [next: 01-avl-trees](../14-advanced-structures/01-avl-trees.md)
---

## Обзор

В этом разделе подробно рассмотрим четыре классические NP-полные задачи:

1. **SAT** (Boolean Satisfiability) — выполнимость булевой формулы
2. **TSP** (Traveling Salesman Problem) — задача коммивояжёра
3. **Knapsack** — задача о рюкзаке
4. **Vertex Cover** — вершинное покрытие

```
┌────────────────────────────────────────────────────────────────┐
│                КЛАССИЧЕСКИЕ NP-ЗАДАЧИ                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   SAT ────────────►  3-SAT ────────────►  CLIQUE               │
│    │                                        │                  │
│    │                                        │                  │
│    ▼                                        ▼                  │
│  CIRCUIT-SAT                          VERTEX COVER             │
│                                             │                  │
│                                             │                  │
│   TSP ◄────────────  HAMPATH ◄─────────────┘                   │
│                                                                │
│   KNAPSACK ◄──────── SUBSET-SUM ◄──────── PARTITION            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 1. SAT (Boolean Satisfiability Problem)

### Определение

**SAT**: Дана булева формула в конъюнктивной нормальной форме (КНФ). Существует ли набор значений переменных, делающий формулу истинной?

```
Формула в КНФ: конъюнкция дизъюнктов
φ = (l₁ ∨ l₂ ∨ ...) ∧ (l₃ ∨ l₄ ∨ ...) ∧ ...

где lᵢ — литерал (переменная xⱼ или её отрицание ¬xⱼ)
```

### Пример

```
Формула: φ = (x₁ ∨ ¬x₂) ∧ (¬x₁ ∨ x₃) ∧ (x₂ ∨ ¬x₃)

Разбор:
• Дизъюнкт 1: (x₁ ∨ ¬x₂) — хотя бы один должен быть true
• Дизъюнкт 2: (¬x₁ ∨ x₃) — хотя бы один должен быть true
• Дизъюнкт 3: (x₂ ∨ ¬x₃) — хотя бы один должен быть true

Выполняющее присваивание: x₁ = true, x₂ = true, x₃ = true
Проверка:
  (T ∨ F) ∧ (F ∨ T) ∧ (T ∨ F) = T ∧ T ∧ T = T ✓
```

### Варианты SAT

```
┌────────────────────────────────────────────────────────────────┐
│                     ВАРИАНТЫ SAT                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  k-SAT: каждый дизъюнкт содержит ровно k литералов             │
│                                                                │
│  • 2-SAT: (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ ...                         │
│    СЛОЖНОСТЬ: P (полиномиальное время!)                        │
│    Алгоритм: граф импликаций + SCC                             │
│                                                                │
│  • 3-SAT: (x₁ ∨ x₂ ∨ x₃) ∧ ...                                 │
│    СЛОЖНОСТЬ: NP-complete                                      │
│    Самая изученная NP-полная задача                            │
│                                                                │
│  • k-SAT (k ≥ 3): NP-complete                                  │
│                                                                │
│  Horn-SAT: все дизъюнкты имеют ≤ 1 положительного литерала     │
│    (¬x₁ ∨ ¬x₂ ∨ x₃) — Horn clause                              │
│    СЛОЖНОСТЬ: P                                                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Теорема Кука-Левина

**SAT — первая NP-полная задача** (1971)

```
Идея доказательства:
1. Любую NP-задачу можно решить верификатором V(x, c)
2. Работу верификатора можно закодировать булевой схемой
3. Схему можно преобразовать в КНФ формулу
4. Формула выполнима ⟺ существует сертификат c

Следствие: если SAT ∈ P, то P = NP
```

### Алгоритмы решения SAT

```python
# DPLL (Davis-Putnam-Logemann-Loveland) — базовый алгоритм
def dpll(clauses, assignment):
    """
    Рекурсивный алгоритм для SAT
    clauses: список дизъюнктов
    assignment: текущее присваивание
    """
    # Упрощаем формулу
    clauses = simplify(clauses, assignment)

    # База: все дизъюнкты выполнены
    if not clauses:
        return True, assignment

    # База: есть пустой дизъюнкт (конфликт)
    if any(len(c) == 0 for c in clauses):
        return False, None

    # Unit propagation: дизъюнкт из одного литерала
    unit_clauses = [c for c in clauses if len(c) == 1]
    for c in unit_clauses:
        literal = c[0]
        var = abs(literal)
        value = literal > 0
        assignment[var] = value
        return dpll(clauses, assignment)

    # Выбираем переменную для ветвления
    var = choose_variable(clauses)

    # Пробуем true
    assignment[var] = True
    result, sol = dpll(clauses, assignment.copy())
    if result:
        return True, sol

    # Пробуем false
    assignment[var] = False
    return dpll(clauses, assignment.copy())
```

### Современные SAT-солверы

```
┌────────────────────────────────────────────────────────────────┐
│              СОВРЕМЕННЫЕ SAT-СОЛВЕРЫ                           │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Техники:                                                      │
│  • CDCL (Conflict-Driven Clause Learning)                      │
│  • VSIDS (Variable State Independent Decaying Sum)             │
│  • Watched Literals                                            │
│  • Restart strategies                                          │
│                                                                │
│  Популярные солверы:                                           │
│  • MiniSat — классика, учебный                                 │
│  • Z3 — от Microsoft, SMT-солвер                               │
│  • CryptoMiniSat — для криптоанализа                           │
│  • Glucose — победитель соревнований                           │
│  • CaDiCaL — современный лидер                                 │
│                                                                │
│  Практика:                                                     │
│  • Решают экземпляры с миллионами переменных                   │
│  • Используются в верификации, AI планировании                 │
│  • SAT как "универсальный решатель"                            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Применения SAT

- Верификация аппаратуры (процессоры, схемы)
- Планирование в AI
- Криптоанализ
- Биоинформатика
- Автоматическое доказательство теорем
- Конфигурация продуктов

---

## 2. TSP (Traveling Salesman Problem)

### Определение

**TSP**: Дан полный взвешенный граф. Найти гамильтонов цикл минимального веса.

```
Версия решения (NP-complete):
  Вход: граф G с весами, число k
  Вопрос: существует ли гамильтонов цикл веса ≤ k?

Версия оптимизации (NP-hard):
  Вход: граф G с весами
  Выход: гамильтонов цикл минимального веса
```

### Пример

```
Города: A, B, C, D
Расстояния:
       A
      /|\
     5 | 10
    /  |  \
   B---+---D
    \  |  /
     8 3 7
      \|/
       C

Матрица расстояний:
     A   B   C   D
A    0   5   3  10
B    5   0   8   7
C    3   8   0   4
D   10   7   4   0

Оптимальный маршрут: A → B → D → C → A
Длина: 5 + 7 + 4 + 3 = 19
```

### Варианты TSP

```
┌────────────────────────────────────────────────────────────────┐
│                     ВАРИАНТЫ TSP                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Metric TSP:                                                   │
│  • Расстояния удовлетворяют неравенству треугольника           │
│  • d(a,c) ≤ d(a,b) + d(b,c)                                    │
│  • Есть 1.5-приближение (Кристофидес)                          │
│                                                                │
│  Euclidean TSP:                                                │
│  • Точки на плоскости, евклидово расстояние                    │
│  • Есть PTAS (схема полиномиального приближения)               │
│                                                                │
│  Asymmetric TSP:                                               │
│  • d(a,b) ≠ d(b,a) возможно                                    │
│  • Сложнее приближать                                          │
│                                                                │
│  TSP с временными окнами:                                      │
│  • Каждый город надо посетить в определённое время             │
│  • Практически важен для логистики                             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Алгоритмы решения

```python
# Точный алгоритм: Хелда-Карпа (динамическое программирование)
# Сложность: O(n² × 2ⁿ)

def tsp_held_karp(dist):
    """
    Алгоритм Хелда-Карпа для TSP
    dist: матрица расстояний n×n
    Возвращает: (минимальная длина, маршрут)
    """
    n = len(dist)
    # dp[mask][i] = минимальная стоимость пути из 0
    # через вершины в mask, заканчивая в i
    INF = float('inf')
    dp = [[INF] * n for _ in range(1 << n)]
    parent = [[None] * n for _ in range(1 << n)]

    dp[1][0] = 0  # Начинаем в вершине 0

    for mask in range(1, 1 << n):
        for last in range(n):
            if not (mask & (1 << last)) or dp[mask][last] == INF:
                continue
            for next_v in range(n):
                if mask & (1 << next_v):
                    continue
                new_mask = mask | (1 << next_v)
                new_cost = dp[mask][last] + dist[last][next_v]
                if new_cost < dp[new_mask][next_v]:
                    dp[new_mask][next_v] = new_cost
                    parent[new_mask][next_v] = last

    # Находим минимальный цикл
    full_mask = (1 << n) - 1
    min_cost = INF
    last_city = -1

    for i in range(1, n):
        cost = dp[full_mask][i] + dist[i][0]
        if cost < min_cost:
            min_cost = cost
            last_city = i

    # Восстанавливаем путь
    path = [0]
    mask = full_mask
    curr = last_city

    while curr is not None:
        path.append(curr)
        next_curr = parent[mask][curr]
        mask ^= (1 << curr)
        curr = next_curr

    path.reverse()
    return min_cost, path
```

### Приближённые алгоритмы

```python
# 2-приближение для Metric TSP (MST-based)
def tsp_mst_approximation(dist):
    """
    Приближённый алгоритм через MST
    Гарантия: результат ≤ 2 × OPT
    Сложность: O(n² log n)
    """
    n = len(dist)

    # 1. Строим MST (алгоритм Прима)
    in_mst = [False] * n
    mst_edges = []
    min_edge = [(float('inf'), -1) for _ in range(n)]
    min_edge[0] = (0, -1)

    for _ in range(n):
        # Находим минимальное ребро
        u = min((v for v in range(n) if not in_mst[v]),
                key=lambda v: min_edge[v][0])
        in_mst[u] = True

        if min_edge[u][1] != -1:
            mst_edges.append((min_edge[u][1], u))

        # Обновляем расстояния
        for v in range(n):
            if not in_mst[v] and dist[u][v] < min_edge[v][0]:
                min_edge[v] = (dist[u][v], u)

    # 2. Удваиваем рёбра MST
    # 3. Находим эйлеров путь
    # 4. Делаем shortcutting

    # Простой обход DFS по MST
    adj = [[] for _ in range(n)]
    for u, v in mst_edges:
        adj[u].append(v)
        adj[v].append(u)

    path = []
    visited = [False] * n

    def dfs(u):
        visited[u] = True
        path.append(u)
        for v in adj[u]:
            if not visited[v]:
                dfs(v)

    dfs(0)
    path.append(0)  # Замыкаем цикл

    return path
```

### Алгоритм Кристофидеса (1.5-приближение)

```
Алгоритм Кристофидеса для Metric TSP:

1. Построить MST графа
2. Найти вершины нечётной степени в MST
3. Построить минимальное паросочетание на этих вершинах
4. Объединить MST и паросочетание (эйлеров граф)
5. Найти эйлеров цикл
6. Сделать shortcutting (убрать повторные вершины)

Гарантия: результат ≤ 1.5 × OPT
Лучшее известное приближение для Metric TSP!
```

### Практическое применение TSP

- Логистика и маршрутизация доставки
- Производство печатных плат (путь сверла)
- Секвенирование ДНК
- Планирование телескопов
- Обслуживание клиентов

---

## 3. Knapsack (Задача о рюкзаке)

### Определение

**Knapsack**: Даны предметы с весами и ценностями, рюкзак с ограничением по весу. Выбрать предметы максимальной суммарной ценности, не превышая лимит веса.

```
Версия решения (NP-complete):
  Вход: n предметов (wᵢ, vᵢ), ёмкость W, целевая ценность V
  Вопрос: можно ли набрать ценность ≥ V при весе ≤ W?

Версия оптимизации (NP-hard):
  Вход: n предметов (wᵢ, vᵢ), ёмкость W
  Выход: максимальная достижимая ценность
```

### Варианты

```
┌────────────────────────────────────────────────────────────────┐
│                   ВАРИАНТЫ РЮКЗАКА                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  0/1 Knapsack:                                                 │
│  • Каждый предмет берём или не берём                           │
│  • Классическая версия, NP-hard                                │
│                                                                │
│  Unbounded Knapsack:                                           │
│  • Каждый предмет можно брать неограниченно                    │
│  • Решается за O(nW)                                           │
│                                                                │
│  Bounded Knapsack:                                             │
│  • Каждый предмет можно брать до kᵢ раз                        │
│  • Сводится к 0/1 Knapsack                                     │
│                                                                │
│  Fractional Knapsack:                                          │
│  • Можно брать часть предмета                                  │
│  • Решается жадно за O(n log n) — в P!                         │
│                                                                │
│  Multi-dimensional Knapsack:                                   │
│  • Несколько ограничений (вес, объём, ...)                     │
│  • Ещё сложнее                                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Пример

```
Рюкзак: ёмкость W = 10

Предметы:
  Предмет | Вес | Ценность | Ценность/Вес
  --------|-----|----------|-------------
     A    |  4  |    5     |    1.25
     B    |  3  |    4     |    1.33
     C    |  5  |    8     |    1.60
     D    |  2  |    3     |    1.50

Оптимальное решение: B + C + D
Вес: 3 + 5 + 2 = 10 ≤ 10 ✓
Ценность: 4 + 8 + 3 = 15

(Жадный по ценности/весу взял бы C, D, B = 15 — в этом случае совпало!)
```

### Алгоритм динамического программирования

```python
# 0/1 Knapsack — псевдополиномиальный алгоритм
# Сложность: O(nW) — полиномиален от W, но W может быть экспоненциален!

def knapsack_01(weights, values, capacity):
    """
    0/1 Knapsack с динамическим программированием
    weights: список весов
    values: список ценностей
    capacity: ёмкость рюкзака
    Возвращает: (максимальная ценность, выбранные предметы)
    """
    n = len(weights)
    # dp[i][w] = макс. ценность из первых i предметов при ёмкости w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Не берём i-й предмет
            dp[i][w] = dp[i-1][w]

            # Берём i-й предмет (если помещается)
            if weights[i-1] <= w:
                take = dp[i-1][w - weights[i-1]] + values[i-1]
                dp[i][w] = max(dp[i][w], take)

    # Восстанавливаем решение
    selected = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            selected.append(i - 1)
            w -= weights[i-1]

    return dp[n][capacity], selected[::-1]


# Пример использования:
weights = [4, 3, 5, 2]
values = [5, 4, 8, 3]
capacity = 10

max_value, items = knapsack_01(weights, values, capacity)
print(f"Максимальная ценность: {max_value}")  # 15
print(f"Выбранные предметы: {items}")  # [1, 2, 3] (B, C, D)
```

### Почему это псевдополиномиальный алгоритм?

```
Сложность O(nW):
• n — количество предметов (полиномиально)
• W — ёмкость рюкзака (может быть экспоненциально большой!)

Размер входа: O(n × log W) — логарифм от W (бинарное представление)

Пример:
• W = 2^64 — всего 64 бита в записи
• Но O(nW) = O(n × 2^64) — экспоненциально!

Вывод: Knapsack слабо NP-полна (weakly NP-complete)
       В отличие от SAT, TSP — сильно NP-полных
```

### Приближённый алгоритм (FPTAS)

```python
# FPTAS для Knapsack — полиномиальный с гарантией (1-ε)
def knapsack_fptas(weights, values, capacity, epsilon):
    """
    FPTAS: Fully Polynomial Time Approximation Scheme
    Гарантия: результат ≥ (1 - ε) × OPT
    Сложность: O(n³/ε)
    """
    n = len(weights)
    v_max = max(values)

    # Масштабируем ценности
    K = epsilon * v_max / n
    scaled_values = [int(v / K) for v in values]

    # Решаем с масштабированными ценностями
    max_scaled = sum(scaled_values)

    # dp[v] = минимальный вес для достижения ценности v
    INF = float('inf')
    dp = [INF] * (max_scaled + 1)
    dp[0] = 0

    for i in range(n):
        # Обходим в обратном порядке (0/1 knapsack)
        for v in range(max_scaled, scaled_values[i] - 1, -1):
            if dp[v - scaled_values[i]] + weights[i] <= capacity:
                dp[v] = min(dp[v], dp[v - scaled_values[i]] + weights[i])

    # Находим максимальную достижимую ценность
    for v in range(max_scaled, -1, -1):
        if dp[v] <= capacity:
            return v * K  # Возвращаем в исходном масштабе

    return 0
```

### Практическое применение

- Распределение бюджета (проекты)
- Загрузка грузовиков
- Распределение ресурсов
- Криптография (subset sum problem)
- Биоинформатика (выбор препаратов)

---

## 4. Vertex Cover (Вершинное покрытие)

### Определение

**Vertex Cover**: Дан граф. Найти минимальное множество вершин, покрывающее все рёбра.

```
Версия решения (NP-complete):
  Вход: граф G = (V, E), число k
  Вопрос: существует ли вершинное покрытие размера ≤ k?

Версия оптимизации (NP-hard):
  Вход: граф G = (V, E)
  Выход: минимальное вершинное покрытие
```

### Пример

```
Граф:
    A ─── B ─── C
    │     │     │
    D ─── E ─── F

Рёбра: {AB, BC, AD, BE, CF, DE, EF}

Вершинное покрытие: {B, D, F} или {B, E, C} или {A, B, E, F} ...

Минимальное покрытие: {B, D, F} — размер 3

Проверка:
• AB: покрыто B ✓
• BC: покрыто B ✓
• AD: покрыто D ✓
• BE: покрыто B ✓
• CF: покрыто F ✓
• DE: покрыто D ✓
• EF: покрыто F ✓
```

### Связь с другими задачами

```
┌────────────────────────────────────────────────────────────────┐
│           СВЯЗЬ VERTEX COVER С ДРУГИМИ ЗАДАЧАМИ                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  INDEPENDENT SET (независимое множество):                      │
│  S — vertex cover ⟺ V \ S — independent set                    │
│                                                                │
│  Пример:                                                       │
│  V = {A, B, C, D, E, F}                                        │
│  Vertex Cover: {B, D, F}                                       │
│  Independent Set: {A, C, E} (никакие два не соединены)         │
│                                                                │
│  CLIQUE (в дополнении графа):                                  │
│  S — independent set в G ⟺ S — clique в Ḡ                      │
│                                                                │
│  DOMINATING SET:                                               │
│  Vertex cover покрывает рёбра                                  │
│  Dominating set покрывает вершины (включая соседей)            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 2-приближённый алгоритм

```python
# Жадный 2-приближённый алгоритм
def vertex_cover_2approx(graph):
    """
    2-приближение для Vertex Cover
    Гарантия: |S| ≤ 2 × OPT
    Сложность: O(V + E)

    graph: словарь {вершина: множество соседей}
    """
    cover = set()
    edges = set()

    # Собираем все рёбра
    for u in graph:
        for v in graph[u]:
            if u < v:  # Избегаем дубликатов
                edges.add((u, v))

    # Жадно выбираем рёбра
    remaining_edges = edges.copy()

    while remaining_edges:
        # Берём любое ребро
        u, v = remaining_edges.pop()

        # Добавляем обе вершины в покрытие
        cover.add(u)
        cover.add(v)

        # Удаляем все рёбра, инцидентные u или v
        remaining_edges = {
            (a, b) for (a, b) in remaining_edges
            if a not in {u, v} and b not in {u, v}
        }

    return cover


# Пример:
graph = {
    'A': {'B', 'D'},
    'B': {'A', 'C', 'E'},
    'C': {'B', 'F'},
    'D': {'A', 'E'},
    'E': {'B', 'D', 'F'},
    'F': {'C', 'E'}
}

cover = vertex_cover_2approx(graph)
print(f"Вершинное покрытие: {cover}")
# Возможный результат: {'A', 'B', 'D', 'E', 'C', 'F'} или меньше
```

### Почему это 2-приближение?

```
Доказательство:

1. Алгоритм выбирает непересекающиеся рёбра (matching)
2. Каждое выбранное ребро добавляет 2 вершины в покрытие
3. Оптимальное покрытие должно содержать хотя бы одну
   вершину от каждого выбранного ребра

Если алгоритм выбрал k рёбер:
• |S| = 2k (наше покрытие)
• OPT ≥ k (оптимум покрывает k рёбер)

Следовательно: |S| ≤ 2 × OPT ∎
```

### Параметризованный алгоритм (FPT)

```python
# FPT алгоритм для Vertex Cover
# Сложность: O(2^k × n) вместо O(n^k)

def vertex_cover_fpt(graph, k):
    """
    FPT алгоритм: существует ли покрытие размера k?
    graph: словарь {вершина: множество соседей}
    k: размер покрытия
    """
    if k < 0:
        return False, None

    # Находим любое ребро
    edge = None
    for u in graph:
        for v in graph[u]:
            edge = (u, v)
            break
        if edge:
            break

    # Если рёбер нет — решение найдено
    if edge is None:
        return True, set()

    u, v = edge

    # Ветвление: берём u или v
    # Вариант 1: берём u
    graph_minus_u = remove_vertex(graph, u)
    found, cover = vertex_cover_fpt(graph_minus_u, k - 1)
    if found:
        cover.add(u)
        return True, cover

    # Вариант 2: берём v
    graph_minus_v = remove_vertex(graph, v)
    found, cover = vertex_cover_fpt(graph_minus_v, k - 1)
    if found:
        cover.add(v)
        return True, cover

    return False, None


def remove_vertex(graph, v):
    """Удаляет вершину и все инцидентные рёбра"""
    new_graph = {}
    for u in graph:
        if u != v:
            new_graph[u] = graph[u] - {v}
    return new_graph
```

### Практическое применение

- Мониторинг сетей (минимальное число сенсоров)
- Биоинформатика (регуляторные сети)
- Оптимизация баз данных (выбор индексов)
- Социальные сети (влиятельные узлы)
- Распределённые системы (выбор узлов репликации)

---

## Сравнительная таблица

| Задача | Тип | Сложность решения | Лучшее приближение | Применение |
|--------|-----|-------------------|-------------------|------------|
| SAT | Логическая | O(2ⁿ) | — | Верификация, AI |
| 3-SAT | Логическая | O(1.307ⁿ) | — | Криптоанализ |
| TSP | Графовая | O(n² × 2ⁿ) | 1.5 (metric) | Логистика |
| Knapsack | Числовая | O(nW) | FPTAS | Распределение |
| Vertex Cover | Графовая | O(2^k × n) | 2 | Сети |

## Итоги

1. **SAT** — фундаментальная NP-полная задача, "мать" всех NP-задач
2. **TSP** — классическая задача оптимизации маршрутов
3. **Knapsack** — слабо NP-полная, есть псевдополиномиальный алгоритм
4. **Vertex Cover** — есть простое 2-приближение и FPT алгоритм
5. Для каждой задачи существуют **практические методы**:
   - SAT-солверы для SAT
   - Метаэвристики для TSP
   - Динамическое программирование для Knapsack
   - Жадные алгоритмы для Vertex Cover
6. Выбор метода зависит от размера входа и требуемой точности

---
[prev: 06-p-vs-np](./06-p-vs-np.md) | [next: 01-avl-trees](../14-advanced-structures/01-avl-trees.md)