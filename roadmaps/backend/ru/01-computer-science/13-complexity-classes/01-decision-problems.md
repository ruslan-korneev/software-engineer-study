# Задачи принятия решений (Decision Problems)

[prev: 04-classic-problems](../12-algorithms/08-dynamic-programming/04-classic-problems.md) | [next: 02-class-p](./02-class-p.md)
---

## Определение

### Формальное определение

**Задача принятия решений** (decision problem) — это вычислительная задача, ответом на которую является "да" или "нет" (булево значение).

Формально: задача принятия решений — это функция вида:

```
f: Σ* → {0, 1}
```

где `Σ*` — множество всех строк над алфавитом `Σ`, а результат — 0 (нет) или 1 (да).

### Интуитивное объяснение

Представьте любой вопрос, на который можно ответить только "да" или "нет":
- "Является ли число 17 простым?" → Да
- "Содержит ли граф цикл?" → Да/Нет
- "Можно ли раскрасить карту тремя цветами?" → Да/Нет

Задачи принятия решений — это фундаментальный способ классификации вычислительных проблем в теории сложности.

## Зачем нужно

### Практическое значение

1. **Упрощение анализа сложности**: Любую оптимизационную задачу можно свести к задаче принятия решений
2. **Классификация задач**: Классы P, NP, NP-полные определяются через задачи принятия решений
3. **Сводимость задач**: Легче доказывать эквивалентность задач

### Связь с оптимизационными задачами

| Оптимизационная задача | Эквивалентная задача принятия решений |
|------------------------|---------------------------------------|
| Найти кратчайший путь | Существует ли путь длины ≤ k? |
| Найти минимальное покрытие | Существует ли покрытие размера ≤ k? |
| Найти оптимальную раскраску | Можно ли раскрасить в k цветов? |

## Как работает

### Структура задачи принятия решений

```
┌─────────────────────────────────────────────────┐
│              ЗАДАЧА ПРИНЯТИЯ РЕШЕНИЙ            │
├─────────────────────────────────────────────────┤
│  Вход: экземпляр задачи (входные данные)        │
│                                                 │
│  Вопрос: формулировка вопроса                   │
│                                                 │
│  Выход: "да" или "нет"                          │
└─────────────────────────────────────────────────┘
```

### Примеры задач принятия решений

#### 1. Задача о простом числе (PRIMES)

```
PRIMES:
  Вход: натуральное число n
  Вопрос: является ли n простым числом?

Примеры:
  n = 17 → Да (делится только на 1 и 17)
  n = 15 → Нет (делится на 3 и 5)
```

#### 2. Задача о связности графа (CONNECTIVITY)

```
CONNECTIVITY:
  Вход: граф G = (V, E) и вершины s, t
  Вопрос: существует ли путь из s в t?

Пример:
  A --- B --- C
  |           |
  D-----------E

  Путь из A в E? → Да (A → B → C → E или A → D → E)
```

#### 3. Задача выполнимости (SAT)

```
SAT (Boolean Satisfiability):
  Вход: булева формула φ
  Вопрос: существует ли набор значений переменных,
          при котором φ = true?

Пример:
  φ = (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)

  При x₁ = true, x₂ = false, x₃ = true:
  φ = (T ∨ F) ∧ (F ∨ T) ∧ (T ∨ F) = T ∧ T ∧ T = T

  Ответ: Да (формула выполнима)
```

### Язык задачи

Каждая задача принятия решений определяет **язык** L — множество всех входов, для которых ответ "да":

```
L = { x ∈ Σ* | f(x) = 1 }

Примеры:
  L_PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, ...}
  L_EVEN = {0, 2, 4, 6, 8, 10, ...}
  L_CONNECTED = {все связные графы}
```

## Диаграмма типов задач

```
                    ┌──────────────────────────────┐
                    │     ВЫЧИСЛИТЕЛЬНЫЕ ЗАДАЧИ    │
                    └──────────────────────────────┘
                                  │
           ┌──────────────────────┼──────────────────────┐
           │                      │                      │
           ▼                      ▼                      ▼
    ┌─────────────┐      ┌───────────────┐      ┌─────────────┐
    │   ЗАДАЧИ    │      │    ЗАДАЧИ     │      │   ЗАДАЧИ    │
    │   ПОИСКА    │      │ ОПТИМИЗАЦИИ   │      │   РЕШЕНИЙ   │
    └─────────────┘      └───────────────┘      └─────────────┘
    "Найти путь"         "Найти кратчайший"     "Существует ли
                               путь"               путь ≤ k?"
           │                      │                      │
           └──────────────────────┼──────────────────────┘
                                  │
                    ┌─────────────▼─────────────┐
                    │  Можно свести к задаче    │
                    │    принятия решений       │
                    └───────────────────────────┘
```

## Примеры из разных областей

### Теория графов

| Задача | Вход | Вопрос |
|--------|------|--------|
| CLIQUE | Граф G, число k | Есть ли клика размера k? |
| HAMPATH | Граф G | Есть ли гамильтонов путь? |
| COLORING | Граф G, число k | Можно ли раскрасить в k цветов? |
| EULERIAN | Граф G | Существует ли эйлеров путь? |

### Арифметика

| Задача | Вход | Вопрос |
|--------|------|--------|
| PRIMES | Число n | Простое ли n? |
| COMPOSITE | Число n | Составное ли n? |
| DIVISIBILITY | Числа a, b | Делится ли a на b? |

### Строки

| Задача | Вход | Вопрос |
|--------|------|--------|
| MEMBERSHIP | Строка s, язык L | Принадлежит ли s языку L? |
| PALINDROME | Строка s | Является ли s палиндромом? |
| SUBSTRING | Строки s, t | Является ли t подстрокой s? |

## Исторический контекст

### Хронология развития

```
1900    Давид Гильберт: проблема разрешимости (Entscheidungsproblem)
         │
1936    Алан Тьюринг: машина Тьюринга, проблема остановки
         │ Алонзо Чёрч: лямбда-исчисление
         │
1965    Джек Эдмондс: формализация понятия "эффективного алгоритма"
         │
1971    Стивен Кук: теорема Кука-Левина, NP-полнота SAT
         │
1972    Ричард Карп: 21 NP-полная задача
         │
2002    AKS-алгоритм: PRIMES ∈ P (доказано за полиномиальное время)
```

### Ключевые моменты

1. **Entscheidungsproblem (1900)** — Гильберт спросил: "Можно ли алгоритмически решить любую математическую задачу?"

2. **Ответ Тьюринга (1936)** — Нет! Существуют неразрешимые задачи (проблема остановки)

3. **Современная теория сложности** — Фокус сместился с разрешимости на эффективность: какие задачи можно решить быстро?

## Связь с классами сложности

```
┌─────────────────────────────────────────────────────────┐
│                    ЗАДАЧИ ПРИНЯТИЯ РЕШЕНИЙ              │
│                                                         │
│    ┌───────────────────────────────────────────┐        │
│    │                    NP                     │        │
│    │    ┌─────────────────────────────┐        │        │
│    │    │            P                │        │        │
│    │    │   PRIMES, CONNECTIVITY,     │        │        │
│    │    │   EULERIAN, 2-SAT           │        │        │
│    │    └─────────────────────────────┘        │        │
│    │                                           │        │
│    │    SAT, CLIQUE, HAMPATH (NP-полные)       │        │
│    └───────────────────────────────────────────┘        │
│                                                         │
│    Неразрешимые: HALTING PROBLEM, POST                  │
└─────────────────────────────────────────────────────────┘
```

## Практическое применение

### Преобразование оптимизационной задачи в задачу решения

```python
# Оптимизационная задача: найти кратчайший путь
def shortest_path(graph, s, t):
    """Возвращает длину кратчайшего пути"""
    pass

# Задача принятия решений: существует ли путь длины ≤ k?
def path_exists_with_length_k(graph, s, t, k):
    """Возвращает True/False"""
    return shortest_path(graph, s, t) <= k

# Восстановление оптимального значения через бинарный поиск
def find_optimal_via_decision(graph, s, t):
    left, right = 0, n  # n = количество вершин
    while left < right:
        mid = (left + right) // 2
        if path_exists_with_length_k(graph, s, t, mid):
            right = mid
        else:
            left = mid + 1
    return left
```

## Итоги

1. **Задачи принятия решений** — базовый инструмент теории сложности
2. Любая оптимизационная задача сводится к задаче принятия решений
3. Классы P, NP, NP-полные определяются через задачи принятия решений
4. Язык задачи L — множество "положительных" входов
5. Изучение задач принятия решений позволяет классифицировать вычислительную сложность

---
[prev: 04-classic-problems](../12-algorithms/08-dynamic-programming/04-classic-problems.md) | [next: 02-class-p](./02-class-p.md)