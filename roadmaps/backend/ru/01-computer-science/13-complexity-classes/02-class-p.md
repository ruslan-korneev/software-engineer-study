# Класс P (Polynomial Time)

[prev: 01-decision-problems](./01-decision-problems.md) | [next: 03-class-np](./03-class-np.md)
---

## Определение

### Формальное определение

**Класс P** — это множество всех задач принятия решений, которые могут быть решены детерминированной машиной Тьюринга за полиномиальное время.

```
P = { L | существует детерминированная машина Тьюринга M,
          которая решает L за время O(n^k) для некоторого k }
```

где n — длина входа.

### Интуитивное объяснение

Класс P — это "быстро решаемые задачи". Если задача принадлежит P, то для неё существует эффективный алгоритм.

Полиномиальное время означает, что время работы ограничено функцией вида:
- O(n), O(n²), O(n³), O(n¹⁰⁰) — полиномиальное
- O(2ⁿ), O(n!), O(nⁿ) — экспоненциальное (НЕ полиномиальное)

```
┌──────────────────────────────────────────────────────────┐
│               СРАВНЕНИЕ ВРЕМЕНИ РАБОТЫ                   │
├────────────────────────────────────────────────────────┤
│  n = 100                                                 │
│                                                          │
│  O(n)       = 100                                        │
│  O(n²)      = 10,000                                     │
│  O(n³)      = 1,000,000                                  │
│  O(2ⁿ)      = 1.27 × 10³⁰  (больше атомов во Вселенной!) │
│  O(n!)      = 9.3 × 10¹⁵⁷                                │
└──────────────────────────────────────────────────────────┘
```

## Зачем нужно

### Практическое значение

1. **Критерий эффективности**: P — формальное определение "эффективно решаемых" задач
2. **Граница между лёгким и трудным**: P отделяет практически решаемые задачи
3. **Цель алгоритмистов**: доказать, что задача ∈ P — значит найти эффективный алгоритм
4. **Криптография**: безопасность основана на том, что определённые задачи ∉ P

### Тезис Кобэма-Эдмондса

> "Полиномиальное время — это математическая модель практически решаемых задач"

Хотя O(n¹⁰⁰) формально полиномиально, на практике большинство задач в P имеют алгоритмы O(n), O(n log n), O(n²), O(n³).

## Как работает

### Детерминированная машина Тьюринга

Класс P определяется через детерминированную машину Тьюринга (ДМТ):

```
┌─────────────────────────────────────────────────────────┐
│             ДЕТЕРМИНИРОВАННАЯ МАШИНА ТЬЮРИНГА           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Лента: ... □ a b c d e f □ ...                         │
│                  ↑                                      │
│              Головка                                    │
│                                                         │
│  Управляющее устройство:                                │
│    Состояние: q₅                                        │
│    Переход: δ(q₅, 'c') = (q₇, 'd', →)                   │
│             ↓                                           │
│    • Перейти в состояние q₇                             │
│    • Записать 'd' на ленту                              │
│    • Сдвинуться вправо                                  │
│                                                         │
│  ДЕТЕРМИНИЗМ: в каждый момент ровно один                │
│  возможный следующий шаг!                               │
└─────────────────────────────────────────────────────────┘
```

### Полиномиальное время

Машина M решает задачу L за полиномиальное время, если:
- Для любого входа x машина останавливается за O(|x|^k) шагов
- Если x ∈ L, машина отвечает "да"
- Если x ∉ L, машина отвечает "нет"

## Примеры задач из класса P

### 1. Поиск в отсортированном массиве — O(log n)

```python
def binary_search(arr, target):
    """
    Бинарный поиск: O(log n)
    Задача: есть ли target в отсортированном массиве?
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return True   # Да, элемент найден
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return False  # Нет, элемент не найден

# Пример:
# arr = [1, 3, 5, 7, 9, 11, 13]
# binary_search(arr, 7) → True
# binary_search(arr, 6) → False
```

### 2. Связность графа — O(V + E)

```python
from collections import deque

def is_connected(graph, start, end):
    """
    BFS для проверки связности: O(V + E)
    Задача: существует ли путь из start в end?
    """
    if start == end:
        return True

    visited = set([start])
    queue = deque([start])

    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor == end:
                return True  # Да, путь существует
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return False  # Нет, пути не существует

# Пример:
# graph = {
#     'A': ['B', 'C'],
#     'B': ['A', 'D'],
#     'C': ['A', 'D'],
#     'D': ['B', 'C']
# }
# is_connected(graph, 'A', 'D') → True
```

### 3. Проверка на простоту (AKS) — O(log^6 n)

```python
def is_prime_naive(n):
    """
    Наивная проверка простоты: O(√n)
    Примечание: AKS-алгоритм работает за O(log^6 n),
    что полиномиально от длины числа!
    """
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False

    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False  # Нет, составное

    return True  # Да, простое

# Пример:
# is_prime_naive(17) → True
# is_prime_naive(15) → False
```

### 4. Задача 2-SAT — O(V + E)

```
2-SAT (2-выполнимость):
Вход: булева формула в КНФ, где каждый дизъюнкт содержит ≤ 2 литерала
Вопрос: выполнима ли формула?

Пример:
φ = (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)

Алгоритм: построение графа импликаций + SCC (компоненты сильной связности)
Сложность: O(n + m), где n — переменные, m — дизъюнкты

ВАЖНО: 2-SAT ∈ P, но 3-SAT ∈ NP-complete!
```

### 5. Эйлеров путь — O(E)

```python
def has_eulerian_path(graph):
    """
    Проверка существования эйлерова пути: O(V + E)
    Эйлеров путь существует ⟺ граф связен и
    количество вершин нечётной степени ≤ 2
    """
    # Считаем степени вершин
    odd_degree_count = 0
    for node in graph:
        if len(graph[node]) % 2 == 1:
            odd_degree_count += 1

    # Должно быть 0 или 2 вершины нечётной степени
    return odd_degree_count in [0, 2]

# Кёнигсбергские мосты:
# 4 вершины нечётной степени → эйлеров путь НЕ существует
```

## Диаграмма классов сложности

```
┌─────────────────────────────────────────────────────────────────┐
│                        ВСЕ ЗАДАЧИ                               │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                        NP                               │   │
│   │                                                         │   │
│   │   ┌─────────────────────────────────────────────────┐   │   │
│   │   │                     P                           │   │   │
│   │   │                                                 │   │   │
│   │   │   • Сортировка          O(n log n)              │   │   │
│   │   │   • Поиск               O(log n)                │   │   │
│   │   │   • Связность           O(V + E)                │   │   │
│   │   │   • Кратчайший путь     O(V²) или O(E log V)    │   │   │
│   │   │   • Простота числа      O(log^6 n)              │   │   │
│   │   │   • 2-SAT               O(n + m)                │   │   │
│   │   │   • Эйлеров путь        O(E)                    │   │   │
│   │   │   • Сопоставление       O(V × E)                │   │   │
│   │   │                                                 │   │   │
│   │   └─────────────────────────────────────────────────┘   │   │
│   │                                                         │   │
│   │   SAT, CLIQUE, HAMPATH, TSP (NP, но возможно не в P)    │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   EXPTIME, неразрешимые задачи                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Таблица задач из P

| Задача | Сложность | Алгоритм |
|--------|-----------|----------|
| Сортировка | O(n log n) | Merge Sort, Quick Sort |
| Поиск в массиве | O(log n) | Бинарный поиск |
| Кратчайший путь | O(V²) или O(E log V) | Дейкстра |
| Минимальное остовное дерево | O(E log V) | Крускал, Прим |
| Максимальный поток | O(V × E²) | Эдмондс-Карп |
| Проверка простоты | O(log⁶ n) | AKS |
| 2-SAT | O(n + m) | Kosaraju SCC |
| Линейное программирование | Полиномиальное | Эллипсоид, внутренняя точка |
| Паросочетание в двудольном графе | O(V × E) | Хопкрофт-Карп |

## Исторический контекст

### Хронология

```
1936    Тьюринг определяет машину Тьюринга
         │
1960s   Начало исследований вычислительной сложности
         │
1965    Джек Эдмондс вводит понятие "хорошего алгоритма"
         │       (полиномиальное время)
         │
1971    Стивен Кук определяет классы P и NP
         │
1972    Карп показывает 21 NP-полную задачу
         │
1979    Хачиян: линейное программирование ∈ P (метод эллипсоидов)
         │
2002    AKS: проверка простоты ∈ P
```

### Важные открытия о P

1. **Линейное программирование (1979)**: Хачиян доказал LP ∈ P
2. **Простота чисел (2002)**: Агравал, Каял, Саксена — PRIMES ∈ P
3. **Паросочетания (1965)**: Алгоритм Эдмондса для общих графов

## Свойства класса P

### Замкнутость относительно операций

```
Если L₁ ∈ P и L₂ ∈ P, то:

• L₁ ∪ L₂ ∈ P      (объединение)
• L₁ ∩ L₂ ∈ P      (пересечение)
• L̄₁ ∈ P           (дополнение)
• L₁ · L₂ ∈ P      (конкатенация)
• L₁* ∈ P          (замыкание Клини)
```

### P = co-P

Важное свойство: класс P замкнут относительно дополнения.

```
Если L ∈ P, то L̄ ∈ P (дополнение тоже в P)

Пример:
• PRIMES ∈ P (проверка "n простое?")
• COMPOSITE ∈ P (проверка "n составное?")
  Просто инвертируем ответ!
```

Это НЕ очевидно для NP: мы не знаем, равны ли NP и co-NP!

## Практическое применение

### Как доказать, что задача ∈ P

1. **Прямой метод**: разработать полиномиальный алгоритм
2. **Сведение**: показать, что задача сводится к известной задаче из P за полиномиальное время

```python
# Пример: задача "является ли граф деревом"
# Сводится к двум задачам из P:

def is_tree(graph, n):
    """
    Граф — дерево ⟺ граф связен И имеет n-1 рёбер
    Обе проверки: O(V + E)
    """
    # Проверка 1: количество рёбер
    edge_count = sum(len(graph[v]) for v in graph) // 2
    if edge_count != n - 1:
        return False

    # Проверка 2: связность (BFS/DFS)
    visited = set()
    stack = [list(graph.keys())[0]]
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(graph[node])

    return len(visited) == n
```

## Итоги

1. **Класс P** = задачи, решаемые за полиномиальное время
2. P — формализация понятия "эффективно решаемая задача"
3. Определяется через детерминированную машину Тьюринга
4. P замкнут относительно дополнения: P = co-P
5. Большинство "повседневных" алгоритмических задач лежат в P
6. Открытый вопрос: P = NP? (проблема тысячелетия)

---
[prev: 01-decision-problems](./01-decision-problems.md) | [next: 03-class-np](./03-class-np.md)