# Статические массивы (Static Arrays)

[prev: 06-space-complexity](../../10-asymptotic-notation/06-space-complexity.md) | [next: 02-dynamic-arrays](./02-dynamic-arrays.md)

---
## Определение

**Статический массив** — это структура данных фиксированного размера, которая хранит элементы одного типа в последовательных (смежных) ячейках памяти. Размер массива определяется при создании и не может быть изменён во время выполнения программы.

## Зачем нужно

### Практическое применение:
- **Хранение фиксированных наборов данных** — дни недели, месяцы, коды ошибок
- **Буферы фиксированного размера** — обработка пакетов данных известного размера
- **Матрицы и таблицы** — математические вычисления, игровые поля
- **Lookup-таблицы** — кэширование вычисленных значений (например, таблица синусов)
- **Низкоуровневое программирование** — работа с hardware, embedded-системы

## Как работает

### Структура в памяти

```
Адрес:    1000    1004    1008    1012    1016
        ┌───────┬───────┬───────┬───────┬───────┐
Данные: │  10   │  20   │  30   │  40   │  50   │
        └───────┴───────┴───────┴───────┴───────┘
Индекс:    [0]     [1]     [2]     [3]     [4]

Базовый адрес = 1000
Размер элемента = 4 байта (int)

Формула вычисления адреса:
address[i] = base_address + i × element_size
address[2] = 1000 + 2 × 4 = 1008
```

### Ключевые свойства:
1. **Непрерывность памяти** — все элементы хранятся рядом
2. **Прямой доступ по индексу** — O(1) благодаря арифметике указателей
3. **Фиксированный размер** — определяется при компиляции или создании
4. **Однородность типов** — все элементы одного типа и размера

## Псевдокод основных операций

### Создание массива
```python
# Статическое выделение (размер известен на этапе компиляции)
function CREATE_STATIC_ARRAY(size):
    array = allocate_memory(size × element_size)
    return array

# Пример на C: int arr[5];
# Пример на Python: arr = [0] * 5  # имитация
```

### Доступ к элементу (Get)
```python
function GET(array, index):
    if index < 0 OR index >= array.length:
        raise IndexOutOfBoundsError

    address = base_address + index × element_size
    return memory[address]
```

### Изменение элемента (Set)
```python
function SET(array, index, value):
    if index < 0 OR index >= array.length:
        raise IndexOutOfBoundsError

    address = base_address + index × element_size
    memory[address] = value
```

### Поиск элемента (Linear Search)
```python
function FIND(array, target):
    for i from 0 to array.length - 1:
        if array[i] == target:
            return i
    return -1  # не найден
```

### Обход массива
```python
function TRAVERSE(array):
    for i from 0 to array.length - 1:
        process(array[i])
```

## Анализ сложности

| Операция | Время | Пояснение |
|----------|-------|-----------|
| Доступ по индексу | O(1) | Прямое вычисление адреса |
| Изменение элемента | O(1) | Прямое вычисление адреса |
| Поиск (линейный) | O(n) | Перебор всех элементов |
| Поиск (бинарный)* | O(log n) | *Только для отсортированного массива |
| Вставка в середину | O(n) | Нужно сдвигать элементы |
| Удаление из середины | O(n) | Нужно сдвигать элементы |

### Память
- **Пространственная сложность**: O(n)
- **Накладные расходы**: минимальны (только метаданные размера)

## Примеры с разбором

### Пример 1: Таблица квадратов
```python
# Предвычисленная таблица для быстрого получения квадратов чисел 0-9
squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Получение квадрата числа 7
result = squares[7]  # O(1), результат = 49

# Без таблицы: result = 7 * 7  # тоже O(1), но для сложных функций таблица быстрее
```

### Пример 2: Подсчёт частоты символов
```python
# ASCII-символы: 256 возможных значений
frequency = [0] * 256  # статический массив счётчиков

text = "hello"
for char in text:
    index = ord(char)  # ASCII-код символа
    frequency[index] += 1

# frequency[104] = 1  # 'h'
# frequency[101] = 1  # 'e'
# frequency[108] = 2  # 'l'
# frequency[111] = 1  # 'o'
```

### Пример 3: Игровое поле (2D массив)
```python
# Крестики-нолики: 3x3 поле
board = [
    [' ', ' ', ' '],
    [' ', ' ', ' '],
    [' ', ' ', ' ']
]

# Ход игрока X в центр
board[1][1] = 'X'

#  Визуализация:
#  [' ']['X'][' ']
#  [' '][' '][' ']
#  [' '][' '][' ']
```

### Пример 4: Кольцевой буфер (Ring Buffer)
```python
BUFFER_SIZE = 5
buffer = [None] * BUFFER_SIZE
head = 0  # индекс для записи
tail = 0  # индекс для чтения

def write(value):
    global head
    buffer[head] = value
    head = (head + 1) % BUFFER_SIZE

def read():
    global tail
    value = buffer[tail]
    tail = (tail + 1) % BUFFER_SIZE
    return value

# Используется в: сетевые буферы, аудиообработка, логирование
```

## Типичные ошибки

### 1. Выход за границы массива (Buffer Overflow)
```python
# НЕПРАВИЛЬНО
arr = [1, 2, 3, 4, 5]
value = arr[5]  # IndexError! Индексы: 0-4

# ПРАВИЛЬНО
if index < len(arr):
    value = arr[index]
```

### 2. Off-by-one ошибки
```python
arr = [10, 20, 30, 40, 50]

# НЕПРАВИЛЬНО
for i in range(1, len(arr)):  # пропустили arr[0]
    print(arr[i])

# НЕПРАВИЛЬНО
for i in range(len(arr) + 1):  # IndexError на последней итерации
    print(arr[i])

# ПРАВИЛЬНО
for i in range(len(arr)):  # i от 0 до len-1
    print(arr[i])
```

### 3. Неинициализированные значения
```c
// В C/C++ статический массив может содержать "мусор"
int arr[5];  // значения неопределены!
printf("%d", arr[0]);  // непредсказуемый результат

// ПРАВИЛЬНО
int arr[5] = {0};  // инициализация нулями
```

### 4. Путаница с размером и последним индексом
```python
arr = [1, 2, 3, 4, 5]
size = len(arr)       # size = 5
last_index = size - 1  # last_index = 4

# НЕПРАВИЛЬНО: доступ к arr[size]
# ПРАВИЛЬНО: доступ к arr[size - 1] или arr[last_index]
```

### 5. Модификация массива во время итерации
```python
arr = [1, 2, 3, 4, 5]

# НЕПРАВИЛЬНО (непредсказуемое поведение)
for i in range(len(arr)):
    if arr[i] % 2 == 0:
        arr.pop(i)  # изменяет индексы!

# ПРАВИЛЬНО: итерация в обратном порядке или новый массив
result = [x for x in arr if x % 2 != 0]
```

## Сравнение с динамическими массивами

| Аспект | Статический | Динамический |
|--------|-------------|--------------|
| Размер | Фиксированный | Изменяемый |
| Память | Выделяется сразу | Растёт по необходимости |
| Накладные расходы | Минимальные | Есть (амортизация) |
| Безопасность | Предсказуемое поведение | Может быть reallocation |
| Применение | Embedded, буферы | Общего назначения |

---

[prev: 06-space-complexity](../../10-asymptotic-notation/06-space-complexity.md) | [next: 02-dynamic-arrays](./02-dynamic-arrays.md)
