# Сравнение алгоритмов сортировки

[prev: 06-heap-sort](./06-heap-sort.md) | [next: 01-preorder](../04-tree-traversals/01-preorder.md)
---

## Обзор

Выбор алгоритма сортировки зависит от множества факторов: размер данных, их начальное состояние, ограничения памяти, требования к стабильности и производительности.

## Сводная таблица сложности

| Алгоритм | Лучший | Средний | Худший | Память | Стабильность |
|----------|--------|---------|--------|--------|--------------|
| **Bubble Sort** | O(n) | O(n^2) | O(n^2) | O(1) | Да |
| **Selection Sort** | O(n^2) | O(n^2) | O(n^2) | O(1) | Нет |
| **Insertion Sort** | O(n) | O(n^2) | O(n^2) | O(1) | Да |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | Да |
| **Quick Sort** | O(n log n) | O(n log n) | O(n^2) | O(log n) | Нет |
| **Heap Sort** | O(n log n) | O(n log n) | O(n log n) | O(1) | Нет |

## Детальное сравнение

### Визуализация роста сложности

```
Количество операций при n элементах:

n        O(n)    O(n log n)   O(n^2)      O(2^n)
─────────────────────────────────────────────────
10       10      33           100         1,024
100      100     664          10,000      1.27×10^30
1000     1000    9,966        1,000,000   ∞
10000    10000   132,877      100,000,000 ∞

Графически:

     ^
     │                              O(n^2)
     │                           ╱
     │                        ╱
     │                     ╱
     │                  ╱
     │               ╱────── O(n log n)
     │            ╱──────────────
     │         ╱
     │      ╱────────────────────── O(n)
     │   ╱──────────────────────────
     └────────────────────────────────────────>
                                            n
```

## Когда использовать какой алгоритм

### Bubble Sort

```
✅ Использовать:
- Образовательные цели
- Проверка отсортированности (один проход)
- Очень маленькие массивы (n < 10)
- Почти отсортированные данные (с оптимизацией)

❌ Не использовать:
- Любые production сценарии
- Большие массивы
- Случайные данные
```

### Selection Sort

```
✅ Использовать:
- Когда количество записей важнее количества сравнений
- Запись в медленную память (flash)
- Образовательные цели

❌ Не использовать:
- Требуется стабильность
- Большие массивы
- Почти отсортированные данные
```

### Insertion Sort

```
✅ Использовать:
- Почти отсортированные данные — O(n)
- Маленькие массивы (n < 50)
- Онлайн-сортировка (поток данных)
- Как часть гибридных алгоритмов

❌ Не использовать:
- Случайные большие массивы
- Обратно отсортированные данные
```

### Merge Sort

```
✅ Использовать:
- Требуется стабильность
- Гарантия O(n log n)
- Связанные списки
- Внешняя сортировка (файлы)
- Параллельные вычисления

❌ Не использовать:
- Критичны требования к памяти
- Нужна in-place сортировка
```

### Quick Sort

```
✅ Использовать:
- Универсальная сортировка массивов
- Нужна максимальная скорость (в среднем)
- Достаточно памяти для стека

❌ Не использовать:
- Требуется стабильность
- Гарантия времени критична
- Уже отсортированные данные (без оптимизации)
```

### Heap Sort

```
✅ Использовать:
- Гарантия O(n log n) с O(1) памяти
- Системы реального времени
- Поиск k наибольших/наименьших

❌ Не использовать:
- Требуется стабильность
- Нужна максимальная скорость (cache-unfriendly)
```

## Практические сценарии

### Сценарий 1: Сортировка пользователей в веб-приложении

```python
users = [
    {"name": "Alice", "age": 30},
    {"name": "Bob", "age": 25},
    {"name": "Charlie", "age": 30},
]

# Требования:
# - Стабильность (сохранить порядок при равном возрасте)
# - Производительность не критична

# Решение: встроенный sort() (Timsort) — стабильный
users.sort(key=lambda u: u["age"])
```

### Сценарий 2: Сортировка миллионов записей

```python
# Требования:
# - Максимальная скорость
# - Память не ограничена

# Решение: Quick Sort или встроенный sort()
import random

data = [random.randint(0, 1000000) for _ in range(1000000)]
data.sort()  # Timsort — гибрид Merge Sort и Insertion Sort
```

### Сценарий 3: Поток данных в реальном времени

```python
# Требования:
# - Данные приходят по одному
# - Нужно поддерживать отсортированный список

# Решение: Insertion Sort или структура данных (BST, skip list)
import bisect

sorted_data = []
for item in incoming_stream():
    bisect.insort(sorted_data, item)  # O(n) вставка, но простота
```

### Сценарий 4: Топ-10 из миллиона элементов

```python
# Требования:
# - Найти только k наибольших
# - Память ограничена

# Решение: Heap (частичная сортировка)
import heapq

data = [random.randint(0, 1000000) for _ in range(1000000)]
top_10 = heapq.nlargest(10, data)  # O(n log k)
```

### Сценарий 5: Внешняя сортировка файла

```python
# Требования:
# - Файл не помещается в память
# - Стабильность желательна

# Решение: Merge Sort (внешний)
def external_merge_sort(input_file, output_file, chunk_size):
    # 1. Разбить файл на chunks
    # 2. Отсортировать каждый chunk в памяти
    # 3. Слить chunks с помощью k-way merge
    pass
```

## Гибридные алгоритмы

### Timsort (Python, Java)

```
Комбинация Merge Sort и Insertion Sort:
1. Находит "runs" — уже отсортированные подпоследовательности
2. Расширяет короткие runs с помощью Insertion Sort
3. Сливает runs с помощью Merge Sort

Преимущества:
- O(n) на почти отсортированных данных
- O(n log n) в худшем случае
- Стабильный
- Адаптивный
```

### Introsort (C++ std::sort)

```
Комбинация Quick Sort, Heap Sort и Insertion Sort:
1. Начинает с Quick Sort
2. Переключается на Heap Sort при глубокой рекурсии
3. Использует Insertion Sort для маленьких подмассивов

Преимущества:
- O(n log n) гарантированно
- Быстрый на практике
- In-place
```

### Pattern-Defeating Quicksort (pdqsort)

```
Современная версия Quick Sort:
- Обнаруживает паттерны в данных
- Использует Heap Sort как fallback
- Оптимизирован для современных процессоров
```

## Сравнение производительности (бенчмарки)

```
Время сортировки 100,000 случайных целых чисел:

Алгоритм          | Время (мс) | Примечание
──────────────────┼────────────┼──────────────────
Bubble Sort       | ~30,000    | Неприемлемо
Selection Sort    | ~8,000     | Очень медленно
Insertion Sort    | ~3,000     | Медленно
Merge Sort        | ~50        | Хорошо
Quick Sort        | ~30        | Отлично
Heap Sort         | ~80        | Хорошо
Python sort()     | ~15        | Оптимизирован (C)

На почти отсортированных данных:

Алгоритм          | Время (мс) | Изменение
──────────────────┼────────────┼──────────────
Insertion Sort    | ~5         | Очень быстро!
Bubble Sort       | ~50        | Быстрее
Quick Sort        | ~500       | Деградация!
Merge Sort        | ~50        | Без изменений
Python sort()     | ~5         | Адаптивен
```

## Рекомендации по выбору

```
┌─────────────────────────────────────────────────────────────┐
│                    ВЫБОР АЛГОРИТМА                          │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
              ┌────────────────────────┐
              │ Используйте встроенный │
              │ sort() если возможно   │
              └───────────┬────────────┘
                          │ Нет
                          ▼
              ┌────────────────────────┐
              │ n < 50?                │
              └───────────┬────────────┘
                     Да   │   Нет
            ┌─────────────┴─────────────┐
            ▼                           ▼
    ┌───────────────┐         ┌─────────────────────┐
    │ Insertion Sort│         │ Нужна стабильность? │
    └───────────────┘         └─────────┬───────────┘
                                   Да   │   Нет
                          ┌─────────────┴─────────────┐
                          ▼                           ▼
                  ┌───────────────┐       ┌───────────────────┐
                  │ Merge Sort    │       │ Нужна гарантия    │
                  └───────────────┘       │ O(n log n)?       │
                                          └─────────┬─────────┘
                                             Да     │   Нет
                                    ┌───────────────┴────────┐
                                    ▼                        ▼
                            ┌───────────────┐       ┌────────────┐
                            │ Heap Sort     │       │ Quick Sort │
                            └───────────────┘       └────────────┘
```

## Заключение

| Ситуация | Рекомендация |
|----------|--------------|
| Production код | `sorted()` или `.sort()` в Python |
| Образование | Bubble, Selection, Insertion для понимания |
| Маленькие массивы | Insertion Sort |
| Большие массивы | Quick Sort (или встроенный) |
| Стабильность нужна | Merge Sort (или встроенный) |
| Гарантия времени | Merge Sort или Heap Sort |
| Частичная сортировка | Heap (heapq) |
| Связанные списки | Merge Sort |
| Внешняя сортировка | Merge Sort |
| Почти отсортировано | Insertion Sort или Timsort |

---
[prev: 06-heap-sort](./06-heap-sort.md) | [next: 01-preorder](../04-tree-traversals/01-preorder.md)