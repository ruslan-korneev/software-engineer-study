# Пузырьковая сортировка (Bubble Sort)

[prev: 02-binary-search](../02-searching/02-binary-search.md) | [next: 02-selection-sort](./02-selection-sort.md)
---

## Определение

**Пузырьковая сортировка** — это простой алгоритм сортировки, который многократно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Проходы по списку повторяются до тех пор, пока список не будет отсортирован.

Название происходит от способа, которым большие элементы "всплывают" к концу списка, подобно пузырькам воздуха в воде.

## Зачем нужен

### Области применения:
- **Образовательные цели** — один из первых алгоритмов для изучения
- **Почти отсортированные данные** — эффективен с оптимизацией
- **Маленькие массивы** — простота важнее производительности
- **Проверка отсортированности** — один проход определяет, отсортирован ли массив

### Преимущества:
- Простота понимания и реализации
- Стабильная сортировка (сохраняет порядок равных элементов)
- In-place сортировка (O(1) дополнительной памяти)
- Адаптивность — быстро работает на почти отсортированных данных

### Недостатки:
- Очень медленный O(n^2) на случайных данных
- Неэффективен для больших массивов

## Как работает

### Визуализация процесса

```
Исходный массив: [5, 3, 8, 4, 2]

Проход 1:
[5, 3, 8, 4, 2]  5>3? Да, меняем
 ↑  ↑
[3, 5, 8, 4, 2]  5>8? Нет
    ↑  ↑
[3, 5, 8, 4, 2]  8>4? Да, меняем
       ↑  ↑
[3, 5, 4, 8, 2]  8>2? Да, меняем
          ↑  ↑
[3, 5, 4, 2, 8]  ← 8 "всплыл" на своё место
             ✓

Проход 2:
[3, 5, 4, 2, 8]  3>5? Нет
 ↑  ↑
[3, 5, 4, 2, 8]  5>4? Да, меняем
    ↑  ↑
[3, 4, 5, 2, 8]  5>2? Да, меняем
       ↑  ↑
[3, 4, 2, 5, 8]  ← 5 на месте
          ✓  ✓

Проход 3:
[3, 4, 2, 5, 8]  3>4? Нет
 ↑  ↑
[3, 4, 2, 5, 8]  4>2? Да, меняем
    ↑  ↑
[3, 2, 4, 5, 8]  ← 4 на месте
       ✓  ✓  ✓

Проход 4:
[3, 2, 4, 5, 8]  3>2? Да, меняем
 ↑  ↑
[2, 3, 4, 5, 8]  ← Отсортировано!
 ✓  ✓  ✓  ✓  ✓
```

### Схема "всплытия" элементов

```
Каждый проход "всплывает" максимальный элемент:

Проход 1: [?, ?, ?, ?, MAX]
Проход 2: [?, ?, ?, MAX, ✓]
Проход 3: [?, ?, MAX, ✓, ✓]
Проход 4: [?, MAX, ✓, ✓, ✓]
Проход 5: [MIN, ✓, ✓, ✓, ✓]
```

## Псевдокод

```
function bubbleSort(array):
    n = length(array)

    for i from 0 to n-1:
        for j from 0 to n-i-2:
            if array[j] > array[j+1]:
                swap(array[j], array[j+1])

    return array
```

### Базовая реализация на Python

```python
def bubble_sort(arr):
    """Базовая пузырьковая сортировка."""
    n = len(arr)

    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

    return arr
```

### Оптимизированная версия с флагом

```python
def bubble_sort_optimized(arr):
    """
    Оптимизированная пузырьковая сортировка.
    Останавливается, если массив уже отсортирован.
    """
    n = len(arr)

    for i in range(n):
        swapped = False

        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True

        # Если за проход не было обменов — массив отсортирован
        if not swapped:
            break

    return arr
```

### Версия с отслеживанием последнего обмена

```python
def bubble_sort_advanced(arr):
    """
    Продвинутая оптимизация.
    Отслеживает позицию последнего обмена.
    """
    n = len(arr)
    end = n - 1

    while end > 0:
        last_swap = 0

        for j in range(end):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                last_swap = j

        end = last_swap  # Все элементы после last_swap уже отсортированы

    return arr
```

### Двунаправленная пузырьковая сортировка (Cocktail Sort)

```python
def cocktail_sort(arr):
    """
    Шейкерная сортировка — проходы в обоих направлениях.
    Эффективнее для некоторых случаев.
    """
    n = len(arr)
    start, end = 0, n - 1

    while start < end:
        # Проход слева направо
        new_end = start
        for i in range(start, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                new_end = i
        end = new_end

        # Проход справа налево
        new_start = end
        for i in range(end, start, -1):
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
                new_start = i
        start = new_start

    return arr
```

## Анализ сложности

| Случай | Временная сложность | Описание |
|--------|---------------------|----------|
| **Лучший** | O(n) | Уже отсортированный массив (с оптимизацией) |
| **Средний** | O(n^2) | Случайный порядок |
| **Худший** | O(n^2) | Обратный порядок |

| Ресурс | Сложность |
|--------|-----------|
| **Время** | O(n^2) |
| **Память** | O(1) — in-place |
| **Стабильность** | Да |

### Количество операций:
- Сравнения: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n^2)
- Обмены (худший случай): n(n-1)/2 = O(n^2)

## Пример с пошаговым разбором

### Сортировка массива [64, 34, 25, 12, 22]

```
Исходный: [64, 34, 25, 12, 22]

Проход 1 (i=0):
j=0: [64, 34, 25, 12, 22] → 64>34 → [34, 64, 25, 12, 22]
j=1: [34, 64, 25, 12, 22] → 64>25 → [34, 25, 64, 12, 22]
j=2: [34, 25, 64, 12, 22] → 64>12 → [34, 25, 12, 64, 22]
j=3: [34, 25, 12, 64, 22] → 64>22 → [34, 25, 12, 22, 64]

Проход 2 (i=1):
j=0: [34, 25, 12, 22, 64] → 34>25 → [25, 34, 12, 22, 64]
j=1: [25, 34, 12, 22, 64] → 34>12 → [25, 12, 34, 22, 64]
j=2: [25, 12, 34, 22, 64] → 34>22 → [25, 12, 22, 34, 64]

Проход 3 (i=2):
j=0: [25, 12, 22, 34, 64] → 25>12 → [12, 25, 22, 34, 64]
j=1: [12, 25, 22, 34, 64] → 25>22 → [12, 22, 25, 34, 64]

Проход 4 (i=3):
j=0: [12, 22, 25, 34, 64] → 12<22 → без изменений

Результат: [12, 22, 25, 34, 64]
```

### Статистика:
- Проходов: 4
- Сравнений: 4 + 3 + 2 + 1 = 10
- Обменов: 4 + 3 + 2 + 0 = 9

## Типичные ошибки и Edge Cases

### 1. Неправильные границы цикла

```python
# ОШИБКА: выход за границы массива
def bubble_sort_wrong(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - 1):  # Нужно n - i - 1!
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

# ПРАВИЛЬНО
def bubble_sort_correct(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):  # -i для оптимизации
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
```

### 2. Пустой массив и массив из одного элемента

```python
def bubble_sort_safe(arr):
    if len(arr) <= 1:
        return arr

    # ... основной алгоритм

arr1 = []
arr2 = [42]
print(bubble_sort_safe(arr1))  # []
print(bubble_sort_safe(arr2))  # [42]
```

### 3. Сортировка с дубликатами

```python
# Bubble sort стабилен — равные элементы сохраняют порядок
arr = [(3, 'a'), (1, 'b'), (3, 'c'), (1, 'd')]

def bubble_sort_stable(arr, key=lambda x: x):
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):
            if key(arr[j]) > key(arr[j + 1]):
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

result = bubble_sort_stable(arr, key=lambda x: x[0])
print(result)  # [(1, 'b'), (1, 'd'), (3, 'a'), (3, 'c')]
# Порядок элементов с одинаковым ключом сохранён
```

### 4. Сортировка по убыванию

```python
def bubble_sort_descending(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] < arr[j + 1]:  # Изменён знак сравнения
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

arr = [3, 1, 4, 1, 5]
print(bubble_sort_descending(arr))  # [5, 4, 3, 1, 1]
```

### 5. Изменение исходного массива

```python
# Bubble sort изменяет исходный массив!
arr = [3, 1, 4]
bubble_sort(arr)
print(arr)  # [1, 3, 4] — изменён!

# Если нужно сохранить исходный:
arr = [3, 1, 4]
sorted_arr = bubble_sort(arr.copy())  # Работаем с копией
print(arr)        # [3, 1, 4] — не изменён
print(sorted_arr) # [1, 3, 4]
```

### Рекомендации:
1. Используйте Bubble Sort только для обучения или очень маленьких массивов
2. Для production кода используйте встроенный `sort()` или более эффективные алгоритмы
3. Всегда применяйте оптимизацию с флагом для раннего выхода
4. Помните, что алгоритм изменяет исходный массив
5. Bubble Sort хорош для проверки "почти отсортированности" данных

---
[prev: 02-binary-search](../02-searching/02-binary-search.md) | [next: 02-selection-sort](./02-selection-sort.md)