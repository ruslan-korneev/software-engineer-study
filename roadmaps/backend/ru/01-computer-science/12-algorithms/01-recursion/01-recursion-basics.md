# Рекурсия: Основы

[prev: 04-complexity-basics](../00-intro/04-complexity-basics.md) | [next: 02-tail-recursion](./02-tail-recursion.md)
---

## Определение

**Рекурсия** — это метод решения задач, при котором функция вызывает сама себя для решения меньших подзадач той же природы. Рекурсивная функция продолжает вызывать себя до тех пор, пока не достигнет базового случая (base case), который решается напрямую без дальнейших рекурсивных вызовов.

## Зачем нужна рекурсия

### Области применения:
- **Обработка древовидных структур данных** (деревья, графы)
- **Алгоритмы "разделяй и властвуй"** (merge sort, quick sort)
- **Математические вычисления** (факториал, числа Фибоначчи)
- **Обход файловой системы** (поиск файлов в директориях)
- **Парсинг выражений** (компиляторы, интерпретаторы)
- **Решение задач с возвратом** (backtracking: судоку, N ферзей)

### Преимущества:
- Код становится более читаемым и лаконичным
- Естественно подходит для задач с рекурсивной структурой
- Легко отображает математические определения

## Как работает рекурсия

### Два обязательных компонента:

1. **Базовый случай (Base Case)** — условие завершения рекурсии
2. **Рекурсивный случай (Recursive Case)** — вызов функции с изменёнными параметрами

### Визуализация стека вызовов

```
Вычисление factorial(4):

┌─────────────────────────────────────────┐
│          СТЕК ВЫЗОВОВ                   │
├─────────────────────────────────────────┤
│                                         │
│  factorial(1) = 1        ← базовый случай
│       ↑                                 │
│  factorial(2) = 2 * factorial(1) = 2    │
│       ↑                                 │
│  factorial(3) = 3 * factorial(2) = 6    │
│       ↑                                 │
│  factorial(4) = 4 * factorial(3) = 24   │
│       ↑                                 │
│  [начальный вызов]                      │
│                                         │
└─────────────────────────────────────────┘

Фаза разворачивания (unwinding):
factorial(4) → 4 * factorial(3)
                   → 3 * factorial(2)
                        → 2 * factorial(1)
                             → 1 (базовый случай)

Фаза сворачивания (winding back):
1 → 2*1=2 → 3*2=6 → 4*6=24
```

## Псевдокод

### Общий шаблон рекурсивной функции:

```
function recursiveFunction(параметры):
    # Базовый случай - условие завершения
    if базовое_условие:
        return базовое_значение

    # Рекурсивный случай
    # Выполнить некоторую работу
    result = recursiveFunction(изменённые_параметры)

    return результат_с_использованием_result
```

### Пример: Факториал

```python
def factorial(n):
    # Базовый случай
    if n <= 1:
        return 1

    # Рекурсивный случай
    return n * factorial(n - 1)
```

### Пример: Сумма элементов списка

```python
def sum_list(arr):
    # Базовый случай: пустой список
    if len(arr) == 0:
        return 0

    # Рекурсивный случай: первый элемент + сумма остальных
    return arr[0] + sum_list(arr[1:])
```

### Пример: Обратный порядок строки

```python
def reverse_string(s):
    # Базовый случай
    if len(s) <= 1:
        return s

    # Рекурсивный случай
    return s[-1] + reverse_string(s[:-1])
```

## Анализ сложности

### Факториал:
| Случай | Время | Память |
|--------|-------|--------|
| Все случаи | O(n) | O(n) — глубина стека |

### Числа Фибоначчи (наивная рекурсия):
| Случай | Время | Память |
|--------|-------|--------|
| Все случаи | O(2^n) | O(n) — глубина стека |

### Как оценить сложность рекурсии:

```
Время = количество_вызовов × работа_за_вызов
Память = максимальная_глубина_стека × память_на_вызов
```

### Теорема о рекурсивных соотношениях (Master Theorem):
Для рекурсий вида T(n) = aT(n/b) + f(n):
- a — количество подзадач
- n/b — размер каждой подзадачи
- f(n) — работа вне рекурсивных вызовов

## Пример с пошаговым разбором

### Задача: Вычислить n-е число Фибоначчи

```python
def fibonacci(n):
    # Базовые случаи
    if n <= 0:
        return 0
    if n == 1:
        return 1

    # Рекурсивный случай
    return fibonacci(n - 1) + fibonacci(n - 2)
```

### Пошаговый разбор для fibonacci(5):

```
fibonacci(5)
├── fibonacci(4)
│   ├── fibonacci(3)
│   │   ├── fibonacci(2)
│   │   │   ├── fibonacci(1) = 1
│   │   │   └── fibonacci(0) = 0
│   │   │   = 1
│   │   └── fibonacci(1) = 1
│   │   = 2
│   └── fibonacci(2)
│       ├── fibonacci(1) = 1
│       └── fibonacci(0) = 0
│       = 1
│   = 3
└── fibonacci(3)
    ├── fibonacci(2)
    │   ├── fibonacci(1) = 1
    │   └── fibonacci(0) = 0
    │   = 1
    └── fibonacci(1) = 1
    = 2
= 5
```

### Подсчёт вызовов:
- fibonacci(5) — 1 раз
- fibonacci(4) — 1 раз
- fibonacci(3) — 2 раза
- fibonacci(2) — 3 раза
- fibonacci(1) — 5 раз
- fibonacci(0) — 3 раза

Всего: 15 вызовов для n=5. Видна проблема повторных вычислений!

## Типичные ошибки и Edge Cases

### 1. Отсутствие базового случая

```python
# ОШИБКА: бесконечная рекурсия
def bad_factorial(n):
    return n * bad_factorial(n - 1)  # Никогда не остановится!

# ПРАВИЛЬНО
def good_factorial(n):
    if n <= 1:  # Базовый случай
        return 1
    return n * good_factorial(n - 1)
```

### 2. Неправильное движение к базовому случаю

```python
# ОШИБКА: параметр не приближается к базовому случаю
def bad_countdown(n):
    if n == 0:
        return
    print(n)
    bad_countdown(n + 1)  # Движемся в неправильном направлении!

# ПРАВИЛЬНО
def good_countdown(n):
    if n == 0:
        return
    print(n)
    good_countdown(n - 1)  # Приближаемся к базовому случаю
```

### 3. Переполнение стека (Stack Overflow)

```python
# Python имеет лимит глубины рекурсии (по умолчанию ~1000)
import sys
print(sys.getrecursionlimit())  # Обычно 1000

# Можно увеличить, но это не рекомендуется
sys.setrecursionlimit(10000)

# Лучше использовать итеративный подход для больших n
```

### 4. Неэффективная рекурсия (повторные вычисления)

```python
# НЕЭФФЕКТИВНО: O(2^n) — много повторных вычислений
def fib_slow(n):
    if n <= 1:
        return n
    return fib_slow(n-1) + fib_slow(n-2)

# ЭФФЕКТИВНО: O(n) с мемоизацией
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_fast(n):
    if n <= 1:
        return n
    return fib_fast(n-1) + fib_fast(n-2)
```

### 5. Edge Cases для обработки:

```python
def safe_factorial(n):
    # Обработка отрицательных чисел
    if n < 0:
        raise ValueError("Факториал не определён для отрицательных чисел")

    # Обработка нецелых чисел
    if not isinstance(n, int):
        raise TypeError("n должно быть целым числом")

    # Базовый случай
    if n <= 1:
        return 1

    return n * safe_factorial(n - 1)
```

### Рекомендации:
1. Всегда определяйте базовый случай первым
2. Убедитесь, что рекурсивный вызов приближает к базовому случаю
3. Рассмотрите возможность мемоизации для избежания повторных вычислений
4. Для глубокой рекурсии используйте итеративный подход или хвостовую рекурсию
5. Тестируйте edge cases: 0, 1, отрицательные числа, большие числа

---
[prev: 04-complexity-basics](../00-intro/04-complexity-basics.md) | [next: 02-tail-recursion](./02-tail-recursion.md)