# Ports

## Что такое порт?

**Порт** — это числовой идентификатор (от 0 до 65535), который позволяет различать разные приложения и сервисы на одном компьютере.

Если **IP-адрес** — это адрес дома, то **порт** — это номер квартиры.

```
         Сервер 192.168.1.100
    ┌─────────────────────────────┐
    │                             │
    │  ┌─────┐  ┌─────┐  ┌─────┐  │
    │  │:22  │  │:80  │  │:443 │  │
    │  │SSH  │  │HTTP │  │HTTPS│  │
    │  └─────┘  └─────┘  └─────┘  │
    │                             │
    │  ┌─────┐  ┌─────┐  ┌─────┐  │
    │  │:3306│  │:5432│  │:8080│  │
    │  │MySQL│  │Postgr│ │App  │  │
    │  └─────┘  └─────┘  └─────┘  │
    │                             │
    └─────────────────────────────┘
```

---

## Зачем нужны порты?

Один сервер может одновременно запускать множество сервисов:
- Веб-сервер на порту 80
- SSH на порту 22
- База данных на порту 5432
- API-сервер на порту 8080

Без портов было бы невозможно понять, какому приложению предназначены данные.

```
Пакет приходит на сервер 192.168.1.100:
├── Порт 80  → передать веб-серверу (Nginx)
├── Порт 22  → передать SSH-демону
├── Порт 5432 → передать PostgreSQL
└── Порт 8080 → передать вашему приложению
```

---

## Как работает связка IP:Port

```
Полный адрес = IP-адрес + Порт

Примеры:
192.168.1.100:80     ← HTTP на локальном сервере
93.184.216.34:443    ← HTTPS на example.com
127.0.0.1:3000       ← Локальный dev-сервер
0.0.0.0:8080         ← Слушать на всех интерфейсах
```

### Сокет (Socket)

**Socket** — это комбинация IP-адреса и порта, уникальный endpoint для соединения.

```
TCP-соединение определяется 4 параметрами:
┌─────────────────────────────────────────────────┐
│  Source IP    │  Source Port  │   Client        │
│  Dest IP      │  Dest Port    │   Server        │
└─────────────────────────────────────────────────┘

Пример:
Клиент: 192.168.1.5:54321 ──────► Сервер: 93.184.216.34:443
```

### Почему клиент использует случайный порт?

```
Браузер открывает 3 вкладки с google.com:

Вкладка 1: 192.168.1.5:49152 → google.com:443
Вкладка 2: 192.168.1.5:49153 → google.com:443
Вкладка 3: 192.168.1.5:49154 → google.com:443

Разные source-порты позволяют различать соединения!
```

---

## Диапазоны портов

```
┌─────────────────┬──────────────────┬────────────────────────────┐
│    Диапазон     │    Название      │       Описание             │
├─────────────────┼──────────────────┼────────────────────────────┤
│    0 - 1023     │ Well-known ports │ Системные, известные порты │
│                 │ (Привилегиров.)  │ Требуют root для bind      │
├─────────────────┼──────────────────┼────────────────────────────┤
│ 1024 - 49151    │ Registered ports │ Зарегистрированные IANA    │
│                 │                  │ Для приложений и сервисов  │
├─────────────────┼──────────────────┼────────────────────────────┤
│ 49152 - 65535   │ Dynamic/Private  │ Эфемерные (временные)      │
│                 │ Ephemeral ports  │ Для исходящих соединений   │
└─────────────────┴──────────────────┴────────────────────────────┘
```

### Well-known ports (0-1023)

Требуют привилегий администратора (root/sudo) для использования.

```bash
# Это не сработает от обычного пользователя:
python3 -m http.server 80
# PermissionError: [Errno 13] Permission denied

# А это сработает:
python3 -m http.server 8080  # порт > 1023
```

---

## Известные порты (Must-know для разработчика)

### Веб и HTTP

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Протокол   │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│  80  │ HTTP         │ Веб-трафик без шифрования               │
│ 443  │ HTTPS        │ Веб-трафик с SSL/TLS шифрованием        │
│ 8080 │ HTTP Alt     │ Альтернативный HTTP (dev-серверы)       │
│ 8443 │ HTTPS Alt    │ Альтернативный HTTPS                    │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Электронная почта

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Протокол   │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│  25  │ SMTP         │ Отправка почты (сервер-сервер)          │
│ 465  │ SMTPS        │ SMTP с SSL                              │
│ 587  │ SMTP         │ Отправка почты (клиент-сервер)          │
│ 110  │ POP3         │ Получение почты (скачивает)             │
│ 995  │ POP3S        │ POP3 с SSL                              │
│ 143  │ IMAP         │ Получение почты (синхронизация)         │
│ 993  │ IMAPS        │ IMAP с SSL                              │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Передача файлов

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Протокол   │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│  20  │ FTP (data)   │ FTP — передача данных                   │
│  21  │ FTP (control)│ FTP — команды                           │
│  22  │ SFTP/SCP     │ Безопасная передача через SSH           │
│  69  │ TFTP         │ Простой FTP (UDP, без аутентификации)   │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Удалённый доступ

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Протокол   │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│  22  │ SSH          │ Secure Shell (удалённый доступ)         │
│  23  │ Telnet       │ Незащищённый удалённый доступ (устарел) │
│ 3389 │ RDP          │ Remote Desktop Protocol (Windows)       │
│ 5900 │ VNC          │ Virtual Network Computing               │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Базы данных

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   База       │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│ 3306 │ MySQL        │ MySQL / MariaDB                         │
│ 5432 │ PostgreSQL   │ PostgreSQL                              │
│ 1433 │ MS SQL       │ Microsoft SQL Server                    │
│ 1521 │ Oracle       │ Oracle Database                         │
│27017 │ MongoDB      │ MongoDB                                 │
│ 6379 │ Redis        │ Redis (in-memory cache)                 │
│11211 │ Memcached    │ Memcached                               │
│ 9200 │ Elasticsearch│ Elasticsearch HTTP API                  │
│ 9042 │ Cassandra    │ Apache Cassandra                        │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Очереди сообщений

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Сервис     │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│ 5672 │ RabbitMQ     │ AMQP протокол                           │
│15672 │ RabbitMQ     │ Management UI                           │
│ 9092 │ Kafka        │ Apache Kafka                            │
│ 4222 │ NATS         │ NATS messaging                          │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Системные сервисы

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Протокол   │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│  53  │ DNS          │ Domain Name System (UDP и TCP)          │
│  67  │ DHCP (server)│ Выдача IP-адресов                       │
│  68  │ DHCP (client)│ Получение IP-адреса                     │
│ 123  │ NTP          │ Синхронизация времени                   │
│ 161  │ SNMP         │ Мониторинг сетевых устройств            │
│ 514  │ Syslog       │ Логирование                             │
└──────┴──────────────┴─────────────────────────────────────────┘
```

### Контейнеры и DevOps

```
┌──────┬──────────────┬─────────────────────────────────────────┐
│ Порт │   Сервис     │              Описание                   │
├──────┼──────────────┼─────────────────────────────────────────┤
│ 2375 │ Docker       │ Docker API (без TLS)                    │
│ 2376 │ Docker       │ Docker API (с TLS)                      │
│ 6443 │ Kubernetes   │ Kubernetes API Server                   │
│ 9090 │ Prometheus   │ Prometheus metrics                      │
│ 3000 │ Grafana      │ Grafana dashboards                      │
│ 8500 │ Consul       │ Consul HTTP API                         │
│ 2379 │ etcd         │ etcd client API                         │
└──────┴──────────────┴─────────────────────────────────────────┘
```

---

## Работа с портами на практике

### Проверка открытых портов

```bash
# Linux: показать слушающие порты
ss -tlnp          # TCP
ss -ulnp          # UDP
ss -tulnp         # TCP и UDP

# macOS: показать слушающие порты
lsof -iTCP -sTCP:LISTEN
netstat -an | grep LISTEN

# Windows: показать слушающие порты
netstat -an | findstr LISTENING

# Проверить конкретный порт
lsof -i :8080           # Кто слушает порт 8080
ss -tlnp | grep 8080    # Linux
netstat -an | grep 8080
```

### Проверка доступности удалённого порта

```bash
# С помощью netcat
nc -vz google.com 443
# Connection to google.com 443 port [tcp/https] succeeded!

# С помощью telnet
telnet google.com 80
# Trying 142.250.74.78...
# Connected to google.com.

# С помощью curl (только HTTP/HTTPS)
curl -I http://example.com:80
curl -I https://example.com:443

# Nmap — сканирование портов
nmap -p 22,80,443 example.com
nmap -p 1-1000 192.168.1.1    # Диапазон
```

### Освобождение занятого порта

```bash
# Найти процесс на порту
lsof -i :8080
# COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
# python3 12345 user    4u  IPv4 1234567      0t0  TCP *:8080 (LISTEN)

# Завершить процесс
kill 12345          # Мягкое завершение
kill -9 12345       # Принудительное завершение

# Одной командой
kill $(lsof -t -i:8080)  # -t возвращает только PID
fuser -k 8080/tcp        # Linux
```

---

## Привязка к портам в коде

### Python

```python
import socket

# Создаём TCP сервер
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Опция SO_REUSEADDR — можно переиспользовать порт сразу
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Привязываем к адресу и порту
server.bind(('0.0.0.0', 8080))  # 0.0.0.0 = все интерфейсы
server.bind(('127.0.0.1', 8080))  # только localhost

server.listen(5)
print("Сервер слушает на порту 8080")
```

### Flask (Python)

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello World!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
    # host='0.0.0.0' — доступен извне
    # host='127.0.0.1' — только локально
```

### Node.js

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello World\n');
});

// Порт из переменной окружения или 3000 по умолчанию
const PORT = process.env.PORT || 3000;

server.listen(PORT, '0.0.0.0', () => {
    console.log(`Server running on port ${PORT}`);
});
```

---

## Port Forwarding и NAT

### Как внешний мир достигает вашего локального сервера?

```
                        Интернет
                            │
              Публичный IP: 203.0.113.50
                            │
                       ┌────┴────┐
                       │  Router │  ← Port Forwarding настроен
                       │  (NAT)  │
                       └────┬────┘
                            │
              Приватная сеть 192.168.1.0/24
                            │
                       ┌────┴────┐
                       │  Server │
                       │  .100   │
                       │ :8080   │
                       └─────────┘

Port Forwarding:
Внешний запрос на 203.0.113.50:80 → перенаправляется на 192.168.1.100:8080
```

### Docker Port Mapping

```bash
# Запустить контейнер с проброской порта
docker run -p 8080:80 nginx
#           │     │
#           │     └── порт внутри контейнера
#           └── порт на хосте

# Проброс на конкретный интерфейс
docker run -p 127.0.0.1:8080:80 nginx  # только localhost
docker run -p 0.0.0.0:8080:80 nginx    # все интерфейсы (default)
```

---

## Безопасность портов

### Закрытие ненужных портов

```bash
# Linux: firewalld
sudo firewall-cmd --permanent --remove-port=8080/tcp
sudo firewall-cmd --reload

# Linux: iptables
sudo iptables -A INPUT -p tcp --dport 8080 -j DROP

# Linux: ufw (Ubuntu)
sudo ufw deny 8080/tcp
sudo ufw enable
```

### Ограничение доступа по IP

```bash
# Разрешить только с определённых IP
sudo iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 22 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 22 -j DROP

# ufw
sudo ufw allow from 192.168.1.0/24 to any port 22
```

### Смена стандартного порта

```bash
# SSH на нестандартном порту (меньше атак)
# /etc/ssh/sshd_config
Port 2222

# Подключение
ssh -p 2222 user@server.com
```

---

## Распространённые проблемы с портами

### 1. Порт уже занят

```
Error: Address already in use (EADDRINUSE)

Решение:
1. Найти процесс: lsof -i :8080
2. Завершить его: kill <PID>
3. Или использовать другой порт
```

### 2. Permission denied (порт < 1024)

```
Error: Permission denied

Решение:
1. Запустить с sudo (не рекомендуется)
2. Использовать порт > 1024
3. Дать capability: sudo setcap 'cap_net_bind_service=+ep' ./binary
4. Использовать reverse proxy (nginx на 80 → app на 8080)
```

### 3. Connection refused

```
Error: Connection refused

Причины:
1. Сервис не запущен
2. Сервис слушает другой порт
3. Сервис слушает только localhost (127.0.0.1)
4. Firewall блокирует соединение

Диагностика:
ss -tlnp | grep <port>       # Проверить, слушает ли
telnet server.com <port>     # Проверить соединение
sudo iptables -L             # Проверить firewall
```

### 4. TIME_WAIT после перезапуска

```
Error: Address already in use (порт в TIME_WAIT)

Причина: TCP-порт остаётся в TIME_WAIT ~60 сек после закрытия

Решение (в коде):
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
```

---

## Быстрая шпаргалка

```
┌────────────────────────────────────────────────────────────────┐
│                    Основные порты                              │
├──────┬─────────────────────────────────────────────────────────┤
│  22  │ SSH                                                     │
│  80  │ HTTP                                                    │
│ 443  │ HTTPS                                                   │
│ 3000 │ Node.js dev                                             │
│ 3306 │ MySQL                                                   │
│ 5000 │ Flask dev                                               │
│ 5432 │ PostgreSQL                                              │
│ 6379 │ Redis                                                   │
│ 8000 │ Django dev                                              │
│ 8080 │ Alternative HTTP                                        │
│27017 │ MongoDB                                                 │
└──────┴─────────────────────────────────────────────────────────┘

Команды для проверки:
ss -tlnp               # Слушающие TCP порты (Linux)
lsof -i :<port>        # Кто использует порт
nc -vz host port       # Проверить доступность
kill $(lsof -t -i:port) # Освободить порт
```

---

## Ключевые моменты для backend-разработчика

1. **Используй переменные окружения** — `PORT=8080` легко менять при деплое
2. **Слушай на 0.0.0.0** — для доступа извне (но помни о безопасности)
3. **Используй порты > 1024** — не нужны привилегии
4. **SO_REUSEADDR** — для быстрого перезапуска сервера
5. **Reverse proxy** — nginx/traefik на 80/443, приложение на высоком порту
6. **Docker port mapping** — `-p host:container`
7. **Мониторинг** — знай, какие порты открыты на твоём сервере
