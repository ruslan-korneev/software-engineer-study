# Как работают браузеры

**Браузер** — программа, которая загружает веб-страницы и отображает их пользователю.

```
URL → Загрузка ресурсов → Парсинг → Рендеринг → Страница на экране
```

## Основные компоненты браузера

```
┌─────────────────────────────────────────────┐
│              Пользовательский интерфейс     │
│         (адресная строка, кнопки, табы)     │
├─────────────────────────────────────────────┤
│              Browser Engine                  │
│     (связывает UI и движок рендеринга)      │
├─────────────────────────────────────────────┤
│            Rendering Engine                  │
│        (HTML/CSS → визуальный вывод)        │
├──────────────────┬──────────────────────────┤
│   Networking     │    JavaScript Engine     │
│  (HTTP-запросы)  │      (V8, SpiderMonkey)  │
├──────────────────┴──────────────────────────┤
│   Data Storage (cookies, localStorage, DB)  │
└─────────────────────────────────────────────┘
```

## Движки браузеров

| Браузер | Rendering Engine | JS Engine |
|---------|------------------|-----------|
| Chrome | Blink | V8 |
| Firefox | Gecko | SpiderMonkey |
| Safari | WebKit | JavaScriptCore |
| Edge | Blink | V8 |

Большинство современных браузеров основаны на Chromium (Blink + V8).

## Что происходит при вводе URL?

```
1. Ввод URL: google.com
       ↓
2. DNS-запрос → получаем IP-адрес
       ↓
3. TCP-соединение + TLS handshake (для HTTPS)
       ↓
4. HTTP-запрос: GET /
       ↓
5. Сервер отвечает: HTML-документ
       ↓
6. Парсинг HTML → DOM-дерево
       ↓
7. Параллельно: загрузка CSS, JS, картинок
       ↓
8. Парсинг CSS → CSSOM
       ↓
9. DOM + CSSOM → Render Tree
       ↓
10. Layout (расчёт позиций и размеров)
       ↓
11. Paint (отрисовка пикселей)
       ↓
12. Composite (сборка слоёв и вывод на экран)
```

## Парсинг HTML → DOM

```html
<html>
  <body>
    <h1>Hello</h1>
    <p>World</p>
  </body>
</html>
```

Превращается в дерево:

```
        Document
            │
          <html>
            │
          <body>
          /    \
      <h1>      <p>
        |         |
    "Hello"   "World"
```

**DOM (Document Object Model)** — древовидное представление HTML-документа. JavaScript взаимодействует со страницей через DOM.

## CSS → CSSOM

```css
body { font-size: 16px; }
h1 { color: red; }
```

Превращается в CSSOM:

```
       CSSOM
         │
       body
     font-size: 16px
         │
        h1
     color: red
```

**CSSOM (CSS Object Model)** — древовидное представление стилей.

## Render Tree

DOM + CSSOM = **Render Tree** (только видимые элементы)

```
Render Tree
     │
   body (font-size: 16px)
   /    \
 h1      p
(red)  (default)
```

- Элементы с `display: none` **не попадают** в Render Tree
- Элементы с `visibility: hidden` **попадают** (занимают место)

## Layout, Paint, Composite

| Этап | Что делает | Когда пересчитывается |
|------|------------|----------------------|
| **Layout** | Вычисляет размеры и позиции | Изменение размеров, добавление элементов |
| **Paint** | Рисует пиксели (текст, цвета, тени, границы) | Изменение цвета, фона |
| **Composite** | Собирает слои и выводит на GPU/экран | Трансформации, opacity |

## Reflow и Repaint

JavaScript может изменять DOM и CSSOM → запускает повторный рендеринг.

```
JS изменил DOM → Layout → Paint → Composite
                (reflow)  (repaint)
```

| Операция | Что происходит | Цена |
|----------|----------------|------|
| **Reflow** | Пересчёт позиций и размеров | Дорого |
| **Repaint** | Перерисовка без изменения layout | Дешевле |

**Примеры операций, вызывающих reflow:**
- Изменение размеров окна
- Изменение шрифта
- Добавление/удаление элементов
- Изменение `width`, `height`, `margin`, `padding`

## Блокирующие ресурсы

| Ресурс | Поведение |
|--------|-----------|
| **CSS** | Блокирует рендеринг (render-blocking) |
| **JS** (обычный) | Блокирует парсинг HTML |
| **JS** с `async` | Загружается параллельно, выполняется сразу после загрузки |
| **JS** с `defer` | Загружается параллельно, выполняется после парсинга HTML |

```html
<!-- Блокирует парсинг HTML -->
<script src="app.js"></script>

<!-- Загружается параллельно, выполняется когда готов -->
<script src="analytics.js" async></script>

<!-- Загружается параллельно, выполняется после DOM ready -->
<script src="app.js" defer></script>
```

**Рекомендация:** использовать `defer` для основных скриптов, `async` для независимых (аналитика).

## Critical Rendering Path

Критический путь рендеринга — минимальный набор ресурсов для первого отображения:

1. HTML
2. CSS (в `<head>`)
3. Блокирующий JS (если есть)

**Оптимизация:**
- Минимизировать CSS/JS
- Inline критический CSS
- Defer/async для скриптов
- Ленивая загрузка картинок (`loading="lazy"`)

## Хранилища браузера

| Хранилище | Размер | Срок жизни | Доступ |
|-----------|--------|------------|--------|
| **Cookies** | ~4 KB | Задаётся | Сервер + клиент |
| **localStorage** | ~5-10 MB | Постоянно | Только клиент |
| **sessionStorage** | ~5-10 MB | До закрытия вкладки | Только клиент |
| **IndexedDB** | Большой | Постоянно | Только клиент |

## DevTools (инструменты разработчика)

Открыть: `F12` или `Cmd+Option+I` (Mac) / `Ctrl+Shift+I` (Windows)

| Вкладка | Назначение |
|---------|------------|
| **Elements** | Просмотр и редактирование DOM/CSS |
| **Console** | JavaScript консоль, логи, ошибки |
| **Network** | HTTP-запросы, время загрузки |
| **Performance** | Профилирование, flamegraph |
| **Application** | Storage, cookies, Service Workers |
| **Sources** | Исходный код, отладка JS |

## Same-Origin Policy

Политика безопасности: скрипт может обращаться только к ресурсам с того же origin.

**Origin** = протокол + домен + порт

```
https://example.com:443/page
──┬──   ────┬────  ─┬─
протокол  домен   порт
```

Разные origin:
- `http://example.com` ≠ `https://example.com` (протокол)
- `example.com` ≠ `api.example.com` (домен)
- `example.com:80` ≠ `example.com:8080` (порт)

Для кросс-доменных запросов используется **CORS** (Cross-Origin Resource Sharing).

---

## Q&A

### Почему некоторые браузеры потребляют много RAM, а другие — мало?

**Главная причина: архитектура процессов**

**Chrome (много RAM)** — многопроцессная архитектура:
```
Chrome
├── Главный процесс (UI)
├── GPU процесс
├── Процесс сети
├── Вкладка 1 (отдельный процесс)
├── Вкладка 2 (отдельный процесс)
├── Расширение 1 (отдельный процесс)
└── Расширение 2 (отдельный процесс)
```

Каждая вкладка = отдельный процесс = накладные расходы (~30-50 MB минимум).

**Плюсы многопроцессности:**
- Падение одной вкладки не убивает браузер
- Безопасность (изоляция между вкладками)
- Использует многоядерность CPU

**Легковесные браузеры** — однопроцессные или с меньшим количеством процессов.

**Сравнение:**

| Браузер | Подход | RAM на старте |
|---------|--------|---------------|
| Chrome | Многопроцессный | ~300-500 MB |
| Firefox | Гибридный | ~200-400 MB |
| Midori, Falkon | Однопроцессный | ~50-100 MB |
| Links, w3m | Текстовые, без JS | ~5-10 MB |

**Другие факторы потребления RAM:**
- **JS Engine:** V8 быстрый, но ест память (JIT-компиляция)
- **Предзагрузка:** Chrome кэширует и предзагружает ссылки
- **Расширения:** каждое = отдельный процесс
- **Встроенные функции:** PDF, переводчик, синхронизация

**Почему Chrome не оптимизирует:**
Google сознательно выбрал безопасность и стабильность выше экономии памяти. При нехватке RAM Chrome умеет "выгружать" неактивные вкладки.
