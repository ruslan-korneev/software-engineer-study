# Формат shell-скрипта

## Shebang (шебанг)

Первая строка скрипта должна начинаться с **shebang** - специальной последовательности `#!`, за которой следует путь к интерпретатору:

```bash
#!/bin/bash
```

### Как работает shebang

Когда вы запускаете скрипт, система читает первые два байта файла. Если это `#!`, система использует указанный после них путь как интерпретатор для выполнения скрипта.

```bash
#!/bin/bash        # Использовать bash
#!/bin/sh          # Использовать POSIX shell
#!/usr/bin/env bash # Найти bash через env (более переносимо)
#!/usr/bin/python3  # Скрипт на Python
```

### Почему `/usr/bin/env`

Путь к bash может отличаться на разных системах:
- Linux: обычно `/bin/bash`
- macOS: `/bin/bash` или `/usr/local/bin/bash` (Homebrew)
- FreeBSD: `/usr/local/bin/bash`

Использование `#!/usr/bin/env bash` заставляет систему искать bash в `$PATH`, что делает скрипт более переносимым.

## Комментарии

Комментарии начинаются с символа `#` и продолжаются до конца строки:

```bash
#!/bin/bash

# Это однострочный комментарий
echo "Hello"  # Комментарий в конце строки

# Многострочные комментарии делаются так:
# Первая строка комментария
# Вторая строка комментария
# Третья строка комментария
```

### Блочные комментарии (hack)

Bash не имеет настоящих блочных комментариев, но можно использовать here-document:

```bash
: << 'COMMENT'
Это многострочный
блочный комментарий.
Он не будет выполнен.
COMMENT
```

## Структура скрипта

Типичный shell-скрипт имеет следующую структуру:

```bash
#!/bin/bash
#
# Название: backup.sh
# Описание: Скрипт для резервного копирования
# Автор: Имя автора
# Дата: 2024-01-15
# Версия: 1.0
#

# ============================================
# Глобальные переменные и константы
# ============================================
BACKUP_DIR="/var/backups"
DATE=$(date +%Y%m%d)

# ============================================
# Функции
# ============================================
show_usage() {
    echo "Использование: $0 [опции]"
}

do_backup() {
    echo "Создание резервной копии..."
}

# ============================================
# Основной код
# ============================================
main() {
    show_usage
    do_backup
}

# Запуск главной функции
main "$@"
```

## Команды и их разделители

### Точка с запятой

Несколько команд можно написать на одной строке, разделяя их `;`:

```bash
echo "Первая команда"; echo "Вторая команда"
```

### Перенос длинных строк

Символ `\` позволяет перенести команду на следующую строку:

```bash
echo "Это очень длинная строка, которая \
продолжается на следующей строке"

# Полезно для длинных команд
find /home -type f \
    -name "*.log" \
    -mtime +30 \
    -delete
```

### Логические операторы

```bash
# && - выполнить следующую команду, если предыдущая успешна
mkdir backup && cp file.txt backup/

# || - выполнить следующую команду, если предыдущая неуспешна
cd /dir || echo "Директория не существует"

# Комбинация
cd /dir && echo "Успешно" || echo "Ошибка"
```

## Кодировка и окончания строк

### Кодировка

Используйте **UTF-8** для shell-скриптов:

```bash
# Проверить кодировку файла
file script.sh

# Конвертировать в UTF-8
iconv -f ISO-8859-1 -t UTF-8 script.sh > script_utf8.sh
```

### Окончания строк

Shell-скрипты должны использовать Unix-стиль окончаний строк (LF, `\n`), а не Windows-стиль (CRLF, `\r\n`):

```bash
# Проверить окончания строк
cat -A script.sh  # ^M в конце строк означает CRLF

# Конвертировать из Windows в Unix
sed -i 's/\r$//' script.sh
# или
dos2unix script.sh
```

## Расширение файла

Shell-скрипты обычно имеют расширение `.sh`, но это не обязательно:

```bash
script.sh      # Стандартное расширение
script.bash    # Явно указывает на bash
script         # Без расширения (часто для утилит)
```

Расширение - это просто соглашение для удобства. Система определяет интерпретатор по shebang, а не по расширению.
