# How Code Runs

## От исходного кода к исполнению

Понимание того, как код превращается в работающую программу, помогает писать более эффективный код и отлаживать сложные проблемы.

## Этапы выполнения программы

### 1. Написание исходного кода

Программист пишет код на языке программирования в текстовом файле.

```python
# main.py
def greet(name):
    return f"Привет, {name}!"

message = greet("Мир")
print(message)
```

### 2. Лексический анализ (Lexing/Tokenization)

Исходный код разбивается на **токены** - минимальные значимые единицы.

```
def     -> KEYWORD
greet   -> IDENTIFIER
(       -> LPAREN
name    -> IDENTIFIER
)       -> RPAREN
:       -> COLON
return  -> KEYWORD
...
```

### 3. Синтаксический анализ (Parsing)

Токены организуются в **AST (Abstract Syntax Tree)** - древовидную структуру, отражающую структуру программы.

```
FunctionDef
├── name: "greet"
├── args: ["name"]
└── body:
    └── Return
        └── FormattedValue
            └── JoinedStr: "Привет, {name}!"
```

### 4. Семантический анализ

Проверяется корректность программы:
- Объявлены ли все переменные?
- Совместимы ли типы?
- Корректны ли вызовы функций?

### 5. Генерация кода

AST преобразуется в исполняемый код:
- **Компилятор**: создаёт машинный код
- **Интерпретатор**: создаёт байткод или выполняет напрямую

### 6. Выполнение

Процессор (CPU) выполняет инструкции программы.

## Процессор (CPU) и выполнение инструкций

### Архитектура CPU

```
┌─────────────────────────────────────────┐
│                  CPU                     │
│  ┌─────────────┐    ┌─────────────────┐ │
│  │   Регистры  │    │  Арифметико-    │ │
│  │   (быстрая  │    │  логическое     │ │
│  │   память)   │    │  устройство     │ │
│  └─────────────┘    │  (ALU)          │ │
│                     └─────────────────┘ │
│  ┌─────────────────────────────────────┐│
│  │       Устройство управления         ││
│  │    (Control Unit)                   ││
│  └─────────────────────────────────────┘│
└─────────────────────────────────────────┘
           │              ▲
           ▼              │
┌─────────────────────────────────────────┐
│              Память (RAM)               │
└─────────────────────────────────────────┘
```

### Цикл выполнения инструкций (Fetch-Decode-Execute)

1. **Fetch (Выборка)** - CPU загружает инструкцию из памяти
2. **Decode (Декодирование)** - определяется, что делать
3. **Execute (Выполнение)** - инструкция выполняется
4. **Store (Сохранение)** - результат записывается

```
Пример машинной инструкции:
ADD R1, R2, R3   # R1 = R2 + R3

1. Fetch:   загрузить инструкцию ADD из памяти
2. Decode:  это сложение, операнды в R2 и R3
3. Execute: ALU выполняет сложение
4. Store:   результат записывается в R1
```

### Регистры

**Регистры** - сверхбыстрая память внутри CPU (несколько байт).

| Тип регистра | Назначение |
|--------------|------------|
| Регистры общего назначения | Хранение данных и промежуточных результатов |
| Program Counter (PC) | Адрес следующей инструкции |
| Stack Pointer (SP) | Указатель на вершину стека |
| Instruction Register (IR) | Текущая инструкция |

## Организация памяти

### Иерархия памяти

```
Скорость ▲                              Объём ▼
         │  ┌─────────────┐
         │  │  Регистры   │  Несколько байт, ~1 нс
         │  └─────────────┘
         │  ┌─────────────┐
         │  │   L1 Cache  │  32-64 KB, ~4 нс
         │  └─────────────┘
         │  ┌─────────────┐
         │  │   L2 Cache  │  256 KB - 1 MB, ~10 нс
         │  └─────────────┘
         │  ┌─────────────┐
         │  │   L3 Cache  │  4-50 MB, ~40 нс
         │  └─────────────┘
         │  ┌─────────────┐
         │  │     RAM     │  8-64 GB, ~100 нс
         │  └─────────────┘
         │  ┌─────────────┐
         │  │   SSD/HDD   │  TB, ~10-100 мкс
         │  └─────────────┘
```

### Структура памяти программы

При запуске программы ОС выделяет ей адресное пространство:

```
Высокие адреса
┌─────────────────────┐
│       Stack         │  ← Стек (растёт вниз)
│         ↓           │
├─────────────────────┤
│                     │
│    Свободная        │
│      память         │
│                     │
├─────────────────────┤
│         ↑           │
│       Heap          │  ← Куча (растёт вверх)
├─────────────────────┤
│       BSS           │  ← Неинициализированные глобальные
├─────────────────────┤
│       Data          │  ← Инициализированные глобальные
├─────────────────────┤
│       Text          │  ← Код программы
└─────────────────────┘
Низкие адреса
```

## Стек вызовов (Call Stack)

### Что такое стек вызовов?

**Стек вызовов** - структура данных, которая отслеживает выполнение функций. Каждый вызов функции создаёт новый **фрейм (stack frame)** на стеке.

### Пример работы стека

```python
def multiply(a, b):
    return a * b

def square(x):
    return multiply(x, x)

def main():
    result = square(5)
    print(result)

main()
```

### Состояние стека во время выполнения

```
Шаг 1: Вызов main()
┌─────────────────┐
│    main()       │ ← top
└─────────────────┘

Шаг 2: main() вызывает square(5)
┌─────────────────┐
│   square(5)     │ ← top
├─────────────────┤
│    main()       │
└─────────────────┘

Шаг 3: square() вызывает multiply(5, 5)
┌─────────────────┐
│ multiply(5, 5)  │ ← top
├─────────────────┤
│   square(5)     │
├─────────────────┤
│    main()       │
└─────────────────┘

Шаг 4: multiply() возвращает 25, удаляется со стека
┌─────────────────┐
│   square(5)     │ ← top (результат = 25)
├─────────────────┤
│    main()       │
└─────────────────┘

Шаг 5: square() возвращает 25
┌─────────────────┐
│    main()       │ ← top (result = 25)
└─────────────────┘

Шаг 6: main() завершается
(стек пуст)
```

### Структура фрейма стека

```
┌─────────────────────────┐
│    Локальные переменные │
├─────────────────────────┤
│    Адрес возврата       │  ← Куда вернуться после завершения
├─────────────────────────┤
│    Аргументы функции    │
├─────────────────────────┤
│    Указатель на         │
│    предыдущий фрейм     │
└─────────────────────────┘
```

### Stack Overflow

**Stack Overflow** - ошибка переполнения стека, обычно из-за бесконечной рекурсии.

```python
def infinite_recursion():
    return infinite_recursion()  # Никогда не останавливается

infinite_recursion()
# RecursionError: maximum recursion depth exceeded
```

## Куча (Heap)

### Что такое куча?

**Куча** - область памяти для динамического выделения. В отличие от стека, объекты в куче живут пока на них есть ссылки.

```python
# Объект создаётся в куче
my_list = [1, 2, 3, 4, 5]

# my_list - ссылка на объект в куче
# Сама ссылка хранится на стеке
```

### Стек vs Куча

| Характеристика | Стек | Куча |
|----------------|------|------|
| Управление | Автоматическое (LIFO) | Ручное или GC |
| Скорость | Очень быстрый | Медленнее |
| Размер | Ограничен (~1-8 MB) | Ограничен RAM |
| Данные | Локальные переменные, адреса возврата | Объекты, динамические структуры |
| Порядок | Строго упорядочен | Фрагментирован |

## Runtime (Среда выполнения)

**Runtime** - это всё, что нужно для выполнения программы: интерпретатор, стандартная библиотека, сборщик мусора и т.д.

### Компоненты Runtime

```
┌────────────────────────────────────────────┐
│                 Runtime                     │
│  ┌────────────────────────────────────────┐│
│  │           Исполняемый код              ││
│  └────────────────────────────────────────┘│
│  ┌──────────────┐  ┌────────────────────┐ │
│  │   Сборщик    │  │    Стандартная     │ │
│  │   мусора     │  │    библиотека      │ │
│  └──────────────┘  └────────────────────┘ │
│  ┌──────────────┐  ┌────────────────────┐ │
│  │  Менеджер    │  │    Обработчик      │ │
│  │  памяти      │  │    исключений      │ │
│  └──────────────┘  └────────────────────┘ │
└────────────────────────────────────────────┘
```

### Примеры Runtime

| Язык | Runtime |
|------|---------|
| Java | JVM (Java Virtual Machine) |
| C# | CLR (Common Language Runtime) |
| Python | CPython, PyPy |
| JavaScript | V8, SpiderMonkey |
| Go | Go Runtime (встроен в бинарник) |

## Сборка мусора (Garbage Collection)

### Что такое GC?

**Сборщик мусора** автоматически освобождает память, которая больше не используется.

```python
def create_objects():
    # Создаются объекты в куче
    data = [1, 2, 3]
    more_data = {"key": "value"}
    return data  # more_data становится "мусором"

result = create_objects()
# После выхода из функции словарь more_data
# недоступен -> GC освободит его память
```

### Алгоритмы GC

#### 1. Reference Counting (подсчёт ссылок)
```
a = [1, 2, 3]    # refcount = 1
b = a            # refcount = 2
del a            # refcount = 1
del b            # refcount = 0 -> освободить память
```

**Проблема**: циклические ссылки
```python
a = []
b = []
a.append(b)  # a ссылается на b
b.append(a)  # b ссылается на a
# Даже после del a, del b - память не освободится
```

#### 2. Mark and Sweep
1. **Mark** - пометить все достижимые объекты
2. **Sweep** - удалить непомеченные объекты

#### 3. Generational GC
Объекты делятся на поколения:
- **Молодое поколение** - новые объекты (чаще проверяются)
- **Старое поколение** - долгоживущие объекты (реже проверяются)

## Пример: как выполняется Python-код

```python
# example.py
x = 10
y = 20
z = x + y
print(z)
```

### Шаг 1: Компиляция в байткод

```bash
python -m dis example.py
```

```
  1           0 LOAD_CONST               0 (10)
              2 STORE_NAME               0 (x)

  2           4 LOAD_CONST               1 (20)
              6 STORE_NAME               1 (y)

  3           8 LOAD_NAME                0 (x)
             10 LOAD_NAME                1 (y)
             12 BINARY_ADD
             14 STORE_NAME               2 (z)

  4          16 LOAD_NAME                3 (print)
             18 LOAD_NAME                2 (z)
             20 CALL_FUNCTION            1
             22 POP_TOP
             24 LOAD_CONST               2 (None)
             26 RETURN_VALUE
```

### Шаг 2: Интерпретация байткода

Python VM выполняет каждую инструкцию:

1. `LOAD_CONST 10` - загрузить число 10 на стек
2. `STORE_NAME x` - сохранить в переменную x
3. `LOAD_CONST 20` - загрузить число 20 на стек
4. `STORE_NAME y` - сохранить в переменную y
5. `LOAD_NAME x` - загрузить значение x на стек
6. `LOAD_NAME y` - загрузить значение y на стек
7. `BINARY_ADD` - сложить два верхних значения стека
8. `STORE_NAME z` - сохранить результат в z
9. И так далее...

## Многопоточность и параллелизм

### Процесс vs Поток

**Процесс** - изолированный экземпляр программы со своей памятью.

**Поток** - единица выполнения внутри процесса, разделяющая память с другими потоками.

```
┌─────────────────────────────────────────┐
│               Процесс                    │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐    │
│  │ Поток 1 │ │ Поток 2 │ │ Поток 3 │    │
│  └─────────┘ └─────────┘ └─────────┘    │
│                                          │
│           Общая память                   │
└─────────────────────────────────────────┘
```

### GIL (Global Interpreter Lock) в Python

**GIL** - механизм в CPython, который позволяет выполняться только одному потоку Python-кода одновременно.

```python
import threading

# Эти потоки не будут реально параллельными для CPU-задач
thread1 = threading.Thread(target=cpu_intensive_task)
thread2 = threading.Thread(target=cpu_intensive_task)
```

Для параллельных вычислений в Python используют:
- `multiprocessing` - отдельные процессы
- `concurrent.futures.ProcessPoolExecutor`
- Библиотеки без GIL (NumPy, Cython)

## Резюме

1. **Исходный код** проходит через лексер, парсер, семантический анализ
2. **CPU** выполняет машинные инструкции по циклу Fetch-Decode-Execute
3. **Память** организована иерархически (регистры -> кеш -> RAM -> диск)
4. **Стек вызовов** отслеживает выполнение функций (LIFO)
5. **Куча** используется для динамического выделения памяти
6. **Runtime** предоставляет среду выполнения (GC, стандартная библиотека)
7. **Сборщик мусора** автоматически освобождает неиспользуемую память
