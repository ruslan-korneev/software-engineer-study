# Bits and Bytes (Биты и байты)

## Определение

**Бит (bit)** — минимальная единица информации в вычислительной технике. Может принимать только два значения: 0 или 1.

**Байт (byte)** — группа из 8 бит. Это стандартная единица измерения данных и адресации памяти в современных компьютерах.

```
1 байт = 8 бит

Пример байта: 01101010 (8 бит)
```

## Почему именно 8 бит в байте?

Исторически размер байта варьировался (6, 7, 9 бит), но 8 бит стал стандартом, потому что:
- Достаточно для представления символа (256 вариантов для ASCII)
- Удобная степень двойки (2³ = 8)
- Ровно 2 hex-цифры
- Исторически закрепился в IBM System/360 (1964)

## Единицы измерения данных

### Стандартные единицы (степени 10)

| Единица | Аббревиатура | Размер в байтах |
|---------|--------------|-----------------|
| Килобайт | KB (kB) | 1,000 = 10³ |
| Мегабайт | MB | 1,000,000 = 10⁶ |
| Гигабайт | GB | 1,000,000,000 = 10⁹ |
| Терабайт | TB | 10¹² |
| Петабайт | PB | 10¹⁵ |

### Двоичные единицы (степени 2, стандарт IEC)

| Единица | Аббревиатура | Размер в байтах |
|---------|--------------|-----------------|
| Кибибайт | KiB | 1,024 = 2¹⁰ |
| Мебибайт | MiB | 1,048,576 = 2²⁰ |
| Гибибайт | GiB | 1,073,741,824 = 2³⁰ |
| Тебибайт | TiB | 2⁴⁰ |
| Пебибайт | PiB | 2⁵⁰ |

### Путаница в терминологии

```
На практике часто путают KB и KiB:

- Производители HDD/SSD: используют KB/GB (степени 10) — диск "больше"
- ОС и программы: часто используют KiB/GiB (степени 2)

Результат: "500 GB" диск показывается как ~465 GiB в Windows

500 GB = 500,000,000,000 байт
       = 500,000,000,000 / 1,073,741,824 ≈ 465.66 GiB
```

## Полубайт (Nibble)

**Nibble (ниббл)** — 4 бита, половина байта. Соответствует одной шестнадцатеричной цифре.

```
1 байт = 2 нибла
0xF5 = 1111 0101
       ───┬ ───┬
        F    5
       high low
       nibble nibble
```

## Слово (Word)

**Слово** — это количество бит, которое процессор обрабатывает за одну операцию. Размер зависит от архитектуры:

| Архитектура | Размер слова |
|-------------|--------------|
| 8-bit (8080, Z80) | 1 байт |
| 16-bit (8086) | 2 байта |
| 32-bit (x86) | 4 байта |
| 64-bit (x86-64, ARM64) | 8 байт |

## Порядок байтов (Endianness)

При хранении многобайтовых чисел важен **порядок байтов**:

### Big Endian (BE)
Старший байт первым. "Большой конец" — самый значимый байт по младшему адресу.

### Little Endian (LE)
Младший байт первым. "Маленький конец" — наименее значимый байт по младшему адресу.

```
Число: 0x12345678

Big Endian (сетевой порядок):
Адрес:  0x00  0x01  0x02  0x03
Байт:   0x12  0x34  0x56  0x78

Little Endian (x86, x86-64):
Адрес:  0x00  0x01  0x02  0x03
Байт:   0x78  0x56  0x34  0x12
```

### Примеры на Python

```python
import struct

num = 0x12345678

# Big Endian
be_bytes = num.to_bytes(4, byteorder='big')
print(be_bytes.hex())  # '12345678'

# Little Endian
le_bytes = num.to_bytes(4, byteorder='little')
print(le_bytes.hex())  # '78563412'

# Обратное преобразование
print(int.from_bytes(be_bytes, byteorder='big'))    # 305419896
print(int.from_bytes(le_bytes, byteorder='little')) # 305419896

# Определение порядка байтов системы
import sys
print(sys.byteorder)  # 'little' на x86/x86-64
```

## Битовые операции

### AND (И) — `&`
```python
0b1010 & 0b1100 = 0b1000  # 10 & 12 = 8

# Применение: маскирование битов
flags = 0b11010110
mask  = 0b00001111
result = flags & mask  # 0b00000110 — оставляем только младшие 4 бита
```

### OR (ИЛИ) — `|`
```python
0b1010 | 0b1100 = 0b1110  # 10 | 12 = 14

# Применение: установка битов
flags = 0b00000001
flags |= 0b00000100  # Устанавливаем бит 2
# flags = 0b00000101
```

### XOR (Исключающее ИЛИ) — `^`
```python
0b1010 ^ 0b1100 = 0b0110  # 10 ^ 12 = 6

# Применение: переключение битов, шифрование
data = 0b11001010
key  = 0b10101010
encrypted = data ^ key   # 0b01100000
decrypted = encrypted ^ key  # 0b11001010 (исходные данные)
```

### NOT (НЕ) — `~`
```python
~0b00001111 = 0b...11110000  # Инверсия всех битов

# В Python (для 8-битного представления):
x = 0b00001111
print(bin(~x & 0xFF))  # '0b11110000'
```

### Сдвиги

```python
# Левый сдвиг (умножение на 2^n)
0b00001010 << 2 = 0b00101000  # 10 << 2 = 40

# Правый сдвиг (деление на 2^n)
0b00101000 >> 2 = 0b00001010  # 40 >> 2 = 10

# Быстрое умножение/деление на степени двойки
x = 5
print(x << 3)  # 40 (5 * 8)
print(x << 4)  # 80 (5 * 16)
```

## Битовые флаги

Эффективный способ хранения множества булевых значений:

```python
# Определяем флаги как степени двойки
READ    = 0b001  # 1
WRITE   = 0b010  # 2
EXECUTE = 0b100  # 4

# Комбинируем флаги
permissions = READ | WRITE  # 0b011 = 3

# Проверяем флаг
if permissions & READ:
    print("Можно читать")

if permissions & EXECUTE:
    print("Можно выполнять")  # Не выведется

# Добавляем флаг
permissions |= EXECUTE  # 0b111 = 7

# Убираем флаг
permissions &= ~WRITE  # 0b101 = 5

# Переключаем флаг
permissions ^= READ  # 0b100 = 4
```

### Реальный пример: Unix permissions

```bash
chmod 755 file.txt
```

```
7 = 111₂ = rwx (owner)
5 = 101₂ = r-x (group)
5 = 101₂ = r-x (others)
```

## Выравнивание и padding

Процессоры эффективнее работают с выровненными данными:

```python
import struct

# Структура без выравнивания (packed)
packed = struct.pack('=BIH', 1, 2, 3)  # 1 + 4 + 2 = 7 байт
print(len(packed))  # 7

# С учётом выравнивания (native)
native = struct.pack('@BIH', 1, 2, 3)
print(len(native))  # Может быть больше из-за padding
```

## Размеры типов данных

```python
import struct
import sys

# Размеры в байтах
print(struct.calcsize('b'))  # 1 — signed char
print(struct.calcsize('h'))  # 2 — short
print(struct.calcsize('i'))  # 4 — int
print(struct.calcsize('q'))  # 8 — long long
print(struct.calcsize('f'))  # 4 — float
print(struct.calcsize('d'))  # 8 — double
print(struct.calcsize('P'))  # 8 — pointer (на 64-bit)

# Размер int в Python
print(sys.getsizeof(0))     # ~28 байт (объект Python)
print(sys.getsizeof(2**100)) # Больше (big integer)
```

## Best Practices

1. **Используйте побитовые операции для флагов** — компактно и быстро
2. **Учитывайте endianness при сетевом программировании** — сеть использует Big Endian
3. **Знайте размеры типов** — важно для бинарных протоколов и сериализации
4. **Используйте сдвиги для умножения/деления на степени 2** — быстрее обычных операций
5. **Предпочитайте KiB/MiB/GiB** для точности в документации

```python
# Сетевой порядок байтов
import socket

# Преобразование host byte order <-> network byte order
host_short = 0x1234
network_short = socket.htons(host_short)  # host to network short
back_to_host = socket.ntohs(network_short)  # network to host short
```

## Связь с другими темами

- **Двоичная система** — биты как основа
- **Шестнадцатеричная система** — удобное представление байтов
- **Кодировки** — байты как представление символов
- **Структуры данных** — выравнивание в памяти
