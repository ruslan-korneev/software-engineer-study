# Hexadecimal (Шестнадцатеричная система счисления)

## Определение

**Шестнадцатеричная система счисления** (hex) — это позиционная система счисления с основанием 16. Использует 16 символов: цифры **0-9** и буквы **A-F** (или a-f), где A=10, B=11, C=12, D=13, E=14, F=15.

## Зачем нужна шестнадцатеричная система?

Шестнадцатеричная система — это **удобный способ записи двоичных данных**:
- 1 hex-цифра = ровно 4 бита (полубайт, nibble)
- 2 hex-цифры = 1 байт (8 бит)
- Компактнее двоичной записи в 4 раза
- Легко переводится в двоичную и обратно

```
Двоичная:           1111 1010 0011 1100
Шестнадцатеричная:    F    A    3    C  = 0xFA3C
Десятичная:         64060
```

## Таблица соответствия

| Hex | Decimal | Binary |
|-----|---------|--------|
| 0   | 0       | 0000   |
| 1   | 1       | 0001   |
| 2   | 2       | 0010   |
| 3   | 3       | 0011   |
| 4   | 4       | 0100   |
| 5   | 5       | 0101   |
| 6   | 6       | 0110   |
| 7   | 7       | 0111   |
| 8   | 8       | 1000   |
| 9   | 9       | 1001   |
| A   | 10      | 1010   |
| B   | 11      | 1011   |
| C   | 12      | 1100   |
| D   | 13      | 1101   |
| E   | 14      | 1110   |
| F   | 15      | 1111   |

## Обозначения в разных языках

| Язык/контекст | Префикс/формат | Пример |
|---------------|----------------|--------|
| C, C++, Python, Java | `0x` | `0xFF` |
| HTML/CSS | `#` | `#FF5733` |
| Assembly | `h` суффикс | `FFh` |
| URL encoding | `%` | `%20` |
| Unicode | `U+` | `U+0041` |

## Перевод из hex в десятичную систему

Умножаем каждую цифру на 16 в степени её позиции:

```
2AF₁₆ = 2×16² + A×16¹ + F×16⁰
      = 2×256 + 10×16 + 15×1
      = 512 + 160 + 15
      = 687₁₀
```

**Ещё примеры:**
```
FF₁₆   = 15×16 + 15 = 255₁₀
100₁₆  = 1×256 + 0 + 0 = 256₁₀
FFFF₁₆ = 65535₁₀
```

## Перевод из десятичной в hex

**Метод деления на 16:**

```
687 ÷ 16 = 42, остаток 15 (F)
42  ÷ 16 = 2,  остаток 10 (A)
2   ÷ 16 = 0,  остаток 2

Результат: 687₁₀ = 2AF₁₆ (читаем снизу вверх)
```

## Перевод между hex и binary

Это самый простой перевод — каждая hex-цифра соответствует ровно 4 битам:

```
Hex → Binary:
0xCAFE → C    A    F    E
       → 1100 1010 1111 1110

Binary → Hex:
1011 0111 0010 1001 → B729
```

**Важно:** группируем биты справа налево по 4, при необходимости добавляя ведущие нули.

## Примеры на Python

```python
# Перевод в hex
print(hex(255))        # '0xff'
print(hex(256))        # '0x100'
print(hex(65535))      # '0xffff'

# Перевод из hex в десятичную
print(int('ff', 16))   # 255
print(int('0xff', 16)) # 255
print(int('CAFE', 16)) # 51966

# Hex-литералы
x = 0xFF      # 255
y = 0xCAFE    # 51966
z = 0xDEADBEEF  # 3735928559 (популярная "магическая" константа)

# Форматирование
num = 255
print(f"{num:x}")      # 'ff' (нижний регистр)
print(f"{num:X}")      # 'FF' (верхний регистр)
print(f"{num:04x}")    # '00ff' (с ведущими нулями)
print(f"{num:#x}")     # '0xff' (с префиксом)

# Работа с байтами
data = bytes([0xDE, 0xAD, 0xBE, 0xEF])
print(data.hex())      # 'deadbeef'
print(bytes.fromhex('cafebabe'))  # b'\xca\xfe\xba\xbe'
```

## Практические применения

### 1. Цвета (RGB/RGBA)

```
#FF5733 — оранжевый цвет
│  │  │
│  │  └─ Blue:  0x33 = 51
│  └──── Green: 0x57 = 87
└─────── Red:   0xFF = 255

#00000080 — чёрный с 50% прозрачностью (RGBA)
```

```python
# Разбор цвета
color = 0xFF5733
red   = (color >> 16) & 0xFF  # 255
green = (color >> 8) & 0xFF   # 87
blue  = color & 0xFF          # 51
```

### 2. MAC-адреса

```
AA:BB:CC:DD:EE:FF — 6 байт, записанных в hex
```

### 3. Хеши и криптография

```
MD5:    d41d8cd98f00b204e9800998ecf8427e (32 hex = 128 бит)
SHA-1:  da39a3ee5e6b4b0d3255bfef95601890afd80709 (40 hex = 160 бит)
SHA-256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
```

### 4. UUID

```
550e8400-e29b-41d4-a716-446655440000
```

### 5. Адреса памяти

```python
x = [1, 2, 3]
print(hex(id(x)))  # '0x7f8b8c0a1d40' — адрес объекта в памяти
```

### 6. Escape-последовательности

```python
# Непечатаемые символы
print("\x00")  # NULL байт
print("\x1b")  # ESC (escape)
print("\x0a")  # LF (line feed) = \n
```

## Магические числа (Magic Numbers)

Hex удобен для создания запоминающихся констант:

| Hex | Чтение | Использование |
|-----|--------|---------------|
| `0xDEADBEEF` | "dead beef" | Отладка, маркер памяти |
| `0xCAFEBABE` | "cafe babe" | Заголовок Java class файлов |
| `0xFEEDFACE` | "feed face" | Mach-O файлы (macOS) |
| `0xBAADF00D` | "bad food" | Windows: неинициализированная heap память |
| `0xDEADC0DE` | "dead code" | Маркер мёртвого кода |

```python
# Проверка типа файла по magic number
with open("Example.class", "rb") as f:
    magic = f.read(4)
    if magic == b'\xca\xfe\xba\xbe':
        print("Это Java class файл!")
```

## Арифметика в hex

```
  0x1A3
+ 0x0BC
-------
  0x25F

1A3 + BC = 25F
(419 + 188 = 607)
```

## Best Practices

1. **Используйте hex для байтовых данных** — удобнее и компактнее
2. **Будьте последовательны в регистре** — либо `0xff`, либо `0xFF`
3. **Добавляйте ведущие нули** для выравнивания: `0x0F` вместо `0xF`
4. **Используйте разделители** в длинных числах (где поддерживается): `0xFF_FF_FF_FF`
5. **Помните о порядке байтов** — Little Endian vs Big Endian

```python
# Python 3.6+ поддерживает underscore в числах
large_num = 0xDEAD_BEEF_CAFE_BABE
```

## Связь с другими темами

- **Двоичная система** — hex как компактная запись binary
- **Кодировки** — символы часто представляются в hex (UTF-8, ASCII)
- **Hex-редакторы** — просмотр файлов в шестнадцатеричном виде
