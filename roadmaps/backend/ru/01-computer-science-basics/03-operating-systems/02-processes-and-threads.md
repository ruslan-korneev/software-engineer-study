# Процессы и потоки (Processes and Threads)

## Определение

**Процесс** — это экземпляр выполняющейся программы. Каждый процесс имеет собственное изолированное адресное пространство, ресурсы и состояние.

**Поток (Thread)** — это единица выполнения внутри процесса. Потоки одного процесса разделяют общее адресное пространство и ресурсы, но имеют собственный стек и регистры.

## Процесс (Process)

### Структура процесса

```
┌──────────────────────────────────────┐
│              Процесс                 │
├──────────────────────────────────────┤
│  Text (Code) – исполняемый код       │
├──────────────────────────────────────┤
│  Data – глобальные переменные        │
├──────────────────────────────────────┤
│  Heap – динамическая память          │
│         ↓ (растёт вниз)              │
│                                      │
│         ↑ (растёт вверх)             │
│  Stack – локальные переменные        │
├──────────────────────────────────────┤
│  PCB (Process Control Block)         │
│  - PID, состояние, регистры          │
│  - указатели на ресурсы              │
└──────────────────────────────────────┘
```

### Состояния процесса

```
         ┌─────────────┐
         │    New      │ ← Создание процесса
         └──────┬──────┘
                ↓
         ┌─────────────┐
    ┌────│   Ready     │←───────────────┐
    │    └──────┬──────┘                │
    │           ↓ (scheduler)           │
    │    ┌─────────────┐                │
    │    │  Running    │────────────────┤ (interrupt/timeout)
    │    └──────┬──────┘                │
    │           │                       │
    │           ↓ (I/O wait)            │
    │    ┌─────────────┐                │
    └────│  Waiting    │────────────────┘ (I/O complete)
         └──────┬──────┘
                ↓
         ┌─────────────┐
         │ Terminated  │ → Завершение
         └─────────────┘
```

### Создание процессов в Unix/Linux

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();  // Создание дочернего процесса

    if (pid < 0) {
        // Ошибка при создании процесса
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // Дочерний процесс
        printf("Child process, PID: %d\n", getpid());
        execlp("ls", "ls", "-l", NULL);  // Замена образа процесса
    } else {
        // Родительский процесс
        printf("Parent process, PID: %d, Child PID: %d\n", getpid(), pid);
        wait(NULL);  // Ожидание завершения дочернего процесса
    }

    return 0;
}
```

### Просмотр процессов в командной строке

```bash
# Список всех процессов
ps aux

# Иерархия процессов (дерево)
ps axjf
# или
pstree

# Интерактивный мониторинг
top
htop  # более удобный вариант

# Информация о конкретном процессе
ps -p <PID> -o pid,ppid,cmd,%mem,%cpu

# Процессы текущего пользователя
ps -u $USER
```

## Потоки (Threads)

### Модель потоков

```
┌────────────────────────────────────────────────────────┐
│                      Процесс                           │
├────────────────────────────────────────────────────────┤
│  Общие ресурсы:                                        │
│  - Адресное пространство (код, данные, heap)           │
│  - Файловые дескрипторы                                │
│  - Сигналы и обработчики                               │
├──────────┬──────────┬──────────┬──────────────────────┤
│  Thread 1│  Thread 2│  Thread 3│                      │
│  ┌──────┐│  ┌──────┐│  ┌──────┐│   Приватные ресурсы: │
│  │Stack ││  │Stack ││  │Stack ││   - Стек             │
│  │──────││  │──────││  │──────││   - Регистры         │
│  │ TID  ││  │ TID  ││  │ TID  ││   - Thread ID        │
│  │Regs  ││  │Regs  ││  │Regs  ││   - Состояние        │
│  └──────┘│  └──────┘│  └──────┘│                      │
└──────────┴──────────┴──────────┴──────────────────────┘
```

### Преимущества потоков над процессами

| Характеристика | Процессы | Потоки |
|----------------|----------|--------|
| Создание | Медленное (копирование памяти) | Быстрое |
| Переключение контекста | Дорогое | Дешёвое |
| Изоляция | Полная | Общая память |
| Обмен данными | Через IPC (сложнее) | Через общую память (проще) |
| Падение | Не влияет на другие процессы | Может убить весь процесс |

### Работа с потоками в Python

```python
import threading
import time

def worker(name, delay):
    """Функция, выполняемая в потоке"""
    print(f"Thread {name} starting")
    time.sleep(delay)
    print(f"Thread {name} finished")

# Создание потоков
threads = []
for i in range(3):
    t = threading.Thread(target=worker, args=(f"Worker-{i}", i + 1))
    threads.append(t)
    t.start()

# Ожидание завершения всех потоков
for t in threads:
    t.join()

print("All threads completed")
```

### Работа с потоками в C (POSIX Threads)

```c
#include <pthread.h>
#include <stdio.h>

void* thread_function(void* arg) {
    int id = *(int*)arg;
    printf("Thread %d is running\n", id);
    return NULL;
}

int main() {
    pthread_t threads[3];
    int thread_ids[3] = {1, 2, 3};

    // Создание потоков
    for (int i = 0; i < 3; i++) {
        pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]);
    }

    // Ожидание завершения
    for (int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("All threads finished\n");
    return 0;
}
```

## Планирование процессов (Scheduling)

### Алгоритмы планирования

#### 1. FCFS (First-Come, First-Served)
- Процессы выполняются в порядке поступления
- Простой, но может вызывать "convoy effect"

#### 2. SJF (Shortest Job First)
- Сначала выполняются короткие задачи
- Оптимален по среднему времени ожидания
- Требует знания времени выполнения заранее

#### 3. Round Robin
- Каждому процессу выделяется квант времени
- По истечении кванта — переключение на следующий
- Хорош для интерактивных систем

```
Процесс A: ████████████████
Процесс B:     ████████████████
Процесс C:         ████████████████

Квант = 4 единицы времени
Выполнение: A→B→C→A→B→C→A→B→C...
```

#### 4. Priority Scheduling
- Процессы с высшим приоритетом выполняются первыми
- Может привести к "голоданию" (starvation)

### Просмотр приоритетов в Linux

```bash
# Просмотр приоритета процессов (nice value)
ps -l

# Запуск с пониженным приоритетом
nice -n 10 ./my_program

# Изменение приоритета работающего процесса
renice -n 5 -p <PID>

# Просмотр политики планирования
chrt -p <PID>
```

## Межпроцессное взаимодействие (IPC)

### Способы IPC

| Механизм | Описание | Применение |
|----------|----------|------------|
| **Pipe** | Однонаправленный поток данных | Связь родитель-потомок |
| **Named Pipe (FIFO)** | Именованный канал | Несвязанные процессы |
| **Message Queue** | Очередь сообщений | Асинхронный обмен |
| **Shared Memory** | Общая память | Быстрый обмен большими данными |
| **Semaphore** | Счётчик для синхронизации | Контроль доступа к ресурсам |
| **Socket** | Сетевое взаимодействие | Межсетевой/локальный обмен |
| **Signal** | Асинхронные уведомления | Обработка событий |

### Пример использования pipe в Python

```python
import os

# Создание pipe
read_fd, write_fd = os.pipe()

pid = os.fork()

if pid == 0:
    # Дочерний процесс — читает
    os.close(write_fd)
    message = os.read(read_fd, 100).decode()
    print(f"Child received: {message}")
    os.close(read_fd)
else:
    # Родительский процесс — пишет
    os.close(read_fd)
    os.write(write_fd, b"Hello from parent!")
    os.close(write_fd)
    os.wait()
```

## Синхронизация потоков

### Проблемы многопоточности
- **Race Condition** — результат зависит от порядка выполнения
- **Deadlock** — взаимная блокировка потоков
- **Starvation** — поток не получает ресурс

### Механизмы синхронизации

```python
import threading

# Mutex (Lock)
lock = threading.Lock()
counter = 0

def increment():
    global counter
    with lock:  # Автоматически захватывает и освобождает lock
        counter += 1

# Semaphore — ограничение числа одновременных доступов
semaphore = threading.Semaphore(3)  # Максимум 3 потока одновременно

def limited_access():
    with semaphore:
        # Критическая секция
        pass

# Event — сигнализация между потоками
event = threading.Event()

def waiter():
    event.wait()  # Блокируется до установки события
    print("Event received!")

def setter():
    event.set()  # Разблокирует ожидающие потоки
```

## Best Practices

### Для процессов
1. **Используйте процессы для изоляции** — падение одного не повлияет на другие
2. **Минимизируйте IPC** — межпроцессное взаимодействие дорогое
3. **Обрабатывайте сигналы** — корректно завершайте процессы (SIGTERM)
4. **Избегайте зомби-процессов** — вызывайте `wait()` для дочерних процессов

### Для потоков
1. **Минимизируйте shared state** — уменьшает необходимость синхронизации
2. **Используйте потокобезопасные структуры** — Queue вместо list
3. **Избегайте deadlocks** — всегда захватывайте lock'и в одном порядке
4. **Учитывайте GIL в Python** — для CPU-bound задач используйте multiprocessing

```python
# Правильно: потокобезопасная очередь
from queue import Queue
from threading import Thread

def producer(queue):
    for i in range(5):
        queue.put(i)

def consumer(queue):
    while True:
        item = queue.get()
        if item is None:
            break
        print(f"Consumed: {item}")
        queue.task_done()

queue = Queue()
producer_thread = Thread(target=producer, args=(queue,))
consumer_thread = Thread(target=consumer, args=(queue,))

producer_thread.start()
consumer_thread.start()

producer_thread.join()
queue.put(None)  # Сигнал завершения
consumer_thread.join()
```

## Заключение

Понимание процессов и потоков критически важно для:
- Разработки многопоточных приложений
- Оптимизации производительности
- Отладки проблем конкурентности
- Правильного проектирования серверных приложений

Для backend-разработчика особенно важно понимать модели параллелизма веб-серверов (fork, prefork, threaded, async).
