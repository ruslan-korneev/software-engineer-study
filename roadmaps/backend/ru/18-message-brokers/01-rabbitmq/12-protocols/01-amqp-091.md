# AMQP 0-9-1

## Введение

**AMQP 0-9-1** (Advanced Message Queuing Protocol) — это основной протокол, который используется RabbitMQ. Это бинарный протокол прикладного уровня, разработанный для передачи сообщений между приложениями. RabbitMQ изначально создавался как реализация именно этого протокола.

## Основные концепции AMQP 0-9-1

### Модель сообщений

AMQP 0-9-1 определяет программируемую модель брокера сообщений:

```
Publisher → Exchange → Binding → Queue → Consumer
```

**Ключевые сущности:**
- **Exchange** — точка входа для сообщений, определяет маршрутизацию
- **Queue** — буфер для хранения сообщений
- **Binding** — связь между exchange и queue с routing key
- **Connection** — TCP-соединение с брокером
- **Channel** — логический канал внутри соединения

### Типы Exchange

| Тип | Описание | Использование |
|-----|----------|---------------|
| `direct` | Точное совпадение routing key | Прямая маршрутизация |
| `fanout` | Рассылка всем привязанным очередям | Broadcast |
| `topic` | Паттерны с `*` и `#` | Гибкая маршрутизация |
| `headers` | Маршрутизация по заголовкам | Сложная логика |

## Структура протокола

### Иерархия AMQP

```
Connection (TCP)
  └── Channel (логический канал)
        └── Methods (команды протокола)
              └── Content (заголовки + тело сообщения)
```

### Frames (Фреймы)

Все данные в AMQP 0-9-1 передаются через фреймы. Каждый фрейм имеет следующую структуру:

```
+----------+----------+----------+-------------------+----------+
| Type (1) | Channel  | Size (4) |     Payload       | End (1)  |
|  byte    | (2 bytes)|  bytes   |   (variable)      |  0xCE    |
+----------+----------+----------+-------------------+----------+
```

**Типы фреймов:**

1. **Method Frame (Type = 1)** — команды протокола
2. **Header Frame (Type = 2)** — метаданные сообщения
3. **Body Frame (Type = 3)** — содержимое сообщения
4. **Heartbeat Frame (Type = 8)** — проверка соединения

### Method Frame

Содержит AMQP методы (команды):

```
+----------+----------+-------------------+
| Class ID | Method ID|    Arguments      |
| (2 bytes)| (2 bytes)|    (variable)     |
+----------+----------+-------------------+
```

**Примеры классов и методов:**

| Класс | Методы |
|-------|--------|
| `connection` | start, start-ok, tune, tune-ok, open, close |
| `channel` | open, close, flow |
| `exchange` | declare, delete, bind |
| `queue` | declare, bind, unbind, purge, delete |
| `basic` | publish, consume, deliver, ack, nack, reject |
| `tx` | select, commit, rollback |

## Процесс подключения

### Handshake (Рукопожатие)

```
Client                              Server
  |                                    |
  |-------- Protocol Header ---------->|
  |<------- Connection.Start ----------|
  |-------- Connection.Start-OK ------>|
  |<------- Connection.Tune -----------|
  |-------- Connection.Tune-OK ------->|
  |-------- Connection.Open ---------->|
  |<------- Connection.Open-OK --------|
  |                                    |
  |-------- Channel.Open ------------->|
  |<------- Channel.Open-OK -----------|
```

### Protocol Header

Первые 8 байт при подключении:

```
+------+------+------+------+------+------+------+------+
| 'A'  | 'M'  | 'Q'  | 'P'  |  0   |  0   |  9   |  1   |
+------+------+------+------+------+------+------+------+
```

## Примеры кода

### Python (pika)

```python
import pika

# Подключение к RabbitMQ
credentials = pika.PlainCredentials('guest', 'guest')
parameters = pika.ConnectionParameters(
    host='localhost',
    port=5672,  # Стандартный порт AMQP
    virtual_host='/',
    credentials=credentials,
    heartbeat=60,
    blocked_connection_timeout=300
)

connection = pika.BlockingConnection(parameters)
channel = connection.channel()

# Объявление exchange
channel.exchange_declare(
    exchange='my_exchange',
    exchange_type='direct',
    durable=True
)

# Объявление очереди
channel.queue_declare(
    queue='my_queue',
    durable=True,
    arguments={
        'x-message-ttl': 60000,
        'x-max-length': 10000
    }
)

# Привязка очереди к exchange
channel.queue_bind(
    exchange='my_exchange',
    queue='my_queue',
    routing_key='my_routing_key'
)

# Публикация сообщения
channel.basic_publish(
    exchange='my_exchange',
    routing_key='my_routing_key',
    body='Hello, AMQP 0-9-1!',
    properties=pika.BasicProperties(
        delivery_mode=2,  # Persistent
        content_type='text/plain',
        headers={'custom-header': 'value'}
    )
)

# Потребление сообщений
def callback(ch, method, properties, body):
    print(f"Получено: {body.decode()}")
    ch.basic_ack(delivery_tag=method.delivery_tag)

channel.basic_consume(
    queue='my_queue',
    on_message_callback=callback,
    auto_ack=False
)

channel.start_consuming()
```

### Node.js (amqplib)

```javascript
const amqp = require('amqplib');

async function main() {
    // Подключение
    const connection = await amqp.connect({
        protocol: 'amqp',
        hostname: 'localhost',
        port: 5672,
        username: 'guest',
        password: 'guest',
        vhost: '/',
        heartbeat: 60
    });

    const channel = await connection.createChannel();

    // Объявление exchange и очереди
    await channel.assertExchange('my_exchange', 'direct', { durable: true });
    await channel.assertQueue('my_queue', {
        durable: true,
        arguments: {
            'x-message-ttl': 60000
        }
    });
    await channel.bindQueue('my_queue', 'my_exchange', 'my_routing_key');

    // Публикация
    channel.publish(
        'my_exchange',
        'my_routing_key',
        Buffer.from('Hello, AMQP!'),
        {
            persistent: true,
            contentType: 'text/plain'
        }
    );

    // Потребление
    channel.consume('my_queue', (msg) => {
        if (msg) {
            console.log('Получено:', msg.content.toString());
            channel.ack(msg);
        }
    });
}

main().catch(console.error);
```

### Go (amqp091-go)

```go
package main

import (
    "log"
    amqp "github.com/rabbitmq/amqp091-go"
)

func main() {
    // Подключение
    conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()

    ch, err := conn.Channel()
    if err != nil {
        log.Fatal(err)
    }
    defer ch.Close()

    // Объявление exchange
    err = ch.ExchangeDeclare(
        "my_exchange", // name
        "direct",      // type
        true,          // durable
        false,         // auto-deleted
        false,         // internal
        false,         // no-wait
        nil,           // arguments
    )
    if err != nil {
        log.Fatal(err)
    }

    // Объявление очереди
    q, err := ch.QueueDeclare(
        "my_queue", // name
        true,       // durable
        false,      // delete when unused
        false,      // exclusive
        false,      // no-wait
        nil,        // arguments
    )
    if err != nil {
        log.Fatal(err)
    }

    // Привязка
    err = ch.QueueBind(
        q.Name,           // queue name
        "my_routing_key", // routing key
        "my_exchange",    // exchange
        false,
        nil,
    )
    if err != nil {
        log.Fatal(err)
    }

    // Публикация
    err = ch.Publish(
        "my_exchange",
        "my_routing_key",
        false,
        false,
        amqp.Publishing{
            DeliveryMode: amqp.Persistent,
            ContentType:  "text/plain",
            Body:         []byte("Hello, AMQP!"),
        },
    )
    if err != nil {
        log.Fatal(err)
    }

    log.Println("Сообщение отправлено")
}
```

## Подтверждения (Acknowledgements)

### Consumer Acknowledgements

```python
# Manual acknowledgement
channel.basic_ack(delivery_tag=method.delivery_tag)

# Отклонение без requeue
channel.basic_reject(delivery_tag=method.delivery_tag, requeue=False)

# Negative acknowledgement с requeue
channel.basic_nack(delivery_tag=method.delivery_tag, requeue=True)
```

### Publisher Confirms

```python
channel.confirm_delivery()

try:
    channel.basic_publish(
        exchange='my_exchange',
        routing_key='my_key',
        body='message',
        mandatory=True
    )
    print("Сообщение подтверждено брокером")
except pika.exceptions.UnroutableError:
    print("Сообщение не доставлено")
```

## Свойства сообщений

AMQP 0-9-1 определяет стандартные свойства сообщений:

| Свойство | Тип | Описание |
|----------|-----|----------|
| `content-type` | string | MIME-тип содержимого |
| `content-encoding` | string | Кодировка содержимого |
| `headers` | table | Пользовательские заголовки |
| `delivery-mode` | integer | 1 = non-persistent, 2 = persistent |
| `priority` | integer | Приоритет (0-9) |
| `correlation-id` | string | ID для корреляции запрос/ответ |
| `reply-to` | string | Очередь для ответа |
| `expiration` | string | TTL сообщения (мс) |
| `message-id` | string | Уникальный ID сообщения |
| `timestamp` | timestamp | Время создания |
| `type` | string | Тип сообщения |
| `user-id` | string | ID пользователя |
| `app-id` | string | ID приложения |

## QoS (Quality of Service)

```python
# Prefetch — количество сообщений, которые consumer может получить
# до отправки acknowledgement
channel.basic_qos(
    prefetch_size=0,    # Размер в байтах (0 = без ограничения)
    prefetch_count=10,  # Количество сообщений
    global=False        # False = per consumer, True = per channel
)
```

## Когда использовать AMQP 0-9-1

**Преимущества:**
- Полная функциональность RabbitMQ
- Программируемая модель брокера
- Гибкая маршрутизация сообщений
- Поддержка транзакций
- Широкая поддержка библиотек

**Используйте, когда:**
- Нужна сложная маршрутизация сообщений
- Требуется полный контроль над брокером
- Работаете с экосистемой RabbitMQ
- Нужны все возможности: exchanges, bindings, TTL, DLX

**Ограничения:**
- Более сложный, чем другие протоколы
- Не является стандартом ISO/OASIS (в отличие от AMQP 1.0)
- Специфичен для RabbitMQ-подобных брокеров

## Порты

| Порт | Назначение |
|------|------------|
| 5672 | AMQP без шифрования |
| 5671 | AMQP с TLS/SSL |

## Заключение

AMQP 0-9-1 — это мощный и гибкий протокол, который предоставляет полный контроль над messaging-инфраструктурой. Понимание его структуры (фреймы, методы, классы) помогает эффективно использовать RabbitMQ и отлаживать проблемы с подключением и передачей сообщений.
