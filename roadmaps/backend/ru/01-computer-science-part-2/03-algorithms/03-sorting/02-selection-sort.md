# Сортировка выбором (Selection Sort)

## Определение

**Сортировка выбором** — это алгоритм сортировки, который делит массив на две части: отсортированную (в начале) и неотсортированную. На каждой итерации алгоритм находит минимальный элемент в неотсортированной части и перемещает его в конец отсортированной части.

## Зачем нужен

### Области применения:
- **Образовательные цели** — легко понять и визуализировать
- **Минимизация записей** — делает O(n) обменов (меньше, чем Bubble Sort)
- **Маленькие массивы** — простота реализации
- **Память — критический ресурс** — работает in-place

### Преимущества:
- Простота понимания и реализации
- Минимальное количество обменов — O(n)
- In-place сортировка — O(1) дополнительной памяти
- Предсказуемая производительность — всегда O(n^2)

### Недостатки:
- Медленный O(n^2) для любых данных
- **Нестабильная** сортировка (может изменить порядок равных элементов)
- Не адаптивный — не использует преимущества частично отсортированных данных

## Как работает

### Визуализация процесса

```
Исходный массив: [64, 25, 12, 22, 11]

Итерация 1: Найти минимум в [64, 25, 12, 22, 11]
            Минимум = 11 (индекс 4)
            Меняем с позицией 0
[11 | 25, 12, 22, 64]
 ✓

Итерация 2: Найти минимум в [25, 12, 22, 64]
            Минимум = 12 (индекс 2)
            Меняем с позицией 1
[11, 12 | 25, 22, 64]
 ✓   ✓

Итерация 3: Найти минимум в [25, 22, 64]
            Минимум = 22 (индекс 3)
            Меняем с позицией 2
[11, 12, 22 | 25, 64]
 ✓   ✓   ✓

Итерация 4: Найти минимум в [25, 64]
            Минимум = 25 (индекс 3)
            Меняем с позицией 3 (сам с собой)
[11, 12, 22, 25 | 64]
 ✓   ✓   ✓   ✓

Результат: [11, 12, 22, 25, 64]
```

### Схема работы

```
Отсортированная часть  |  Неотсортированная часть
                       |
[                      |  64, 25, 12, 22, 11]  ← Ищем min (11)
[11                    |  25, 12, 22, 64]      ← Ищем min (12)
[11, 12                |  25, 22, 64]          ← Ищем min (22)
[11, 12, 22            |  25, 64]              ← Ищем min (25)
[11, 12, 22, 25        |  64]                  ← Ищем min (64)
[11, 12, 22, 25, 64    |  ]                    ← Готово!
```

## Псевдокод

```
function selectionSort(array):
    n = length(array)

    for i from 0 to n-2:
        # Находим индекс минимального элемента
        min_index = i

        for j from i+1 to n-1:
            if array[j] < array[min_index]:
                min_index = j

        # Меняем местами, если нашли меньший элемент
        if min_index != i:
            swap(array[i], array[min_index])

    return array
```

### Реализация на Python

```python
def selection_sort(arr):
    """Сортировка выбором."""
    n = len(arr)

    for i in range(n - 1):
        # Предполагаем, что минимум — текущий элемент
        min_idx = i

        # Ищем минимум в оставшейся части
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j

        # Меняем местами, если нашли меньший
        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]

    return arr
```

### Сортировка по убыванию (выбор максимума)

```python
def selection_sort_descending(arr):
    """Сортировка выбором по убыванию."""
    n = len(arr)

    for i in range(n - 1):
        max_idx = i

        for j in range(i + 1, n):
            if arr[j] > arr[max_idx]:
                max_idx = j

        if max_idx != i:
            arr[i], arr[max_idx] = arr[max_idx], arr[i]

    return arr
```

### Двойная сортировка выбором (оптимизация)

```python
def double_selection_sort(arr):
    """
    Одновременно ищет минимум и максимум.
    Сокращает количество итераций вдвое.
    """
    n = len(arr)
    left, right = 0, n - 1

    while left < right:
        min_idx = left
        max_idx = right

        for i in range(left, right + 1):
            if arr[i] < arr[min_idx]:
                min_idx = i
            if arr[i] > arr[max_idx]:
                max_idx = i

        # Ставим минимум в начало
        arr[left], arr[min_idx] = arr[min_idx], arr[left]

        # Корректируем max_idx, если он указывал на left
        if max_idx == left:
            max_idx = min_idx

        # Ставим максимум в конец
        arr[right], arr[max_idx] = arr[max_idx], arr[right]

        left += 1
        right -= 1

    return arr
```

### Стабильная версия

```python
def stable_selection_sort(arr):
    """
    Стабильная сортировка выбором.
    Вместо обмена — сдвиг элементов.
    """
    n = len(arr)

    for i in range(n - 1):
        min_idx = i

        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j

        # Вместо обмена — сдвигаем элементы
        min_val = arr[min_idx]
        while min_idx > i:
            arr[min_idx] = arr[min_idx - 1]
            min_idx -= 1
        arr[i] = min_val

    return arr
```

## Анализ сложности

| Случай | Временная сложность | Описание |
|--------|---------------------|----------|
| **Лучший** | O(n^2) | Даже отсортированный массив требует всех сравнений |
| **Средний** | O(n^2) | Случайный порядок |
| **Худший** | O(n^2) | Любой порядок |

| Ресурс | Сложность |
|--------|-----------|
| **Время** | O(n^2) |
| **Память** | O(1) — in-place |
| **Стабильность** | Нет (обычная версия) |

### Количество операций:
- Сравнения: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n^2)
- Обмены: максимум n-1 = O(n) — **преимущество Selection Sort!**

### Сравнение с Bubble Sort:
| Операция | Selection Sort | Bubble Sort |
|----------|---------------|-------------|
| Сравнения | O(n^2) | O(n^2) |
| Обмены | O(n) | O(n^2) |

## Пример с пошаговым разбором

### Сортировка массива [29, 10, 14, 37, 13]

```
Исходный: [29, 10, 14, 37, 13]

Итерация i=0:
  Поиск минимума в [29, 10, 14, 37, 13]
    j=1: 10 < 29, min_idx=1
    j=2: 14 > 10, min_idx=1
    j=3: 37 > 10, min_idx=1
    j=4: 13 > 10, min_idx=1
  Минимум: 10 на позиции 1
  Обмен: arr[0] ↔ arr[1]
  Результат: [10, 29, 14, 37, 13]

Итерация i=1:
  Поиск минимума в [29, 14, 37, 13]
    j=2: 14 < 29, min_idx=2
    j=3: 37 > 14, min_idx=2
    j=4: 13 < 14, min_idx=4
  Минимум: 13 на позиции 4
  Обмен: arr[1] ↔ arr[4]
  Результат: [10, 13, 14, 37, 29]

Итерация i=2:
  Поиск минимума в [14, 37, 29]
    j=3: 37 > 14, min_idx=2
    j=4: 29 > 14, min_idx=2
  Минимум: 14 на позиции 2
  Обмен не нужен (min_idx == i)
  Результат: [10, 13, 14, 37, 29]

Итерация i=3:
  Поиск минимума в [37, 29]
    j=4: 29 < 37, min_idx=4
  Минимум: 29 на позиции 4
  Обмен: arr[3] ↔ arr[4]
  Результат: [10, 13, 14, 29, 37]

Итоговый массив: [10, 13, 14, 29, 37]
```

### Статистика:
- Итераций: 4
- Сравнений: 4 + 3 + 2 + 1 = 10
- Обменов: 3

## Типичные ошибки и Edge Cases

### 1. Нестабильность — проблема с равными элементами

```python
# Selection Sort НЕСТАБИЛЕН!
# Пример: сортировка пар по первому элементу
arr = [(4, 'a'), (3, 'b'), (4, 'c'), (2, 'd')]

# После обычной selection sort порядок (4,'a') и (4,'c') может измениться!
# Используйте stable_selection_sort или другой алгоритм
```

### 2. Пустой массив и массив из одного элемента

```python
def selection_sort_safe(arr):
    if len(arr) <= 1:
        return arr

    n = len(arr)
    for i in range(n - 1):  # n-1, не n!
        # ...
```

### 3. Оптимизация: пропуск обмена сам с собой

```python
def selection_sort_optimized(arr):
    n = len(arr)

    for i in range(n - 1):
        min_idx = i

        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j

        # Не делаем лишний обмен!
        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]

    return arr
```

### 4. Сортировка с пользовательской функцией сравнения

```python
def selection_sort_key(arr, key=lambda x: x):
    """Сортировка с пользовательским ключом."""
    n = len(arr)

    for i in range(n - 1):
        min_idx = i

        for j in range(i + 1, n):
            if key(arr[j]) < key(arr[min_idx]):
                min_idx = j

        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]

    return arr

# Сортировка по длине строки
words = ["apple", "cat", "banana", "dog"]
selection_sort_key(words, key=len)
print(words)  # ['cat', 'dog', 'apple', 'banana']
```

### 5. Изменение исходного массива

```python
# Selection sort изменяет исходный массив!
original = [5, 2, 8, 1]
sorted_arr = selection_sort(original)
print(original)  # [1, 2, 5, 8] — изменён!

# Чтобы сохранить исходный:
original = [5, 2, 8, 1]
sorted_arr = selection_sort(original.copy())
print(original)  # [5, 2, 8, 1] — не изменён
```

### Рекомендации:
1. Используйте Selection Sort, когда количество записей критично (например, flash-память)
2. Помните о нестабильности — для стабильной сортировки используйте другие алгоритмы
3. Для production кода используйте встроенный `sort()`
4. Selection Sort предсказуем — всегда O(n^2), независимо от входных данных
5. Алгоритм прост для отладки и понимания
