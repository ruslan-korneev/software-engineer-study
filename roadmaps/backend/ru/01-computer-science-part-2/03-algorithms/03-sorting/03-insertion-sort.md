# Сортировка вставками (Insertion Sort)

## Определение

**Сортировка вставками** — это алгоритм сортировки, который строит отсортированный массив по одному элементу за раз. На каждой итерации берётся следующий элемент из неотсортированной части и вставляется на правильную позицию в отсортированной части, сдвигая большие элементы вправо.

Аналогия: сортировка карт в руке — вы берёте карты по одной и вставляете каждую на своё место среди уже отсортированных.

## Зачем нужен

### Области применения:
- **Почти отсортированные данные** — очень эффективен, O(n)
- **Маленькие массивы** — один из лучших для n < 10-50
- **Онлайн-сортировка** — может сортировать данные по мере поступления
- **Гибридные алгоритмы** — используется в Timsort, Introsort

### Преимущества:
- Простота реализации
- Стабильная сортировка
- In-place — O(1) дополнительной памяти
- Адаптивный — быстр на частично отсортированных данных
- Онлайн — может сортировать поток данных

### Недостатки:
- Медленный O(n^2) на случайных данных
- Много операций сдвига

## Как работает

### Визуализация процесса

```
Исходный массив: [5, 2, 4, 6, 1, 3]

Шаг 1: Рассматриваем 2
Отсортированная часть: [5]
Вставляем 2: 2 < 5, сдвигаем 5 вправо
[2, 5 | 4, 6, 1, 3]

Шаг 2: Рассматриваем 4
Отсортированная часть: [2, 5]
Вставляем 4: 4 < 5, сдвигаем 5; 4 > 2, стоп
[2, 4, 5 | 6, 1, 3]

Шаг 3: Рассматриваем 6
Отсортированная часть: [2, 4, 5]
Вставляем 6: 6 > 5, остаётся на месте
[2, 4, 5, 6 | 1, 3]

Шаг 4: Рассматриваем 1
Отсортированная часть: [2, 4, 5, 6]
Вставляем 1: сдвигаем все, вставляем в начало
[1, 2, 4, 5, 6 | 3]

Шаг 5: Рассматриваем 3
Отсортированная часть: [1, 2, 4, 5, 6]
Вставляем 3: 3 < 4, сдвигаем 4,5,6; 3 > 2, стоп
[1, 2, 3, 4, 5, 6]
```

### Детальная визуализация вставки

```
Вставка элемента 3 в [1, 2, 4, 5, 6]:

key = 3

[1, 2, 4, 5, 6, _]   j=4: 6 > 3, сдвигаем
           ↑    ↓
[1, 2, 4, 5, _, 6]   j=3: 5 > 3, сдвигаем
        ↑    ↓
[1, 2, 4, _, 5, 6]   j=2: 4 > 3, сдвигаем
     ↑    ↓
[1, 2, _, 4, 5, 6]   j=1: 2 < 3, стоп!
      ↓
[1, 2, 3, 4, 5, 6]   Вставляем key=3 на позицию j+1=2
```

## Псевдокод

```
function insertionSort(array):
    n = length(array)

    for i from 1 to n-1:
        key = array[i]
        j = i - 1

        # Сдвигаем элементы больше key вправо
        while j >= 0 and array[j] > key:
            array[j + 1] = array[j]
            j = j - 1

        # Вставляем key на правильную позицию
        array[j + 1] = key

    return array
```

### Базовая реализация на Python

```python
def insertion_sort(arr):
    """Сортировка вставками."""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # Сдвигаем элементы больше key
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1

        # Вставляем key
        arr[j + 1] = key

    return arr
```

### Версия с бинарным поиском (Binary Insertion Sort)

```python
import bisect

def binary_insertion_sort(arr):
    """
    Сортировка вставками с бинарным поиском.
    Уменьшает количество сравнений до O(n log n),
    но сдвиги всё равно O(n^2).
    """
    for i in range(1, len(arr)):
        key = arr[i]

        # Бинарный поиск для позиции вставки
        pos = bisect.bisect_left(arr, key, 0, i)

        # Сдвигаем элементы и вставляем
        arr[pos + 1:i + 1] = arr[pos:i]
        arr[pos] = key

    return arr
```

### Рекурсивная версия

```python
def insertion_sort_recursive(arr, n=None):
    """Рекурсивная сортировка вставками."""
    if n is None:
        n = len(arr)

    if n <= 1:
        return arr

    # Сортируем первые n-1 элементов
    insertion_sort_recursive(arr, n - 1)

    # Вставляем n-й элемент
    key = arr[n - 1]
    j = n - 2

    while j >= 0 and arr[j] > key:
        arr[j + 1] = arr[j]
        j -= 1

    arr[j + 1] = key

    return arr
```

### Сортировка связанного списка

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insertion_sort_list(head):
    """Сортировка вставками для связанного списка."""
    if not head or not head.next:
        return head

    dummy = ListNode(float('-inf'))
    current = head

    while current:
        # Сохраняем следующий узел
        next_node = current.next

        # Находим позицию для вставки
        prev = dummy
        while prev.next and prev.next.val < current.val:
            prev = prev.next

        # Вставляем current после prev
        current.next = prev.next
        prev.next = current

        current = next_node

    return dummy.next
```

## Анализ сложности

| Случай | Временная сложность | Описание |
|--------|---------------------|----------|
| **Лучший** | O(n) | Уже отсортированный массив |
| **Средний** | O(n^2) | Случайный порядок |
| **Худший** | O(n^2) | Обратный порядок |

| Ресурс | Сложность |
|--------|-----------|
| **Время** | O(n^2) |
| **Память** | O(1) — in-place |
| **Стабильность** | Да |

### Подсчёт операций:
- **Лучший случай** (отсортировано): n-1 сравнение, 0 сдвигов
- **Худший случай** (обратный порядок): n(n-1)/2 сравнений и сдвигов
- **Средний случай**: ~n^2/4 сравнений и сдвигов

### Инверсии
Количество сдвигов = количество инверсий в массиве.
**Инверсия** — пара (i, j) где i < j, но arr[i] > arr[j].

```
[5, 2, 4, 6, 1, 3]
Инверсии: (5,2), (5,4), (5,1), (5,3), (2,1), (4,1), (4,3), (6,1), (6,3)
Всего: 9 инверсий = 9 сдвигов
```

## Пример с пошаговым разбором

### Сортировка массива [12, 11, 13, 5, 6]

```
Исходный: [12, 11, 13, 5, 6]

i=1, key=11:
  j=0: arr[0]=12 > 11, сдвигаем
  [12, 12, 13, 5, 6]
  j=-1: выход из цикла
  arr[0] = 11
  Результат: [11, 12, 13, 5, 6]

i=2, key=13:
  j=1: arr[1]=12 < 13, выход
  arr[2] = 13 (без изменений)
  Результат: [11, 12, 13, 5, 6]

i=3, key=5:
  j=2: arr[2]=13 > 5, сдвигаем → [11, 12, 13, 13, 6]
  j=1: arr[1]=12 > 5, сдвигаем → [11, 12, 12, 13, 6]
  j=0: arr[0]=11 > 5, сдвигаем → [11, 11, 12, 13, 6]
  j=-1: выход
  arr[0] = 5
  Результат: [5, 11, 12, 13, 6]

i=4, key=6:
  j=3: arr[3]=13 > 6, сдвигаем → [5, 11, 12, 13, 13]
  j=2: arr[2]=12 > 6, сдвигаем → [5, 11, 12, 12, 13]
  j=1: arr[1]=11 > 6, сдвигаем → [5, 11, 11, 12, 13]
  j=0: arr[0]=5 < 6, выход
  arr[1] = 6
  Результат: [5, 6, 11, 12, 13]

Итоговый массив: [5, 6, 11, 12, 13]
```

### Статистика:
- Сравнений: 1 + 1 + 3 + 4 = 9
- Сдвигов: 1 + 0 + 3 + 3 = 7

## Типичные ошибки и Edge Cases

### 1. Начало цикла с i=0 вместо i=1

```python
# ОШИБКА: первый элемент сам по себе уже "отсортирован"
def wrong_insertion(arr):
    for i in range(len(arr)):  # Должно быть range(1, len(arr))
        # ...

# ПРАВИЛЬНО
def correct_insertion(arr):
    for i in range(1, len(arr)):
        # ...
```

### 2. Забыть сохранить key

```python
# ОШИБКА: key теряется при сдвигах
def wrong_insertion(arr):
    for i in range(1, len(arr)):
        j = i - 1
        while j >= 0 and arr[j] > arr[i]:  # arr[i] изменится!
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = arr[i]  # Неправильное значение!

# ПРАВИЛЬНО
def correct_insertion(arr):
    for i in range(1, len(arr)):
        key = arr[i]  # Сохраняем значение!
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```

### 3. Пустой массив и массив из одного элемента

```python
arr = []
insertion_sort(arr)  # [] — работает

arr = [42]
insertion_sort(arr)  # [42] — работает (цикл не выполняется)
```

### 4. Сортировка по убыванию

```python
def insertion_sort_desc(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        while j >= 0 and arr[j] < key:  # Изменён знак!
            arr[j + 1] = arr[j]
            j -= 1

        arr[j + 1] = key

    return arr
```

### 5. Сортировка с ключом

```python
def insertion_sort_key(arr, key=lambda x: x):
    """Сортировка с пользовательским ключом."""
    for i in range(1, len(arr)):
        item = arr[i]
        item_key = key(item)
        j = i - 1

        while j >= 0 and key(arr[j]) > item_key:
            arr[j + 1] = arr[j]
            j -= 1

        arr[j + 1] = item

    return arr

# Пример: сортировка кортежей по второму элементу
data = [(1, 'c'), (2, 'a'), (3, 'b')]
insertion_sort_key(data, key=lambda x: x[1])
print(data)  # [(2, 'a'), (3, 'b'), (1, 'c')]
```

### 6. Использование в гибридных алгоритмах

```python
def hybrid_sort(arr, threshold=32):
    """
    Гибридная сортировка:
    Insertion Sort для маленьких массивов,
    Merge Sort для больших.
    """
    if len(arr) <= threshold:
        return insertion_sort(arr.copy())
    else:
        return merge_sort(arr)  # Предполагается реализация merge_sort
```

### Рекомендации:
1. Insertion Sort отлично подходит для почти отсортированных данных
2. Используйте для маленьких массивов (< 50 элементов)
3. Рассмотрите Binary Insertion Sort для уменьшения сравнений
4. Помните, что это стабильная сортировка
5. В реальных системах используется как часть гибридных алгоритмов (Timsort)
