# Майнинг и экономические стимулы в блокчейне

## Введение

Майнинг (добыча) — это фундаментальный процесс, обеспечивающий работу децентрализованных блокчейн-сетей. Он выполняет две ключевые функции: создание новых монет и валидация транзакций. В этой главе мы разберём, как работает майнинг, какие экономические стимулы им движут и почему эта система остаётся устойчивой.

---

## 1. Что такое майнинг

### Определение

**Майнинг** — это процесс добавления новых блоков в блокчейн путём решения криптографических задач. Термин произошёл от английского "mining" (добыча полезных ископаемых), поскольку процесс напоминает добычу золота: требует затрат ресурсов и вознаграждается ценным активом.

### Роль майнеров в сети

Майнеры выполняют несколько критически важных функций:

1. **Валидация транзакций** — проверяют, что отправитель имеет достаточно средств и транзакция корректно подписана
2. **Формирование блоков** — собирают транзакции из мемпула в блоки
3. **Обеспечение безопасности** — делают невыгодным изменение истории транзакций
4. **Эмиссия новых монет** — получают вознаграждение в виде новых криптомонет
5. **Достижение консенсуса** — определяют, какая версия блокчейна является канонической

### Процесс добычи блока

```
┌─────────────────────────────────────────────────────────────┐
│                    ПРОЦЕСС МАЙНИНГА                         │
├─────────────────────────────────────────────────────────────┤
│  1. Сбор транзакций из мемпула                              │
│           ↓                                                 │
│  2. Формирование блока (header + transactions)              │
│           ↓                                                 │
│  3. Подбор nonce для достижения target hash                 │
│           ↓                                                 │
│  4. Если hash < target → блок найден!                       │
│     Если hash >= target → увеличить nonce, повторить        │
│           ↓                                                 │
│  5. Трансляция блока в сеть                                 │
│           ↓                                                 │
│  6. Другие ноды проверяют и принимают блок                  │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. Proof of Work (PoW)

### Механизм работы

**Proof of Work** (Доказательство работы) — алгоритм консенсуса, требующий от майнеров выполнения вычислительной работы для добавления блока. Идея в том, что честные участники должны контролировать большую часть вычислительной мощности сети.

Основной принцип PoW:
- Задача должна быть **сложной для решения** (требует много вычислений)
- Решение должно быть **легко проверяемым** (одна операция хеширования)

### Сложность (Difficulty)

**Сложность** — параметр, определяющий, насколько трудно найти валидный хеш блока. В Bitcoin сложность автоматически корректируется каждые 2016 блоков (~2 недели), чтобы среднее время нахождения блока составляло 10 минут.

```python
# Упрощённая формула корректировки сложности
def adjust_difficulty(current_difficulty: int, actual_time: int, expected_time: int) -> int:
    """
    Корректировка сложности на основе времени нахождения предыдущих блоков.

    Args:
        current_difficulty: текущая сложность
        actual_time: фактическое время на 2016 блоков (в секундах)
        expected_time: ожидаемое время (2016 * 10 минут = 1209600 секунд)

    Returns:
        новая сложность
    """
    # Ограничение: сложность не может измениться более чем в 4 раза
    if actual_time < expected_time // 4:
        actual_time = expected_time // 4
    elif actual_time > expected_time * 4:
        actual_time = expected_time * 4

    new_difficulty = current_difficulty * expected_time // actual_time
    return new_difficulty
```

**Target (цель)** — это число, ниже которого должен быть хеш блока:

```
target = max_target / difficulty
```

Чем выше сложность, тем меньше target и тем сложнее найти подходящий хеш.

### Nonce и хеширование

**Nonce** (Number used once) — это 32-битное число, которое майнер изменяет при каждой попытке найти валидный хеш.

Структура заголовка блока Bitcoin:
```
┌──────────────────────────────────────────────────────────┐
│                   BLOCK HEADER (80 bytes)                │
├──────────────────────────────────────────────────────────┤
│  Version (4 bytes)         - версия протокола           │
│  Previous Block Hash (32)  - хеш предыдущего блока      │
│  Merkle Root (32)          - корень дерева транзакций   │
│  Timestamp (4)             - время создания             │
│  Bits (4)                  - закодированная сложность   │
│  Nonce (4)                 - перебираемое значение      │
└──────────────────────────────────────────────────────────┘
```

### Пример алгоритма поиска nonce

```python
import hashlib
import time

def sha256_double(data: bytes) -> bytes:
    """Двойное хеширование SHA-256 (как в Bitcoin)."""
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

def calculate_hash(block_header: bytes) -> str:
    """Вычисление хеша блока."""
    hash_bytes = sha256_double(block_header)
    # В Bitcoin хеш отображается в little-endian
    return hash_bytes[::-1].hex()

def mine_block(block_data: str, difficulty_bits: int) -> tuple[int, str]:
    """
    Простая симуляция майнинга.

    Args:
        block_data: данные блока (без nonce)
        difficulty_bits: количество ведущих нулей в хеше

    Returns:
        (найденный nonce, хеш блока)
    """
    target = '0' * difficulty_bits  # Хеш должен начинаться с N нулей
    nonce = 0
    max_nonce = 2**32  # 4 миллиарда попыток

    start_time = time.time()

    while nonce < max_nonce:
        # Формируем данные для хеширования
        data = f"{block_data}{nonce}".encode()
        hash_result = hashlib.sha256(data).hexdigest()

        # Проверяем, начинается ли хеш с нужного количества нулей
        if hash_result.startswith(target):
            elapsed = time.time() - start_time
            print(f"Блок найден за {elapsed:.2f} секунд")
            print(f"Количество попыток: {nonce + 1}")
            return nonce, hash_result

        nonce += 1

    raise Exception("Nonce не найден в диапазоне")

# Демонстрация
if __name__ == "__main__":
    block_data = "prev_hash:abc123|transactions:tx1,tx2,tx3|timestamp:1234567890"

    print("Майнинг с difficulty=4 (4 ведущих нуля):")
    nonce, block_hash = mine_block(block_data, difficulty_bits=4)
    print(f"Nonce: {nonce}")
    print(f"Hash:  {block_hash}")
```

Пример вывода:
```
Майнинг с difficulty=4 (4 ведущих нуля):
Блок найден за 0.23 секунд
Количество попыток: 52841
Nonce: 52840
Hash:  0000a8f2b1c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9
```

---

## 3. Награды и комиссии

### Block Reward (награда за блок)

**Block reward** — это количество новых монет, которые майнер получает за найденный блок. Это основной источник дохода майнеров и механизм эмиссии криптовалюты.

```
┌────────────────────────────────────────────────────────────┐
│              НАГРАДА ЗА БЛОК BITCOIN                       │
├────────────────────────────────────────────────────────────┤
│  2009: 50 BTC       │  2012: 25 BTC      │  2016: 12.5 BTC │
│  2020: 6.25 BTC     │  2024: 3.125 BTC   │  2028: ~1.56 BTC│
└────────────────────────────────────────────────────────────┘
```

### Transaction Fees (комиссии за транзакции)

Комиссии — это плата, которую пользователи добавляют к транзакциям, чтобы мотивировать майнеров включить их в блок.

```python
def calculate_fee_rate(transaction_size_bytes: int, fee_satoshis: int) -> float:
    """
    Расчёт fee rate (sat/vB) для транзакции.

    Майнеры обычно сортируют транзакции по fee rate и включают
    наиболее выгодные в блок первыми.
    """
    return fee_satoshis / transaction_size_bytes

# Пример: транзакция 250 байт с комиссией 5000 сатоши
fee_rate = calculate_fee_rate(250, 5000)
print(f"Fee rate: {fee_rate} sat/vB")  # 20 sat/vB
```

### Halving (уменьшение награды)

**Halving** — это событие уменьшения награды за блок вдвое, происходящее каждые 210,000 блоков (примерно раз в 4 года).

```python
def get_block_reward(block_height: int) -> float:
    """
    Вычисление награды за блок по его высоте.

    Args:
        block_height: номер блока в цепочке

    Returns:
        награда в BTC
    """
    initial_reward = 50  # BTC
    halving_interval = 210_000  # блоков

    halvings = block_height // halving_interval

    # После ~64 халвингов награда станет меньше 1 сатоши
    if halvings >= 64:
        return 0

    reward = initial_reward / (2 ** halvings)
    return reward

# Примеры
print(f"Блок 0:       {get_block_reward(0)} BTC")        # 50 BTC
print(f"Блок 210000:  {get_block_reward(210000)} BTC")   # 25 BTC
print(f"Блок 840000:  {get_block_reward(840000)} BTC")   # 3.125 BTC
```

### Экономическая модель Bitcoin

```
Максимальное количество BTC:  21,000,000
Текущая эмиссия (~2024):      ~19,600,000 BTC (93%)
Последний BTC будет добыт:    ~2140 год

┌─────────────────────────────────────────────────────────────┐
│                  МОДЕЛЬ ДЕФЛЯЦИИ BITCOIN                    │
├─────────────────────────────────────────────────────────────┤
│  • Ограниченное предложение создаёт дефицит                │
│  • Halving уменьшает инфляцию со временем                  │
│  • В долгосрочной перспективе майнеры будут жить           │
│    только на комиссии за транзакции                        │
│  • Stock-to-Flow модель предсказывает рост цены            │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Экономические стимулы

### Почему майнеры честны

Ключевой вопрос: почему рациональные майнеры следуют правилам протокола?

**Ответ**: Потому что это экономически выгоднее, чем мошенничество.

```
ЧЕСТНОЕ ПОВЕДЕНИЕ:
  Затраты: электричество + оборудование
  Доход:   награда за блок + комиссии (в BTC)

НЕЧЕСТНОЕ ПОВЕДЕНИЕ:
  Затраты: те же
  Доход:   0 (нечестный блок будет отвергнут сетью)
           + убытки от обесценивания BTC
           + потеря репутации
```

### Теория игр в майнинге

Майнинг можно рассматривать через призму теории игр:

```python
def mining_game_analysis():
    """
    Матрица выигрышей в упрощённой модели майнинга.
    Два майнера выбирают: честно майнить или атаковать.
    """
    payoff_matrix = {
        ("честно", "честно"): (10, 10),   # Оба получают справедливую долю
        ("честно", "атака"):  (0, 15),    # Атакующий временно выигрывает
        ("атака", "честно"):  (15, 0),    # Атакующий временно выигрывает
        ("атака", "атака"):   (-20, -20), # Сеть падает, все теряют
    }

    # Долгосрочно: атака обесценивает криптовалюту
    # Равновесие Нэша: (честно, честно)

    return payoff_matrix
```

**Доминирующая стратегия** — честное поведение, потому что:
1. Нечестные блоки отвергаются сетью
2. Успешная атака обесценивает монету (майнер теряет свои накопления)
3. Оборудование становится бесполезным

### Атака 51%

**Атака 51%** — ситуация, когда злоумышленник контролирует большую часть хешрейта сети и может:
- Отменять свои транзакции (double-spending)
- Блокировать транзакции других участников
- Получать все награды за блоки

```python
def calculate_attack_cost(network_hashrate_th: float,
                          electricity_cost_kwh: float,
                          asic_efficiency_jth: float,
                          attack_duration_hours: int) -> dict:
    """
    Оценка стоимости атаки 51%.

    Args:
        network_hashrate_th: хешрейт сети в TH/s
        electricity_cost_kwh: стоимость электричества $/kWh
        asic_efficiency_jth: эффективность ASIC в J/TH
        attack_duration_hours: длительность атаки

    Returns:
        словарь с оценкой затрат
    """
    # Нужно контролировать 51% хешрейта
    attack_hashrate = network_hashrate_th * 0.51

    # Потребление энергии
    power_watts = attack_hashrate * asic_efficiency_jth
    power_kwh = power_watts * attack_duration_hours / 1000

    # Стоимость электричества
    electricity_cost = power_kwh * electricity_cost_kwh

    # Стоимость оборудования (примерно $50/TH для ASIC)
    equipment_cost = attack_hashrate * 50

    return {
        "required_hashrate_th": attack_hashrate,
        "electricity_cost_usd": electricity_cost,
        "equipment_cost_usd": equipment_cost,
        "total_cost_usd": electricity_cost + equipment_cost
    }

# Пример для Bitcoin (~500 EH/s = 500,000,000 TH/s)
attack_cost = calculate_attack_cost(
    network_hashrate_th=500_000_000,
    electricity_cost_kwh=0.05,
    asic_efficiency_jth=30,  # Джоулей на TH
    attack_duration_hours=1
)
print(f"Стоимость 1-часовой атаки: ${attack_cost['total_cost_usd']:,.0f}")
```

### Затраты на электроэнергию

Майнинг потребляет огромное количество электроэнергии:

```
┌─────────────────────────────────────────────────────────────┐
│         ЭНЕРГОПОТРЕБЛЕНИЕ BITCOIN (~2024)                   │
├─────────────────────────────────────────────────────────────┤
│  Годовое потребление:    ~150 TWh                          │
│  Сравнение:              ≈ Аргентина или Норвегия          │
│  CO2 выбросы:            ~70 Mt в год                      │
│  Доля возобновляемых:    ~50-60%                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. Майнинг пулы

### Зачем нужны пулы

Вероятность соло-майнера найти блок крайне мала. При хешрейте сети 500 EH/s и собственном ASIC на 100 TH/s:

```python
def calculate_solo_mining_probability(
    personal_hashrate_th: float,
    network_hashrate_th: float,
    blocks_per_day: int = 144
) -> dict:
    """
    Расчёт вероятности найти блок при соло-майнинге.
    """
    # Доля от общего хешрейта
    share = personal_hashrate_th / network_hashrate_th

    # Ожидаемое время до нахождения блока
    blocks_per_year = blocks_per_day * 365
    expected_days = 1 / (share * blocks_per_day)
    expected_years = expected_days / 365

    return {
        "network_share": f"{share * 100:.10f}%",
        "expected_days": expected_days,
        "expected_years": expected_years,
        "probability_per_block": share
    }

# Соло-майнер с одним ASIC (100 TH/s) против сети (500 EH/s)
result = calculate_solo_mining_probability(100, 500_000_000_000)
print(f"Доля сети: {result['network_share']}")
print(f"Ожидаемое время до блока: {result['expected_years']:.0f} лет")
```

**Пулы** объединяют хешрейт многих майнеров, распределяя награду пропорционально вкладу каждого.

### Распределение наград

Основные схемы выплат в пулах:

| Схема | Описание | Риск для майнера |
|-------|----------|------------------|
| **PPS** (Pay Per Share) | Фиксированная плата за каждую шару | Низкий |
| **PPLNS** (Pay Per Last N Shares) | Награда от последних N шар | Средний |
| **FPPS** (Full Pay Per Share) | PPS + комиссии за транзакции | Низкий |
| **PROP** (Proportional) | Пропорционально шарам в раунде | Высокий |

```python
def calculate_pps_payout(
    shares_submitted: int,
    pool_difficulty: int,
    network_difficulty: int,
    block_reward: float
) -> float:
    """
    Расчёт выплаты по схеме PPS.

    Майнер получает фиксированную сумму за каждую принятую шару,
    независимо от того, нашёл ли пул блок.
    """
    # Ожидаемое количество шар для нахождения блока
    expected_shares = network_difficulty / pool_difficulty

    # Выплата за одну шару
    payout_per_share = block_reward / expected_shares

    # Общая выплата
    total_payout = shares_submitted * payout_per_share

    return total_payout
```

### Популярные пулы (2024)

```
┌─────────────────────────────────────────────────────────────┐
│              КРУПНЕЙШИЕ BITCOIN-ПУЛЫ                        │
├─────────────────────────────────────────────────────────────┤
│  1. Foundry USA      ~30%   │  США                         │
│  2. AntPool          ~15%   │  Китай (Bitmain)             │
│  3. F2Pool           ~12%   │  Китай                       │
│  4. Binance Pool     ~10%   │  Международный               │
│  5. ViaBTC           ~8%    │  Китай                       │
└─────────────────────────────────────────────────────────────┘

⚠️  Концентрация хешрейта — риск для децентрализации!
```

---

## 6. Альтернативы PoW

### Proof of Stake: краткое сравнение

| Параметр | Proof of Work | Proof of Stake |
|----------|---------------|----------------|
| Ресурс | Вычислительная мощность | Заблокированные монеты |
| Энергопотребление | Высокое | Минимальное |
| Оборудование | Специализированное (ASIC) | Обычный компьютер |
| Безопасность | Затраты на атаку | Риск потери стейка |
| Децентрализация | Капиталоёмкий барьер | Богатые становятся богаче |
| Примеры | Bitcoin, Litecoin | Ethereum 2.0, Cardano |

### Экологические проблемы PoW

**Критика:**
- Огромное потребление электроэнергии
- Углеродный след (зависит от источника энергии)
- Электронные отходы от устаревшего оборудования

**Контраргументы:**
- Майнинг стимулирует развитие возобновляемой энергетики
- Использует избыточную/дешёвую энергию
- Потребление традиционной финансовой системы сопоставимо

---

## Заключение

Майнинг — это не просто процесс создания новых монет, а сложная система экономических стимулов, обеспечивающая безопасность и децентрализацию блокчейна. Понимание этих механизмов критически важно для:

- Оценки безопасности криптовалютных сетей
- Принятия инвестиционных решений
- Разработки новых консенсус-алгоритмов
- Понимания экономики криптовалют

---

## Дополнительные ресурсы

- [Bitcoin Whitepaper](https://bitcoin.org/bitcoin.pdf) — оригинальная статья Сатоши Накамото
- [Mastering Bitcoin, Ch. 10](https://github.com/bitcoinbook/bitcoinbook) — глубокое погружение в майнинг
- [Cambridge Bitcoin Electricity Consumption Index](https://ccaf.io/cbeci/index) — мониторинг энергопотребления
